// Code generated by cborgen runtime DO NOT EDIT.

package metasnapshot

import (
	"io"
	"sync"

	// Local byte buffer pool under our control.
	//
	// Guidelines:
	// - Do not call Reset() before Put() unless you intend to reuse the buffer
	//   before putting it back. The pool does not require Reset() before Put().
	// - Use Ensure(n) to grow capacity up-front when you know you will append
	//   at least n more bytes. This avoids repeated reallocations.

	// GetByteBuffer obtains a pooled ByteBuffer. The buffer is Reset() before
	// being returned so length is zero (capacity may be reused).

	// GetMinSize obtains a pooled ByteBuffer with capacity for at least size bytes.
	// The buffer is Reset() and then grown if needed.
	"encoding/base64"
	"encoding/hex"
	"errors"
	"fmt"
	"math"
	"reflect"
	"strconv"
	"unicode/utf8"

	"encoding/json"

	"encoding/binary"
	"math/big"
	"math/bits"
	"regexp"
	"strings"
	"time"

	"bytes"
	bigmath "math/big"
	"unsafe"

	"sort"
)

type ByteBuffer struct {
	b []byte
}

var bbPool = sync.Pool{New: func() any { return &ByteBuffer{b: make([]byte, 0, 1024)} }}

func GetByteBuffer() *ByteBuffer {
	bb := bbPool.Get().(*ByteBuffer)
	bb.Reset()
	return bb
}

func GetMinSize(size int) *ByteBuffer {
	bb := bbPool.Get().(*ByteBuffer)
	bb.Reset()
	if size > 0 {
		bb.Ensure(size)
	}
	return bb
}

// PutByteBuffer returns the buffer to the pool. The content is left intact
// (no implicit Reset). Call Reset() yourself if you want to clear before reuse
// without returning to the pool.
// PutByteBuffer returns the buffer to the pool after Resetting length to zero.
func PutByteBuffer(bb *ByteBuffer) { bb.Reset(); bbPool.Put(bb) }

// Bytes returns the underlying bytes.
func (bb *ByteBuffer) Bytes() []byte { return bb.b }

// Len returns length.
func (bb *ByteBuffer) Len() int { return len(bb.b) }

// Cap returns capacity.
func (bb *ByteBuffer) Cap() int { return cap(bb.b) }

// Reset resets the length to zero; capacity is unchanged.
func (bb *ByteBuffer) Reset() { bb.b = bb.b[:0] }

// Ensure ensures there is room for at least n more bytes without reallocation.
// If needed, it grows the underlying slice.
func (bb *ByteBuffer) Ensure(n int) {
	need := len(bb.b) + n
	if cap(bb.b) >= need {
		return
	}
	// Grow: double until enough, then allocate
	c := cap(bb.b)
	if c == 0 {
		c = 1024
	}
	for c < need {
		c <<= 1
	}
	nb := make([]byte, len(bb.b), c)
	copy(nb, bb.b)
	bb.b = nb
}

// Extend grows the buffer by n bytes and returns a slice to the newly
// appended region for direct writes. The buffer length is advanced by n.
func (bb *ByteBuffer) Extend(n int) []byte {
	old := len(bb.b)
	bb.Ensure(n)
	bb.b = bb.b[:old+n]
	return bb.b[old:]
}

// Write implements io.Writer.
func (bb *ByteBuffer) Write(p []byte) (int, error) {
	bb.Ensure(len(p))
	bb.b = append(bb.b, p...)
	return len(p), nil
}

// WriteString appends a string.
func (bb *ByteBuffer) WriteString(s string) (int, error) {
	bb.Ensure(len(s))
	bb.b = append(bb.b, s...)
	return len(s), nil
}

// WriteByte appends a single byte.
func (bb *ByteBuffer) WriteByte(c byte) error {
	bb.Ensure(1)
	bb.b = append(bb.b, c)
	return nil
}

// ReadFrom implements io.ReaderFrom for efficient streaming into the buffer.
func (bb *ByteBuffer) ReadFrom(r io.Reader) (int64, error) {
	var total int64
	for {
		// Grow a chunk (~32KB) if no free space
		if cap(bb.b)-len(bb.b) < 32*1024 {
			bb.Ensure(32 * 1024)
		}
		// Read into free tail
		n, err := r.Read(bb.b[len(bb.b):cap(bb.b)])
		if n > 0 {
			bb.b = bb.b[:len(bb.b)+n]
			total += int64(n)
		}
		if err != nil {
			if err == io.EOF {
				return total, nil
			}
			return total, err
		}
	}
}

// Convenience CBOR appenders on ByteBuffer
// These mirror the package-level AppendXxx functions but operate directly on
// the ByteBuffer, enabling a fluent, zero-alloc style when combined with
// upfront Ensure()/GetMinSize().

// This package is the support library for the cborp code generator.
//
// This package defines the utilities used by the cborp code generator for encoding and decoding CBOR
// from []byte and io.Reader/io.Writer types. Much of this package is devoted to helping the cborp code
// generator implement the Marshaler/Unmarshaler and Encodable/Decodable interfaces.
//
// This package defines four "families" of functions:
//   - AppendXxxx() appends an object to a []byte in CBOR encoding.
//   - ReadXxxxBytes() reads an object from a []byte and returns the remaining bytes.
//   - (*Writer).WriteXxxx() writes an object to the buffered *Writer type.
//   - (*Reader).ReadXxxx() reads an object from a buffered *Reader type.
//
// Once a type has satisfied the `Encodable` and `Decodable` interfaces,
// it can be written and read from arbitrary `io.Writer`s and `io.Reader`s using
//
//	cbor.Encode(io.Writer, cbor.Encodable)
//
// and
//
//	cbor.Decode(io.Reader, cbor.Decodable)

// RawPair represents an already-encoded CBOR key/value pair.
// Key and Value must each contain exactly one CBOR item.

// recursionLimit is the limit of recursive calls.
// This limits the call depth of dynamic code, like Skip and interface conversions.

// ErrNonCanonicalFloat is returned when a float is not encoded in the shortest form (strict mode).

// ErrContainerTooLarge is returned when a container length exceeds configured Reader limits.

// CBOR major types (3 bits)

// unsigned integer
// negative integer
// byte string
// text string (UTF-8)
// array
// map
// semantic tag
// float, simple values, break

// Additional info values (5 bits)

// 0-23: literal value
// max direct value
// 1-byte uint8 follows
// 2-byte uint16 follows
// 4-byte uint32 follows
// 8-byte uint64 follows
// indefinite length (for bytes, text, array, map)

// Simple values in major type 7

// Common CBOR semantic tags

// RFC3339 date/time string
// Unix timestamp (int or float)
// Positive bignum
// Negative bignum
// Decimal fraction
// Bigfloat
// Expected base64url encoding
// Expected base64 encoding
// Expected base16 encoding
// Embedded CBOR data item
// URI
// base64url
// base64
// Regular expression
// MIME message
// Self-describe CBOR (0xd9d9f7)

// makeByte creates a CBOR initial byte from major type and additional info

// getMajorType extracts the major type from a CBOR initial byte

func (bb *ByteBuffer) AppendMapHeader(sz uint32) *

// getAddInfo extracts the additional info from a CBOR initial byte

ByteBuffer {
	bb.b = AppendMapHeader(bb.b, sz)
	return bb
}

func (bb *ByteBuffer) AppendArrayHeader(sz uint32) *

// Type represents CBOR data types

ByteBuffer {
	bb.b = AppendArrayHeader(bb.

		// CBOR Types

		b, sz)
	return bb
}

func (bb *ByteBuffer) AppendArrayHeaderIndefinite(

// text string

) *ByteBuffer {

	// byte string

	bb.b = AppendArrayHeaderIndefinite(

		// map

		bb.b)
	return bb

	// array

}

func (bb *ByteBuffer) AppendBreak(

// float64

) *ByteBuffer {

	// float32

	bb.b = AppendBreak(

		// bool

		bb.b)
	return bb

	// signed integer

}

func (bb *ByteBuffer) AppendString(

	// unsigned integer

	s string) *ByteBuffer {

	// nil

	bb.b = AppendString(bb.

		// duration (encoded as int64)

		b, s)
	return bb
}

func (bb *ByteBuffer) AppendBytes(

	// tagged value

	bs []byte) *ByteBuffer {

	// time (tagged epoch timestamp)

	bb.b = AppendBytes(bb.b, bs)

	// String implements fmt.Stringer

	return bb
}

func (bb *ByteBuffer) AppendInt64(i int64) *ByteBuffer {
	bb.b = AppendInt64(bb.b, i)
	return bb
}

func (bb *ByteBuffer) AppendUint64(u uint64) *ByteBuffer {
	bb.b = AppendUint64(bb.b, u)
	return bb
}

func (bb *ByteBuffer) AppendBool(v bool) *ByteBuffer {
	bb.b = AppendBool(bb.b, v)
	return bb
}

func (bb *ByteBuffer) AppendFloat64(f float64) *ByteBuffer {
	bb.b = AppendFloat64(bb.b, f)
	return bb
}

func (bb *ByteBuffer) AppendFloat32(f float32) *ByteBuffer {
	bb.b = AppendFloat32(bb.b, f)

	// Marshaler is the interface implemented by types that know how to marshal
	// themselves as CBOR. MarshalCBOR appends the marshalled form to the provided
	// byte slice, returning the extended slice and any errors encountered.

	return bb
}

func (bb *ByteBuffer) AppendTag(tag uint64) *ByteBuffer {
	bb.b = AppendTag(bb.b, tag)
	return bb
}

type RawPair struct {
	Key   []byte
	Value []byte
}

const (
	recursionLimit = 100000
)

var ErrNonCanonicalFloat = errors.New("cbor: non-canonical float encoding")

var ErrContainerTooLarge = errors.New("cbor: container too large")

const (
	majorTypeUint   = 0
	majorTypeNegInt = 1
	majorTypeBytes  = 2
	majorTypeText   = 3
	majorTypeArray  = 4
	majorTypeMap    = 5
	majorTypeTag    = 6
	majorTypeSimple = 7
)

const (
	addInfoDirect     = 23
	addInfoUint8      = 24
	addInfoUint16     = 25
	addInfoUint32     = 26
	addInfoUint64     = 27
	addInfoIndefinite = 31
)

const (
	simpleFalse     = 20
	simpleTrue      = 21
	simpleNull      = 22
	simpleUndefined = 23
	simpleFloat16   = 25
	simpleFloat32   = 26
	simpleFloat64   = 27
	simpleBreak     = 31
)

const (
	tagDateTimeString   = 0
	tagEpochDateTime    = 1
	tagPosBignum        = 2
	tagNegBignum        = 3
	tagDecimalFrac      = 4
	tagBigfloat         = 5
	tagBase64URL        = 21
	tagBase64           = 22
	tagBase16           = 23
	tagCBOR             = 24
	tagURI              = 32
	tagBase64URLString  = 33
	tagBase64String     = 34
	tagRegexp           = 35
	tagMIME             = 36
	tagSelfDescribeCBOR = 55799
)

func makeByte(majorType, addInfo uint8) byte {
	return byte((majorType << 5) | addInfo)
}

func getMajorType(b byte) uint8 {
	return (b >> 5) & 0x07
}

func getAddInfo(b byte) uint8 {
	return b & 0x1f
}

type Type byte

const (
	InvalidType Type = iota

	StrType
	BinType
	MapType
	ArrayType
	Float64Type
	Float32Type
	BoolType
	IntType
	UintType
	NilType
	DurationType
	ExtensionType
	TimeType
)

func (t Type) String() string {
	switch t {
	case StrType:
		return "str"
	case BinType:
		return "bin"
	case MapType:
		return "map"
	case ArrayType:
		return "array"
	case Float64Type:
		return "float64"
	case Float32Type:
		return "float32"
	case BoolType:
		return "bool"
	case UintType:
		return "uint"
	case IntType:
		return "int"
	case ExtensionType:
		return "ext"
	case NilType:
		return "nil"
	case TimeType:
		return "time"
	case DurationType:
		return "duration"
	default:
		return "<invalid>"
	}
}

type Marshaler interface {
	MarshalCBOR([]byte) ([]byte, error)
}

// Unmarshaler is the interface fulfilled by objects that know how to unmarshal
// themselves from CBOR. UnmarshalCBOR unmarshals the object from binary,
// returning any leftover bytes and any errors encountered.
type Unmarshaler interface {
	UnmarshalCBOR([]byte) ([]byte, error)
}

// ValidateUTF8OnDecode controls whether ReadStringBytes validates UTF-8.
// Enabled by default for spec compliance; can be disabled in hot paths.
var ValidateUTF8OnDecode = true

// UnsafeStringDecode controls whether ReadStringBytes converts zero-copy using
// UnsafeString (unsafe) instead of allocating a new string. Disabled by default.
var UnsafeStringDecode = false

func DiagBytes(b []byte) (string, []byte, error) {
	bb := GetByteBuffer()
	defer PutByteBuffer(bb)
	rest, err := diagOneBuf(bb, b, 0)
	if err != nil {
		return "", b, err
	}
	out := make([]byte, bb.Len())
	copy(out, bb.Bytes())
	return string(out), rest, nil
}

func diagOneBuf(buf *ByteBuffer, b []byte, depth int) ([]byte, error) {
	if depth > recursionLimit {
		return b, ErrMaxDepthExceeded
	}
	if len(b) < 1 {
		return b, ErrShortBytes
	}
	maj := getMajorType(b[0])
	add := getAddInfo(b[0])

	switch maj {
	case majorTypeUint:
		u, o, err := readUintCore(b, majorTypeUint)
		if err != nil {
			return b, err
		}
		buf.WriteString(strconv.FormatUint(u, 10))
		return o, nil
	case majorTypeNegInt:
		u, o, err := readUintCore(b, majorTypeNegInt)
		if err != nil {
			return b, err
		}
		n := int64(-1) - int64(u)
		buf.WriteString(strconv.FormatInt(n, 10))
		return o, nil
	case majorTypeBytes:
		if add == addInfoIndefinite {
			p := b[1:]
			buf.WriteString("(_")
			first := true
			for {
				if len(p) < 1 {
					return b, ErrShortBytes
				}
				if p[0] == makeByte(majorTypeSimple, simpleBreak) {
					buf.WriteString(")")
					return p[1:], nil
				}
				sz, o, err := readUintCore(p, majorTypeBytes)
				if err != nil {
					return b, err
				}
				if uint64(len(o)) < sz {
					return b, ErrShortBytes
				}
				if !first {
					buf.WriteString(", ")
				} else {
					buf.WriteString(" ")
					first = false
				}
				buf.WriteString("h'")
				d := buf.Extend(hex.EncodedLen(int(sz)))
				hex.Encode(d, o[:sz])
				buf.WriteString("'")
				p = o[sz:]
			}
		}
		bs, o, err := ReadBytesBytes(b, nil)
		if err != nil {
			return b, err
		}
		buf.WriteString("h'")
		d := buf.Extend(hex.EncodedLen(len(bs)))
		hex.Encode(d, bs)
		buf.WriteString("'")
		return o, nil
	case majorTypeText:
		if add == addInfoIndefinite {
			p := b[1:]
			buf.WriteString("(_")
			first := true
			for {
				if len(p) < 1 {
					return b, ErrShortBytes
				}
				if p[0] == makeByte(majorTypeSimple, simpleBreak) {
					buf.WriteString(")")
					return p[1:], nil
				}
				chunk, o, err := ReadStringZC(p)
				if err != nil {
					return b, err
				}
				q := strconv.Quote(string(chunk))
				if !first {
					buf.WriteString(", ")
				} else {
					buf.WriteString(" ")
					first = false
				}
				buf.WriteString(q)
				p = o
			}
		}
		s, o, err := ReadStringBytes(b)
		if err != nil {
			return b, err
		}
		buf.WriteString(strconv.Quote(s))
		return o, nil
	case majorTypeArray:
		if add == addInfoIndefinite {
			p := b[1:]
			buf.WriteString("[_")
			first := true
			for {
				if len(p) < 1 {
					return b, ErrShortBytes
				}
				if p[0] == makeByte(majorTypeSimple, simpleBreak) {
					buf.WriteString("]")
					return p[1:], nil
				}
				if !first {
					buf.WriteString(", ")
				} else {
					buf.WriteString(" ")
					first = false
				}
				var err error
				p, err = diagOneBuf(buf, p, depth+1)
				if err != nil {
					return b, err
				}
			}
		}
		sz, p, err := readUintCore(b, majorTypeArray)
		if err != nil {
			return b, err
		}
		buf.WriteString("[")
		for i := uint64(0); i < sz; i++ {
			if i > 0 {
				buf.WriteString(", ")
			}
			var err error
			p, err = diagOneBuf(buf, p, depth+1)
			if err != nil {
				return b, err
			}
		}
		buf.WriteString("]")
		return p, nil
	case majorTypeMap:
		if add == addInfoIndefinite {
			p := b[1:]
			buf.WriteString("{_")
			first := true
			for {
				if len(p) < 1 {
					return b, ErrShortBytes
				}
				if p[0] == makeByte(majorTypeSimple, simpleBreak) {
					buf.WriteString("}")
					return p[1:], nil
				}
				if !first {
					buf.WriteString(", ")
				} else {
					buf.WriteString(" ")
					first = false
				}

				var err error
				p, err = diagOneBuf(buf, p, depth+1)
				if err != nil {
					return b, err
				}
				buf.WriteString(": ")

				p, err = diagOneBuf(buf, p, depth+1)
				if err != nil {
					return b, err
				}
			}
		}
		sz, p, err := readUintCore(b, majorTypeMap)
		if err != nil {
			return b, err
		}
		buf.WriteString("{")
		for i := uint64(0); i < sz; i++ {
			if i > 0 {
				buf.WriteString(", ")
			}
			var err error
			p, err = diagOneBuf(buf, p, depth+1)
			if err != nil {
				return b, err
			}
			buf.WriteString(": ")
			p, err = diagOneBuf(buf, p, depth+1)
			if err != nil {
				return b, err
			}
		}
		buf.WriteString("}")
		return p, nil
	case majorTypeTag:
		tag, o, err := ReadTagBytes(b)
		if err != nil {
			return b, err
		}
		buf.WriteString(strconv.FormatUint(tag, 10))
		buf.WriteString("(")
		o2, err := diagOneBuf(buf, o, depth+1)
		if err != nil {
			return b, err
		}
		buf.WriteString(")")
		return o2, nil
	case majorTypeSimple:
		switch add {
		case simpleFalse:

			// (duplicate removed)

			// DiagBytes renders the next CBOR item in RFC diagnostic notation and returns the remaining bytes.

			// key

			// value

			// key

			// value

			buf.WriteString("false")
			return b[1:], nil
		case simpleTrue:
			buf.WriteString("true")
			return b[1:], nil
		case simpleNull:
			buf.WriteString("null")
			return b[1:], nil
		case simpleUndefined:
			buf.WriteString("undefined")
			return b[1:], nil
		case simpleFloat16:
			f, o, err := ReadFloat16Bytes(b)
			if err != nil {
				return b, err
			}
			buf.WriteString(formatFloat32Diag(f))
			return o, nil
		case simpleFloat32:
			f, o, err := ReadFloat32Bytes(b)
			if err != nil {
				return b, err
			}
			buf.WriteString(formatFloat32Diag(f))
			return o, nil
		case simpleFloat64:
			f, o, err := ReadFloat64Bytes(b)
			if err != nil {
				return b, err
			}
			buf.WriteString(formatFloat64Diag(f))
			return o, nil
		default:
			if add < 20 {
				buf.WriteString(fmt.Sprintf("simple(%d)", add))
				return b[1:], nil
			}
			if add == addInfoUint8 {
				if len(b) < 2 {
					return b, ErrShortBytes
				}
				buf.WriteString(fmt.Sprintf("simple(%d)", b[1]))
				return b[2:], nil
			}
			return b, &ErrUnsupportedType{}
		}
	}
	return b, &ErrUnsupportedType{}
}

// formatFloat64Diag returns a diagnostic string for float64 matching RFC examples
func formatFloat64Diag(f float64) string {
	if math.IsInf(f, +1) {
		return "Infinity"
	}
	if math.IsInf(f, -1) {
		return "-Infinity"
	}
	if math.IsNaN(f) {
		return "NaN"
	}
	af := math.Abs(f)
	// Prefer fixed-point for reasonable magnitudes
	if af == 0 || af < 1e15 {
		s := strconv.FormatFloat(f, 'f', -1, 64)
		return trimTrailingZerosDot(s)
	}
	return strconv.FormatFloat(f, 'g', -1, 64)
}

// formatFloat32Diag returns a diagnostic string for float32 matching RFC examples
func formatFloat32Diag(f float32) string {
	if math.IsInf(float64(f), +1) {
		return "Infinity"
	}
	if math.IsInf(float64(f), -1) {
		return "-Infinity"
	}
	if math.IsNaN(float64(f)) {
		return "NaN"
	}
	af := math.Abs(float64(f))
	if af == 0 || af < 1e15 {
		s := strconv.FormatFloat(float64(f), 'f', -1, 32)
		return trimTrailingZerosDot(s)
	}
	return strconv.FormatFloat(float64(f), 'g', -1, 32)
}

func trimTrailingZerosDot(s string) string {
	// Trim trailing zeros and optional dot

	// ErrShortBytes is returned when the
	// slice being decoded is too short to
	// contain the contents of the message

	// ErrRecursion is returned when the maximum recursion limit is reached for an operation.
	// This should only realistically be seen on adversarial data trying to exhaust the stack.

	// ErrLimitExceeded is returned when a set limit is exceeded.
	// Limits can be set on the Reader to prevent excessive memory usage by adversarial data.

	// ErrMaxDepthExceeded is returned when skip recursion depth exceeds limit

	// ErrNotNil is returned when expecting nil

	// ErrInvalidUTF8 is returned when a text string contains invalid UTF-8

	// ErrDuplicateMapKey is returned when a map contains duplicate keys where
	// duplicates are not allowed (e.g., deterministic/strict decoding).

	// ErrIndefiniteForbidden is returned when an indefinite-length item is present
	// but strict/deterministic decoding forbids it.

	// ErrNonCanonicalInteger is returned when an integer is not encoded in the shortest form.

	// ErrNonCanonicalLength is returned when a length (array/map/str/bytes) is not encoded in the shortest form.

	// Error is the interface satisfied
	// by all of the errors that originate
	// from this package.

	// Resumable returns whether
	// or not the error means that
	// the stream of data is malformed
	// and the information is unrecoverable.

	// contextError allows msgp Error instances to be enhanced with additional
	// context about their origin.

	// withContext must not modify the error instance - it must clone and
	// return a new error with the context added.

	// Cause returns the underlying cause of an error that has been wrapped
	// with additional context.

	// Resumable returns whether or not the error means that the stream of data is
	// malformed and the information is unrecoverable.

	// WrapError wraps an error with additional context that allows the part of the
	// serialized type that caused the problem to be identified. Underlying errors
	// can be retrieved using Cause()
	//
	// The input error is not modified - a new error should be returned.
	//
	// ErrShortBytes is not wrapped with any context due to backward compatibility
	// issues with the public API.

	// errWrapped allows arbitrary errors passed to WrapError to be enhanced with
	// context and unwrapped with Cause()

	// Unwrap returns the cause.

	// ArrayError is an error returned
	// when decoding a fix-sized array
	// of the wrong size

	// Error implements the error interface

	// Resumable is always 'true' for ArrayErrors

	// IntOverflow is returned when a call
	// would downcast an integer to a type
	// with too few bits to hold its value.

	// the value of the integer
	// the bit size that the int64 could not fit into

	// Error implements the error interface

	// Resumable is always 'true' for overflows

	// UintOverflow is returned when a call
	// would downcast an unsigned integer to a type
	// with too few bits to hold its value

	// value of the uint
	// the bit size that couldn't fit the value

	// Error implements the error interface

	// Resumable is always 'true' for overflows

	// InvalidTimestamp is returned when an invalid timestamp is encountered

	// value of the nano, if invalid
	// Unexpected field length.

	// Error implements the error interface

	// Resumable is always 'true' for overflows

	// UintBelowZero is returned when a call
	// would cast a signed integer below zero
	// to an unsigned integer.

	// value of the incoming int

	// Error implements the error interface

	// Resumable is always 'true' for overflows

	// A TypeError is returned when a particular
	// decoding method is unsuitable for decoding
	// a particular MessagePack value.

	// Type expected by method
	// Type actually encoded
	i := len(s)
	for i > 0 && s[i-1] ==

		// Error implements the error interface
		'0' {
		i--
	}
	if i > 0 && s[i-1] == '.' {
		i--
	}
	return s[:i]
}

const resumableDefault = false

var (
	ErrShortBytes error = errShort{}

	ErrRecursion error = errRecursion{}

	ErrLimitExceeded error = errLimitExceeded{}

	ErrMaxDepthExceeded error = errors.New("cbor: max depth exceeded")

	ErrNotNil error = errors.New("cbor: not nil")

	ErrInvalidUTF8 error = errors.New("cbor: invalid UTF-8 in text string")

	ErrDuplicateMapKey error = errors.New("cbor: duplicate map key")

	ErrIndefiniteForbidden error = errors.New("cbor: indefinite-length item not allowed in strict/deterministic mode")

	ErrNonCanonicalInteger error = errors.New("cbor: non-canonical integer encoding")

	ErrNonCanonicalLength error = errors.New("cbor: non-canonical length encoding")
)

type Error interface {
	error

	Resumable() bool
}

type contextError interface {
	Error

	withContext(ctx string) error
}

func Cause(e error) error {
	out := e
	if e, ok := e.(errWrapped); ok && e.cause != nil {
		out = e.cause
	}
	return out
}

func Resumable(e error) bool {
	if e, ok := e.(Error); ok {
		return e.Resumable()
	}
	return resumableDefault
}

func WrapError(err error, ctx ...any) error {
	switch e := err.(type) {
	case errShort:
		return e
	case contextError:
		return e.withContext(ctxString(ctx))
	default:
		return errWrapped{cause: err, ctx: ctxString(ctx)}
	}
}

func addCtx(ctx, add string) string {
	if ctx != "" {
		return add + "/" + ctx
	} else {
		return add
	}
}

type errWrapped struct {
	cause error
	ctx   string
}

func (e errWrapped) Error() string {
	if e.ctx != "" {
		return e.cause.Error() + " at " + e.ctx
	} else {
		return e.cause.Error()
	}
}

func (e errWrapped) Resumable() bool {
	if e, ok := e.cause.(Error); ok {
		return e.Resumable()
	}
	return resumableDefault
}

func (e errWrapped) Unwrap() error { return e.cause }

type errShort struct{}

func (e errShort) Error() string   { return "cbor: too few bytes left to read object" }
func (e errShort) Resumable() bool { return false }

type errRecursion struct{}

func (e errRecursion) Error() string   { return "cbor: recursion limit reached" }
func (e errRecursion) Resumable() bool { return false }

type errLimitExceeded struct{}

func (e errLimitExceeded) Error() string   { return "cbor: configured reader limit exceeded" }
func (e errLimitExceeded) Resumable() bool { return false }

type ArrayError struct {
	Wanted uint32
	Got    uint32
	ctx    string
}

func (a ArrayError) Error() string {
	out := "cbor: wanted array of size " + strconv.Itoa(int(a.Wanted)) + "; got " + strconv.Itoa(int(a.Got))
	if a.ctx != "" {
		out += " at " + a.ctx
	}
	return out
}

func (a ArrayError) Resumable() bool { return true }

func (a ArrayError) withContext(ctx string) error { a.ctx = addCtx(a.ctx, ctx); return a }

type IntOverflow struct {
	Value         int64
	FailedBitsize int
	ctx           string
}

func (i IntOverflow) Error() string {
	str := "cbor: " + strconv.FormatInt(i.Value, 10) + " overflows int" + strconv.Itoa(i.FailedBitsize)
	if i.ctx != "" {
		str += " at " + i.ctx
	}
	return str
}

func (i IntOverflow) Resumable() bool { return true }

func (i IntOverflow) withContext(ctx string) error { i.ctx = addCtx(i.ctx, ctx); return i }

type UintOverflow struct {
	Value         uint64
	FailedBitsize int
	ctx           string
}

func (u UintOverflow) Error() string {
	str := "cbor: " + strconv.FormatUint(u.Value, 10) + " overflows uint" + strconv.Itoa(u.FailedBitsize)
	if u.ctx != "" {
		str += " at " + u.ctx
	}
	return str
}

func (u UintOverflow) Resumable() bool { return true }

func (u UintOverflow) withContext(ctx string) error { u.ctx = addCtx(u.ctx, ctx); return u }

type InvalidTimestamp struct {
	Nanos       int64
	FieldLength int
	ctx         string
}

func (u InvalidTimestamp) Error() (str string) {
	if u.Nanos > 0 {
		str = "msgp: timestamp nanosecond field value " + strconv.FormatInt(u.Nanos, 10) + " exceeds maximum allows of 999999999"
	} else if u.FieldLength >= 0 {
		str = "msgp: invalid timestamp field length " + strconv.FormatInt(int64(u.FieldLength), 10) + " - must be 4, 8 or 12"
	}
	if u.ctx != "" {
		str += " at " + u.ctx
	}
	return str
}

func (u InvalidTimestamp) Resumable() bool { return true }

func (u InvalidTimestamp) withContext(ctx string) error { u.ctx = addCtx(u.ctx, ctx); return u }

type UintBelowZero struct {
	Value int64
	ctx   string
}

func (u UintBelowZero) Error() string {
	str := "cbor: attempted to cast int " + strconv.FormatInt(u.Value, 10) + " to unsigned"
	if u.ctx != "" {
		str += " at " + u.ctx
	}
	return str
}

func (u UintBelowZero) Resumable() bool { return true }

func (u UintBelowZero) withContext(ctx string) error {
	u.ctx = ctx
	return u
}

type TypeError struct {
	Method  Type
	Encoded Type

	ctx string
}

func (t TypeError) Error() string {
	out := "cbor: attempted to decode type " + quoteStr(t.Encoded.String()) + " with method for " + quoteStr(t.Method.String())
	if t.ctx != "" {
		out += " at " + t.ctx
	}
	return out
}

// Resumable returns 'true' for TypeErrors
func (t TypeError) Resumable() bool { return true }

func (t TypeError) withContext(ctx string) error { t.ctx = addCtx(t.ctx, ctx); return t }

// returns either InvalidPrefixError or
// TypeError depending on whether or not
// the prefix is recognized
func badPrefix(wantMajor uint8, gotMajor uint8) error {
	return InvalidPrefixError{Want: wantMajor, Got: gotMajor}
}

// InvalidPrefixError is returned when a bad encoding
// uses a major type that is not expected.
// This kind of error is unrecoverable.
type InvalidPrefixError struct {
	Want uint8
	Got  uint8
}

// Error implements the error interface
func (i InvalidPrefixError) Error() string {
	return "cbor: expected major type " + strconv.Itoa(int(i.Want)) + " but got " + strconv.Itoa(int(i.Got))
}

// Resumable returns 'false' for InvalidPrefixErrors
func (i InvalidPrefixError) Resumable() bool { return false }

// ErrUnsupportedType is returned when a bad argument is supplied to
// a function that accepts arbitrary values.
type ErrUnsupportedType struct {
	T reflect.Type

	ctx string
}

// Error implements error
func (e *ErrUnsupportedType) Error() string {
	out := "cbor: type " + quoteStr(e.T.String()) + " not supported"
	if e.ctx != "" {
		out += " at " + e.ctx
	}
	return out
}

// Resumable returns 'true' for ErrUnsupportedType

// ctxString converts the incoming context slice into a single string.

// getType returns the CBOR type from a byte

// NextType returns the type of the next object in the slice

// Require ensures that b has capacity for at least n additional bytes
// without reallocation. It returns a slice that shares the original
// contents and has sufficient capacity for appending n bytes.

// IsLikelyJSON reports whether the given byte slice looks like JSON text
// rather than CBOR. It is a heuristic and not a formal discriminator:
//
//   - It requires the data to be valid UTF-8.
//   - It then checks the first non-whitespace byte against the JSON
//     value grammar (object/array/string/number/true/false/null).
//
// Most CBOR payloads will fail one of these checks (non-UTF-8 or
// invalid JSON starter) and thus be classified as non-JSON.

// Require valid UTF-8 for JSON.

// Skip leading ASCII whitespace.

// Valid JSON value starters:
//  - object/array: '{', '['
//  - string: '"'
//  - number: '-', '0'..'9'
//  - true/false/null: 't', 'f', 'n'

// FromJSONBytes converts a JSON document into CBOR bytes using a
// wrapper convention similar to RFC examples and the prototype:
//
//  - null/bool/number/string/array/object map naturally to CBOR
//    nil/bool/float-or-int/text/array/map.
//  - Wrapper objects are recognized and mapped to semantic tags:
//      {"$rfc3339": string}         -> tag(0) RFC3339 time string
//      {"$epoch": number}           -> tag(1) epoch seconds (int or float)
//      {"$decimal":[exp, mant]}     -> tag(4)
//      {"$bigfloat":[exp, mant]}    -> tag(5)
//      {"$base64url": string}       -> tag(21) bytes (base64url)
//      {"$base64": string}          -> tag(22) bytes (base64 std)
//      {"$base16": string}          -> tag(23) bytes (hex)
//      {"$cbor": string}            -> tag(24) embedded CBOR (base64)
//      {"$uri": string}             -> tag(32) URI (text)
//      {"$base64urlstr": string}    -> tag(33) text
//      {"$base64str": string}       -> tag(34) text
//      {"$regex": string}           -> tag(35) regex (text)
//      {"$mime": string}            -> tag(36) MIME (text)
//      {"$uuid": string}            -> tag(37) UUID (canonical hyphenated)
//      {"$selfdescribe": true}      -> tag(55799)
//      {"$tag":N, "$":value}       -> generic tag N

// Prefer integers when possible, otherwise float64.

// Wrapper detection

// Plain object

// Generic {"$tag":N, "$":value}

// $rfc3339

// $epoch

// Accept json.Number, float64, or integer-like

// $decimal

// $bigfloat

// $base64url -> tagBase64URL

// $base64 -> tagBase64

// $base16 -> tagBase16

// $cbor -> embedded CBOR (tag24)

// $uri

// $base64urlstr

// $base64str

// $regex

// $mime

// $uuid

// 8-4-4-4-12

// $selfdescribe

// ToJSONBytes converts the next CBOR item into a JSON encoding and
// returns the JSON bytes and remainder. It follows a similar mapping
// as FromJSONBytes, including unwrapping common semantic tags into
// wrapper objects where appropriate.

// base64-encode byte strings

// key must be JSON string; try fast path

// fallback: use diagnostic notation as key

// 0

// 1

// 2/3

// 4 -> {"$decimal":[exp, mant]}

// 5 -> {"$bigfloat":[exp, mant]}

// 21 -> {"$base64url":"..."}

// 22 -> {"$base64":"..."}

// 23 -> {"$base16":"..."}

// 24 embedded CBOR -> {"$cbor":"..."}

// 32 -> plain JSON string

// 33 -> {"$base64urlstr":string}

// 34 -> {"$base64str":string}

// 35 -> {"$regex":string}

// 36 -> {"$mime":string}

// UUID -> {"$uuid":"..."}

// 55799 -> {"$selfdescribe":true}

// Generic: {"$tag":N, "$": value}

// application-defined simple value; map to null in JSON by default

// unassigned simple values -> null
func (e *ErrUnsupportedType) Resumable() bool { return true }

func (e *ErrUnsupportedType) withContext(ctx string) error {
	o :=

		// encodeBase64Std writes standard base64 of src into buf.
		*e
	o.ctx = addCtx(o.ctx, ctx)
	return &o
}

func ctxString(ctx []any) string {
	out := ""
	for idx, cv := range ctx {
		if idx > 0 {
			out += "/"
		}
		out += fmt.Sprintf("%v", cv)
	}
	return out
}

func quoteStr(s string) string {
	return strconv.Quote(s)
}

func getType(b byte) Type {
	major := getMajorType(b)
	switch major {
	case majorTypeUint:
		return UintType
	case majorTypeNegInt:
		return IntType
	case majorTypeBytes:
		return BinType
	case majorTypeText:
		return StrType
	case majorTypeArray:
		return ArrayType
	case majorTypeMap:
		return MapType
	case majorTypeTag:
		return ExtensionType
	case majorTypeSimple:
		addInfo := getAddInfo(b)
		switch addInfo {
		case simpleTrue, simpleFalse:
			return BoolType
		case simpleNull:
			return NilType
		case simpleFloat32, simpleFloat64:
			return Float64Type
		}
	}
	return InvalidType
}

func NextType(b []byte) Type {
	if len(b) == 0 {
		return InvalidType
	}
	return getType(b[0])
}

func Require(b []byte, n int) []byte {
	if cap(b)-len(b) >= n {
		return b
	}
	nb := make([]byte, len(b), len(b)+n)
	copy(nb, b)
	return nb
}

func IsLikelyJSON(b []byte) bool {

	if !utf8.Valid(b) {
		return false
	}

	i := 0
	for i < len(b) {
		c := b[i]
		if c == ' ' || c == '\n' || c == '\r' || c == '\t' {
			i++
			continue
		}
		break
	}
	if i >= len(b) {
		return false
	}
	ch := b[i]

	if ch == '{' || ch == '[' || ch == '"' || ch == '-' {
		return true
	}
	if ch >= '0' && ch <= '9' {
		return true
	}
	if ch == 't' || ch == 'f' || ch == 'n' {
		return true
	}
	return false
}

func FromJSONBytes(js []byte) ([]byte, error) {
	dec := json.NewDecoder(strings.NewReader(string(js)))
	dec.UseNumber()
	var v any
	if err := dec.Decode(&v); err != nil {
		return nil, err
	}
	return jsonToCBOR(nil, v)
}

func jsonToCBOR(b []byte, v any) ([]byte, error) {
	switch x := v.(type) {
	case nil:
		return AppendNil(b), nil
	case bool:
		return AppendBool(b, x), nil
	case json.Number:

		if strings.ContainsAny(string(x), ".eE") {
			f, err := x.Float64()
			if err != nil {
				return b, err
			}
			return AppendFloat64(b, f), nil
		}
		if i, err := x.Int64(); err == nil {
			return AppendInt64(b, i), nil
		}
		f, err := x.Float64()
		if err != nil {
			return b, err
		}
		return AppendFloat64(b, f), nil
	case float64:
		return AppendFloat64(b, x), nil
	case string:
		return AppendString(b, x), nil
	case []any:
		b = AppendArrayHeader(b, uint32(len(x)))
		var err error
		for _, e := range x {
			b, err = jsonToCBOR(b, e)
			if err != nil {
				return b, err
			}
		}
		return b, nil
	case map[string]any:

		if out, ok, err := tryWrapper(b, x); ok || err != nil {
			return out, err
		}

		b = AppendMapHeader(b, uint32(len(x)))
		var err error
		for k, vv := range x {
			b = AppendString(b, k)
			b, err = jsonToCBOR(b, vv)
			if err != nil {
				return b, err
			}
		}
		return b, nil
	default:
		return b, &ErrUnsupportedType{}
	}
}

func tryWrapper(b []byte, m map[string]any) ([]byte, bool, error) {

	if tagv, ok := m["$tag"]; ok {
		iv, ok2 := m["$"]
		if !ok2 {
			return b, true, errors.New("cbor: $tag wrapper missing $ field")
		}
		tag, err := numToUint64(tagv)
		if err != nil {
			return b, true, err
		}
		inner, err := jsonToCBOR(nil, iv)
		if err != nil {
			return b, true, err
		}
		return AppendTagged(b, tag, inner), true, nil
	}

	if v, ok := m["$rfc3339"]; ok {
		s, _ := v.(string)
		if s == "" {
			return b, true, errors.New("cbor: $rfc3339 expects string")
		}
		t, err := time.Parse(time.RFC3339Nano, s)
		if err != nil {
			return b, true, err
		}
		return AppendRFC3339Time(b, t), true, nil
	}

	if v, ok := m["$epoch"]; ok {

		var f float64
		switch vv := v.(type) {
		case json.Number:
			ff, err := vv.Float64()
			if err != nil {
				return b, true, err
			}
			f = ff
		case float64:
			f = vv
		case int64:
			f = float64(vv)
		default:
			return b, true, errors.New("cbor: $epoch expects number")
		}
		sec := mathFloor(f)
		ns := int64(mathRound((f - float64(sec)) * 1e9))
		secs := int64(sec)
		if ns >= 1e9 {
			secs++
			ns -= 1e9
		}
		t := time.Unix(secs, ns).UTC()
		return AppendTime(b, t), true, nil
	}

	if v, ok := m["$decimal"]; ok {
		arr, ok := v.([]any)
		if !ok || len(arr) != 2 {
			return b, true, errors.New("cbor: $decimal expects [exp, mant]")
		}
		exp, err := anyToInt64(arr[0])
		if err != nil {
			return b, true, err
		}
		mantStr, ok := arr[1].(string)
		if !ok {
			return b, true, errors.New("cbor: $decimal mantissa must be string")
		}
		z, ok := new(big.Int).SetString(mantStr, 10)
		if !ok {
			return b, true, errors.New("cbor: invalid $decimal mantissa")
		}
		return AppendDecimalFraction(b, exp, z), true, nil
	}

	if v, ok := m["$bigfloat"]; ok {
		arr, ok := v.([]any)
		if !ok || len(arr) != 2 {
			return b, true, errors.New("cbor: $bigfloat expects [exp, mant]")
		}
		exp, err := anyToInt64(arr[0])
		if err != nil {
			return b, true, err
		}
		mantStr, ok := arr[1].(string)
		if !ok {
			return b, true, errors.New("cbor: $bigfloat mantissa must be string")
		}
		z, ok := new(big.Int).SetString(mantStr, 10)
		if !ok {
			return b, true, errors.New("cbor: invalid $bigfloat mantissa")
		}
		return AppendBigfloat(b, exp, z), true, nil
	}

	if v, ok := m["$base64url"]; ok {
		s, _ := v.(string)
		bs, err := base64.RawURLEncoding.DecodeString(s)
		if err != nil {
			return b, true, err
		}
		return AppendBase64URL(b, bs), true, nil
	}

	if v, ok := m["$base64"]; ok {
		s, _ := v.(string)
		bs, err := base64.StdEncoding.DecodeString(s)
		if err != nil {
			return b, true, err
		}
		return AppendBase64(b, bs), true, nil
	}

	if v, ok := m["$base16"]; ok {
		s, _ := v.(string)
		bs, err := hex.DecodeString(s)
		if err != nil {
			return b, true, err
		}
		return AppendBase16(b, bs), true, nil
	}

	if v, ok := m["$cbor"]; ok {
		s, _ := v.(string)
		bs, err := base64.StdEncoding.DecodeString(s)
		if err != nil {
			return b, true, err
		}
		return AppendEmbeddedCBOR(b, bs), true, nil
	}

	if v, ok := m["$uri"]; ok {
		s, _ := v.(string)
		if s == "" {
			return b, true, errors.New("cbor: $uri expects string")
		}
		return AppendURI(b, s), true, nil
	}

	if v, ok := m["$base64urlstr"]; ok {
		s, _ := v.(string)
		return AppendBase64URLString(b, s), true, nil
	}

	if v, ok := m["$base64str"]; ok {
		s, _ := v.(string)
		return AppendBase64String(b, s), true, nil
	}

	if v, ok := m["$regex"]; ok {
		s, _ := v.(string)
		if s == "" {
			return b, true, errors.New("cbor: $regex expects string")
		}
		if _, err := regexp.Compile(s); err != nil {
			return b, true, err
		}
		return AppendRegexpString(b, s), true, nil
	}

	if v, ok := m["$mime"]; ok {
		s, _ := v.(string)
		if s == "" {
			return b, true, errors.New("cbor: $mime expects string")
		}
		return AppendMIMEString(b, s), true, nil
	}

	if v, ok := m["$uuid"]; ok {
		s, _ := v.(string)
		if len(s) != 36 {
			return b, true, errors.New("cbor: $uuid expects canonical string")
		}
		hexStr := strings.ReplaceAll(s, "-", "")
		bs, err := hex.DecodeString(hexStr)
		if err != nil || len(bs) != 16 {
			return b, true, errors.New("cbor: invalid $uuid")
		}
		var u [16]byte
		copy(u[:], bs)
		return AppendUUID(b, u), true, nil
	}

	if v, ok := m["$selfdescribe"]; ok {
		bval, _ := v.(bool)
		if !bval {
			return b, true, errors.New("cbor: $selfdescribe expects true")
		}
		return AppendSelfDescribeCBOR(b), true, nil
	}
	return b, false, nil
}

func numToUint64(v any) (uint64, error) {
	switch t := v.(type) {
	case json.Number:
		if strings.ContainsAny(string(t), ".eE") {
			f, err := t.Float64()
			if err != nil {
				return 0, err
			}
			if f < 0 {
				return 0, errors.New("cbor: negative tag")
			}
			return uint64(f), nil
		}
		i, err := t.Int64()
		if err != nil {
			return 0, err
		}
		if i < 0 {
			return 0, errors.New("cbor: negative tag")
		}
		return uint64(i), nil
	case float64:
		if t < 0 {
			return 0, errors.New("cbor: negative tag")
		}
		return uint64(t), nil
	case int64:
		if t < 0 {
			return 0, errors.New("cbor: negative tag")
		}
		return uint64(t), nil
	case int:
		if t < 0 {
			return 0, errors.New("cbor: negative tag")
		}
		return uint64(t), nil
	default:
		return 0, errors.New("cbor: expected numeric tag")
	}
}

func anyToInt64(v any) (int64, error) {
	switch t := v.(type) {
	case json.Number:
		i, err := t.Int64()
		if err != nil {
			return 0, err
		}
		return i, nil
	case float64:
		return int64(t), nil
	case int64:
		return t, nil
	case int:
		return int64(t), nil
	default:
		return 0, errors.New("cbor: expected integer")
	}
}

func mathFloor(f float64) float64 {
	if f >= 0 {
		return float64(int64(f))
	}
	if float64(int64(f)) == f {
		return f
	}
	return float64(int64(f) - 1)
}

func mathRound(f float64) float64 {
	if f >= 0 {
		return float64(int64(f + 0.5))
	}
	return float64(int64(f - 0.5))
}

func ToJSONBytes(b []byte) ([]byte, []byte, error) {
	bb := GetByteBuffer()
	defer PutByteBuffer(bb)
	rest, err := toJSON(bb, b, 0)
	if err != nil {
		return nil, b, err
	}
	out := make([]byte, bb.Len())
	copy(out, bb.Bytes())
	return out, rest, nil
}

func toJSON(buf *ByteBuffer, b []byte, depth int) ([]byte, error) {
	if depth > recursionLimit {
		return b, ErrMaxDepthExceeded
	}
	if len(b) < 1 {
		return b, ErrShortBytes
	}
	maj := getMajorType(b[0])
	add := getAddInfo(b[0])

	switch maj {
	case majorTypeUint:
		u, o, err := readUintCore(b, majorTypeUint)
		if err != nil {
			return b, err
		}
		buf.WriteString(strconv.FormatUint(u, 10))
		return o, nil
	case majorTypeNegInt:
		u, o, err := readUintCore(b, majorTypeNegInt)
		if err != nil {
			return b, err
		}
		n := int64(-1) - int64(u)
		buf.WriteString(strconv.FormatInt(n, 10))
		return o, nil
	case majorTypeBytes:
		bs, o, err := ReadBytesBytes(b, nil)
		if err != nil {
			return b, err
		}

		buf.WriteString("\"")
		encodeBase64Std(buf, bs)
		buf.WriteString("\"")
		return o, nil
	case majorTypeText:
		s, o, err := ReadStringBytes(b)
		if err != nil {
			return b, err
		}
		js, _ := json.Marshal(s)
		buf.Write(js)
		return o, nil
	case majorTypeArray:
		if add == addInfoIndefinite {
			buf.WriteString("[")
			p := b[1:]
			first := true
			for {
				if len(p) < 1 {
					return b, ErrShortBytes
				}
				if p[0] == makeByte(majorTypeSimple, simpleBreak) {
					buf.WriteString("]")
					return p[1:], nil
				}
				if !first {
					buf.WriteString(",")
				} else {
					first = false
				}
				var err error
				p, err = toJSON(buf, p, depth+1)
				if err != nil {
					return b, err
				}
			}
		}
		sz, p, err := readUintCore(b, majorTypeArray)
		if err != nil {
			return b, err
		}
		buf.WriteString("[")
		for i := uint64(0); i < sz; i++ {
			if i > 0 {
				buf.WriteString(",")
			}
			var err error
			p, err = toJSON(buf, p, depth+1)
			if err != nil {
				return b, err
			}
		}
		buf.WriteString("]")
		return p, nil
	case majorTypeMap:
		if add == addInfoIndefinite {
			buf.WriteString("{")
			p := b[1:]
			first := true
			for {
				if len(p) < 1 {
					return b, ErrShortBytes
				}
				if p[0] == makeByte(majorTypeSimple, simpleBreak) {
					buf.WriteString("}")
					return p[1:], nil
				}

				if getMajorType(p[0]) == majorTypeText {
					k, o, err := ReadStringBytes(p)
					if err != nil {
						return b, err
					}
					if !first {
						buf.WriteString(",")
					} else {
						first = false
					}
					kj, _ := json.Marshal(k)
					buf.Write(kj)
					buf.WriteString(":")
					var err2 error
					p, err2 = toJSON(buf, o, depth+1)
					if err2 != nil {
						return b, err2
					}
				} else {

					ks, o, err := DiagBytes(p)
					if err != nil {
						return b, err
					}
					if !first {
						buf.WriteString(",")
					} else {
						first = false
					}
					kj, _ := json.Marshal(ks)
					buf.Write(kj)
					buf.WriteString(":")
					var err2 error
					p, err2 = toJSON(buf, o, depth+1)
					if err2 != nil {
						return b, err2
					}
				}
			}
		}
		sz, p, err := readUintCore(b, majorTypeMap)
		if err != nil {
			return b, err
		}
		buf.WriteString("{")
		for i := uint64(0); i < sz; i++ {
			if i > 0 {
				buf.WriteString(",")
			}
			if getMajorType(p[0]) == majorTypeText {
				k, o, err := ReadStringBytes(p)
				if err != nil {
					return b, err
				}
				kj, _ := json.Marshal(k)
				buf.Write(kj)
				buf.WriteString(":")
				var err2 error
				p, err2 = toJSON(buf, o, depth+1)
				if err2 != nil {
					return b, err2
				}
			} else {
				ks, o, err := DiagBytes(p)
				if err != nil {
					return b, err
				}
				kj, _ := json.Marshal(ks)
				buf.Write(kj)
				buf.WriteString(":")
				var err2 error
				p, err2 = toJSON(buf, o, depth+1)
				if err2 != nil {
					return b, err2
				}
			}
		}
		buf.WriteString("}")
		return p, nil
	case majorTypeTag:
		tag, o, err := ReadTagBytes(b)
		if err != nil {
			return b, err
		}
		switch tag {
		case tagDateTimeString:
			tm, rest, err := ReadRFC3339TimeBytes(b)
			if err != nil {
				return b, err
			}
			js, _ := json.Marshal(tm.Format(time.RFC3339Nano))
			buf.Write(js)
			return rest, nil
		case tagEpochDateTime:
			tm, rest, err := ReadTimeBytes(b)
			if err != nil {
				return b, err
			}
			js, _ := json.Marshal(tm.Format(time.RFC3339Nano))
			buf.Write(js)
			return rest, nil
		case tagPosBignum, tagNegBignum:
			z, rest, err := ReadBigIntBytes(b)
			if err != nil {
				return b, err
			}
			js, _ := json.Marshal(z.String())
			buf.Write(js)
			return rest, nil
		case tagDecimalFrac:
			exp, mant, rest, err := ReadDecimalFractionBytes(b)
			if err != nil {
				return b, err
			}
			buf.WriteString(`{"$decimal":[`)
			buf.WriteString(strconv.FormatInt(exp, 10))
			buf.WriteString(",")
			ms, _ := json.Marshal(mant.String())
			buf.Write(ms)
			buf.WriteString("]}")
			return rest, nil
		case tagBigfloat:
			exp, mant, rest, err := ReadBigfloatBytes(b)
			if err != nil {
				return b, err
			}
			buf.WriteString(`{"$bigfloat":[`)
			buf.WriteString(strconv.FormatInt(exp, 10))
			buf.WriteString(",")
			ms, _ := json.Marshal(mant.String())
			buf.Write(ms)
			buf.WriteString("]}")
			return rest, nil
		case tagBase64URL:
			bs, rest, err := ReadBase64URLBytes(b)
			if err != nil {
				return b, err
			}
			buf.WriteString(`{"$base64url":"`)
			encodeBase64RawURL(buf, bs)
			buf.WriteString(`"}`)
			return rest, nil
		case tagBase64:
			bs, rest, err := ReadBase64Bytes(b)
			if err != nil {
				return b, err
			}
			buf.WriteString(`{"$base64":"`)
			encodeBase64Std(buf, bs)
			buf.WriteString(`"}`)
			return rest, nil
		case tagBase16:
			bs, rest, err := ReadBase16Bytes(b)
			if err != nil {
				return b, err
			}
			buf.WriteString(`{"$base16":"`)
			d := buf.Extend(hex.EncodedLen(len(bs)))
			hex.Encode(d, bs)
			buf.WriteString(`"}`)
			return rest, nil
		case tagCBOR:
			payload, rest, err := ReadEmbeddedCBORBytes(b)
			if err != nil {
				return b, err
			}
			buf.WriteString(`{"$cbor":"`)
			encodeBase64Std(buf, payload)
			buf.WriteString(`"}`)
			return rest, nil
		case tagURI:
			s, rest, err := ReadURIStringBytes(b)
			if err != nil {
				return b, err
			}
			js, _ := json.Marshal(s)
			buf.Write(js)
			return rest, nil
		case tagBase64URLString:
			s, rest, err := ReadBase64URLStringBytes(b)
			if err != nil {
				return b, err
			}
			buf.WriteString(`{"$base64urlstr":`)
			js, _ := json.Marshal(s)
			buf.Write(js)
			buf.WriteString("}")
			return rest, nil
		case tagBase64String:
			s, rest, err := ReadBase64StringBytes(b)
			if err != nil {
				return b, err
			}
			buf.WriteString(`{"$base64str":`)
			js, _ := json.Marshal(s)
			buf.Write(js)
			buf.WriteString("}")
			return rest, nil
		case tagRegexp:
			s, rest, err := ReadRegexpStringBytes(b)
			if err != nil {
				return b, err
			}
			buf.WriteString(`{"$regex":`)
			js, _ := json.Marshal(s)
			buf.Write(js)
			buf.WriteString("}")
			return rest, nil
		case tagMIME:
			s, rest, err := ReadMIMEStringBytes(b)
			if err != nil {
				return b, err
			}
			buf.WriteString(`{"$mime":`)
			js, _ := json.Marshal(s)
			buf.Write(js)
			buf.WriteString("}")
			return rest, nil
		case 37:
			u, rest, err := ReadUUIDBytes(b)
			if err != nil {
				return b, err
			}
			hexs := hex.EncodeToString(u[:])
			uuidStr := hexs[0:8] + "-" + hexs[8:12] + "-" + hexs[12:16] + "-" + hexs[16:20] + "-" + hexs[20:32]
			buf.WriteString(`{"$uuid":"`)
			buf.WriteString(uuidStr)
			buf.WriteString(`"}`)
			return rest, nil
		case tagSelfDescribeCBOR:
			_, found, _ := StripSelfDescribeCBOR(b)
			if found {
				buf.WriteString(`{"$selfdescribe":true}`)
				_, o2, _ := ReadTagBytes(b)
				return o2, nil
			}
			return b, &ErrUnsupportedType{}
		default:

			vbuf := GetByteBuffer()
			rest, err := toJSON(vbuf, o, depth+1)
			if err != nil {
				PutByteBuffer(vbuf)
				return b, err
			}
			buf.WriteString(`{"$tag":`)
			buf.WriteString(strconv.FormatUint(tag, 10))
			buf.WriteString(`,"$":`)
			buf.Write(vbuf.Bytes())
			buf.WriteString("}")
			PutByteBuffer(vbuf)
			return rest, nil
		}
	case majorTypeSimple:
		switch add {
		case simpleFalse:
			buf.WriteString("false")
			return b[1:], nil
		case simpleTrue:
			buf.WriteString("true")
			return b[1:], nil
		case simpleNull, simpleUndefined:
			buf.WriteString("null")
			return b[1:], nil
		case simpleFloat16:
			f, o, err := ReadFloat16Bytes(b)
			if err != nil {
				return b, err
			}
			buf.WriteString(strconv.FormatFloat(float64(f), 'g', -1, 32))
			return o, nil
		case simpleFloat32:
			f, o, err := ReadFloat32Bytes(b)
			if err != nil {
				return b, err
			}
			buf.WriteString(strconv.FormatFloat(float64(f), 'g', -1, 32))
			return o, nil
		case simpleFloat64:
			f, o, err := ReadFloat64Bytes(b)
			if err != nil {
				return b, err
			}
			buf.WriteString(strconv.FormatFloat(f, 'g', -1, 64))
			return o, nil
		case addInfoUint8:

			if len(b) < 2 {
				return b, ErrShortBytes
			}
			buf.WriteString("null")
			return b[2:], nil
		default:
			if add < 20 {

				buf.WriteString("null")
				return b[1:], nil
			}
			return b, &ErrUnsupportedType{}
		}
	}
	return b, &ErrUnsupportedType{}
}

func encodeBase64Std(buf *ByteBuffer, src []byte) {
	out := buf.Extend(base64.StdEncoding.EncodedLen(len(src)))
	base64.StdEncoding.Encode(out, src)
}

// encodeBase64RawURL writes raw base64url of src into buf.

// ReadJSONNumberBytes reads a CBOR numeric value and returns it as a
// json.Number, along with the remaining input.

// Number represents a CBOR number that may be an int64, uint64,
// float32, or float64 internally. The zero value is equivalent to
// an int64 value of 0.

// AsInt sets the number to an int64.

// AsUint sets the number to a uint64.

// AsFloat32 sets the value of the number to a float32.

// AsFloat64 sets the value of the number to a float64.

// Int returns the value as an int64 and reports whether that was the
// underlying type (or the zero value).

// Uint returns the value as a uint64 and reports whether that was the
// underlying type.

// Float returns the value as a float64 and reports whether the
// underlying type was float32 or float64.

// Type returns the underlying numeric kind.

// UnmarshalCBOR decodes a single CBOR number from b into n.

// MarshalCBOR encodes the stored numeric value into b.

// CoerceInt attempts to coerce the value into an int64 without loss of
// precision and reports success.

// CoerceUInt attempts to coerce the value into a uint64 without loss of
// precision and reports success.

// isExactInt reports whether the stored float value is an exact integer.

// CoerceFloat returns the value as a float64.

// Msgsize returns the worst-case encoded size.

// String implements fmt.Stringer-style formatting.

// readUintCore reads an unsigned integer with the given expected major type

// ReadMapHeaderBytes reads a map header

// Ultra-fast paths: major type 5 (map): 0xa0-0xbb
// size 0-23

// size in uint8

// size in uint16

// size in uint32

// size in uint64

// ReadArrayHeaderBytes reads an array header

// Ultra-fast paths: major type 4 (array): 0x80-0x9b
// size 0-23

// size in uint8

// size in uint16

// size in uint32

// size in uint64

// ReadMapStartBytes reads a map start and indicates whether it is indefinite-length.
// If indefinite is true, sz is zero and rest points after the header byte (0xbf).

// ReadArrayStartBytes reads an array start and indicates whether it is indefinite-length.
// If indefinite is true, sz is zero and rest points after the header byte (0x9f).

// ReadBreakBytes checks whether the next byte is a break (0xff) and consumes it if so.

// ReadNilBytes reads a nil value

// ReadFloat64Bytes reads a float64

// Ultra-fast path: direct byte comparison (0xfb = float64)

// ReadFloat32Bytes reads a float32

// Ultra-fast path: direct byte comparison (0xfa = float32)

// ReadFloat16Bytes reads a float16 (IEEE 754 binary16) and returns float32

// ReadBoolBytes reads a bool

// Ultra-fast path: direct byte comparison
// true

// false

// ReadInt64Bytes reads an int64

// Ultra-fast paths: direct byte pattern matching, no bit ops
// Major type 0 (positive): 0x00-0x1b
// 0-23 direct encoding

// uint8 follows

// uint16 follows

// uint32 follows

// uint64 follows

// Major type 1 (negative): 0x20-0x3b
// -1 to -24 direct encoding

// negative, uint8 follows

// negative, uint16 follows

// negative, uint32 follows

// negative, uint64 follows

// Invalid major type for integer

// ReadInt32Bytes reads an int32

// ReadInt16Bytes reads an int16

// ReadInt8Bytes reads an int8

// ReadIntBytes reads an int

// ReadUint64Bytes reads a uint64

// ReadUint32Bytes reads a uint32

// ReadUint16Bytes reads a uint16

// ReadUint8Bytes reads a uint8

// ReadUintBytes reads a uint

// ReadBytesBytes reads a byte string

func encodeBase64RawURL(buf *ByteBuffer, src []byte) {
	out := buf.Extend(base64.RawURLEncoding.EncodedLen(len(src)))
	base64.

		// Indefinite form: 0x5f

		RawURLEncoding.Encode(out, src)
}

func ReadJSONNumberBytes(b []byte) (json.Number, []byte, error) {
	typ := NextType(b)
	switch typ {
	case IntType:
		v, o, err := ReadInt64Bytes(b)
		if err != nil {
			return "", b, err
		}
		return json.Number(strconv.FormatInt(v, 10)), o, nil
	case UintType:
		v, o, err := ReadUint64Bytes(b)
		if err != nil {
			return "", b, err
		}
		return json.Number(strconv.FormatUint(v, 10)), o, nil
	case Float32Type:
		v, o, err := ReadFloat32Bytes(b)
		if err != nil {
			return "", b, err
		}
		return json.Number(strconv.FormatFloat(float64(v), 'f', -1, 64)), o, nil
	case Float64Type:
		v, o, err := ReadFloat64Bytes(b)
		if err != nil {
			return "", b, err
		}
		return json.Number(strconv.FormatFloat(v, 'f', -1, 64)), o, nil
	default:
		return "", b, &ErrUnsupportedType{}
	}
}

type Number struct {
	bits uint64
	typ  Type
}

func (n *Number) AsInt(i int64) {
	if i == 0 {
		n.typ = InvalidType
		n.bits = 0
		return
	}

	n.typ = IntType
	n.bits = uint64(i)
}

func (n *Number) AsUint(u uint64) {
	n.typ = UintType
	n.bits = u
}

func (n *Number) AsFloat32(f float32) {
	n.typ = Float32Type
	n.bits = uint64(math.Float32bits(f))
}

func (n *Number) AsFloat64(f float64) {
	n.typ = Float64Type
	n.bits = math.Float64bits(f)
}

func (n *Number) Int() (int64, bool) {
	return int64(n.bits), n.typ == IntType || n.typ == InvalidType
}

func (n *Number) Uint() (uint64, bool) {
	return n.bits, n.typ == UintType
}

func (n *Number) Float() (float64, bool) {
	switch n.typ {
	case Float32Type:
		return float64(math.Float32frombits(uint32(n.bits))), true
	case Float64Type:
		return math.Float64frombits(n.bits), true
	default:
		return 0, false
	}
}

func (n *Number) Type() Type {
	if n.typ == InvalidType {
		return IntType
	}
	return n.typ
}

func (n *Number) UnmarshalCBOR(b []byte) ([]byte, error) {
	typ := NextType(b)
	switch typ {
	case IntType:
		i, o, err := ReadInt64Bytes(b)
		if err != nil {
			return b, err
		}
		n.AsInt(i)
		return o, nil
	case UintType:
		u, o, err := ReadUint64Bytes(b)
		if err != nil {
			return b, err
		}
		n.AsUint(u)
		return o, nil
	case Float64Type:
		f, o, err := ReadFloat64Bytes(b)
		if err != nil {
			return b, err
		}
		n.AsFloat64(f)
		return o, nil
	case Float32Type:
		f, o, err := ReadFloat32Bytes(b)
		if err != nil {
			return b, err
		}
		n.AsFloat32(f)
		return o, nil
	default:
		return b, &ErrUnsupportedType{}
	}
}

func (n *Number) MarshalCBOR(b []byte) ([]byte, error) {
	switch n.typ {
	case IntType:
		return AppendInt64(b, int64(n.bits)), nil
	case UintType:
		return AppendUint64(b, n.bits), nil
	case Float64Type:
		return AppendFloat64(b, math.Float64frombits(n.bits)), nil
	case Float32Type:
		return AppendFloat32(b, math.Float32frombits(uint32(n.bits))), nil
	default:
		return AppendInt64(b, 0), nil
	}
}

func (n *Number) CoerceInt() (int64, bool) {
	switch n.typ {
	case InvalidType, IntType:
		return int64(n.bits), true
	case UintType:
		return int64(n.bits), n.bits <= math.MaxInt64
	case Float32Type:
		f := math.Float32frombits(uint32(n.bits))
		if n.isExactInt() && f <= math.MaxInt64 && f >= math.MinInt64 {
			return int64(f), true
		}
		if n.bits == 0 || n.bits == 1<<31 {
			return 0, true
		}
	case Float64Type:
		f := math.Float64frombits(n.bits)
		if n.isExactInt() && f <= math.MaxInt64 && f >= math.MinInt64 {
			return int64(f), true
		}
		return 0, n.bits == 0 || n.bits == 1<<63
	}
	return 0, false
}

func (n *Number) CoerceUInt() (uint64, bool) {
	switch n.typ {
	case InvalidType, IntType:
		if int64(n.bits) >= 0 {
			return n.bits, true
		}
	case UintType:
		return n.bits, true
	case Float32Type:
		f := math.Float32frombits(uint32(n.bits))
		if f >= 0 && f <= math.MaxUint64 && n.isExactInt() {
			return uint64(f), true
		}
		if n.bits == 0 || n.bits == 1<<31 {
			return 0, true
		}
	case Float64Type:
		f := math.Float64frombits(n.bits)
		if f >= 0 && f <= math.MaxUint64 && n.isExactInt() {
			return uint64(f), true
		}
		return 0, n.bits == 0 || n.bits == 1<<63
	}
	return 0, false
}

func (n *Number) isExactInt() bool {
	var eBits, mBits int

	switch n.typ {
	case InvalidType, IntType, UintType:
		return true
	case Float32Type:
		eBits = 8
		mBits = 23
	case Float64Type:
		eBits = 11
		mBits = 52
	default:
		return false
	}

	exp := int(n.bits>>mBits) & ((1 << eBits) - 1)
	mant := n.bits & ((1 << mBits) - 1)
	if exp == 0 && mant == 0 {
		return true
	}

	exp -= (1 << (eBits - 1)) - 1
	if exp < 0 || exp == 1<<(eBits-1) {
		return false
	}
	if exp >= mBits {
		return true
	}
	return bits.TrailingZeros64(mant) >= mBits-exp
}

func (n *Number) CoerceFloat() float64 {
	switch n.typ {
	case IntType:
		return float64(int64(n.bits))
	case UintType:
		return float64(n.bits)
	case Float32Type:
		return float64(math.Float32frombits(uint32(n.bits)))
	case Float64Type:
		return math.Float64frombits(n.bits)
	default:
		return 0
	}
}

func (n *Number) Msgsize() int {
	switch n.typ {
	case Float32Type:
		return Float32Size
	case Float64Type:
		return Float64Size
	case IntType:
		return Int64Size
	case UintType:
		return Uint64Size
	default:
		return 1
	}
}

func (n *Number) String() string {
	switch n.typ {
	case InvalidType:
		return "0"
	case Float32Type, Float64Type:
		f, _ := n.Float()
		return strconv.FormatFloat(f, 'f', -1, 64)
	case IntType:
		i, _ := n.Int()
		return strconv.FormatInt(i, 10)
	case UintType:
		u, _ := n.Uint()
		return strconv.FormatUint(u, 10)
	default:
		return "0"
	}
}

var be = binary.BigEndian

func readUintCore(b []byte, expectedMajor uint8) (uint64, []byte, error) {
	if len(b) < 1 {
		return 0, b, ErrShortBytes
	}

	major := getMajorType(b[0])
	if major != expectedMajor {
		return 0, b, badPrefix(major, expectedMajor)
	}

	addInfo := getAddInfo(b[0])

	switch {
	case addInfo <= addInfoDirect:
		return uint64(addInfo), b[1:], nil
	case addInfo == addInfoUint8:
		if len(b) < 2 {
			return 0, b, ErrShortBytes
		}
		return uint64(b[1]), b[2:], nil
	case addInfo == addInfoUint16:
		if len(b) < 3 {
			return 0, b, ErrShortBytes
		}
		return uint64(be.Uint16(b[1:])), b[3:], nil
	case addInfo == addInfoUint32:
		if len(b) < 5 {
			return 0, b, ErrShortBytes
		}
		return uint64(be.Uint32(b[1:])), b[5:], nil
	case addInfo == addInfoUint64:
		if len(b) < 9 {
			return 0, b, ErrShortBytes
		}
		return be.Uint64(b[1:]), b[9:], nil
	default:
		return 0, b, &ErrUnsupportedType{}
	}
}

func ReadMapHeaderBytes(b []byte) (sz uint32, o []byte, err error) {
	if len(b) < 1 {
		return 0, b, ErrShortBytes
	}

	lead := b[0]

	if lead >= 0xa0 && lead <= 0xb7 {
		return uint32(lead - 0xa0), b[1:], nil
	}
	if lead == 0xb8 {
		if len(b) < 2 {
			return 0, b, ErrShortBytes
		}
		return uint32(b[1]), b[2:], nil
	}
	if lead == 0xb9 {
		if len(b) < 3 {
			return 0, b, ErrShortBytes
		}
		return uint32(be.Uint16(b[1:])), b[3:], nil
	}
	if lead == 0xba {
		if len(b) < 5 {
			return 0, b, ErrShortBytes
		}
		return be.Uint32(b[1:]), b[5:], nil
	}
	if lead == 0xbb {
		if len(b) < 9 {
			return 0, b, ErrShortBytes
		}
		u := be.Uint64(b[1:])
		if u > math.MaxUint32 {
			return 0, b, UintOverflow{Value: u, FailedBitsize: 32}
		}
		return uint32(u), b[9:], nil
	}

	major := getMajorType(lead)
	return 0, b, badPrefix(major, majorTypeMap)
}

func ReadArrayHeaderBytes(b []byte) (sz uint32, o []byte, err error) {
	if len(b) < 1 {
		return 0, b, ErrShortBytes
	}

	lead := b[0]

	if lead >= 0x80 && lead <= 0x97 {
		return uint32(lead - 0x80), b[1:], nil
	}
	if lead == 0x98 {
		if len(b) < 2 {
			return 0, b, ErrShortBytes
		}
		return uint32(b[1]), b[2:], nil
	}
	if lead == 0x99 {
		if len(b) < 3 {
			return 0, b, ErrShortBytes
		}
		return uint32(be.Uint16(b[1:])), b[3:], nil
	}
	if lead == 0x9a {
		if len(b) < 5 {
			return 0, b, ErrShortBytes
		}
		return be.Uint32(b[1:]), b[5:], nil
	}
	if lead == 0x9b {
		if len(b) < 9 {
			return 0, b, ErrShortBytes
		}
		u := be.Uint64(b[1:])
		if u > math.MaxUint32 {
			return 0, b, UintOverflow{Value: u, FailedBitsize: 32}
		}
		return uint32(u), b[9:], nil
	}

	major := getMajorType(lead)
	return 0, b, badPrefix(major, majorTypeArray)
}

func ReadMapStartBytes(b []byte) (sz uint32, indefinite bool, rest []byte, err error) {
	if len(b) < 1 {
		return 0, false, b, ErrShortBytes
	}
	if b[0] == makeByte(majorTypeMap, addInfoIndefinite) {
		return 0, true, b[1:], nil
	}
	s, o, e := ReadMapHeaderBytes(b)
	return s, false, o, e
}

func ReadArrayStartBytes(b []byte) (sz uint32, indefinite bool, rest []byte, err error) {
	if len(b) < 1 {
		return 0, false, b, ErrShortBytes
	}
	if b[0] == makeByte(majorTypeArray, addInfoIndefinite) {
		return 0, true, b[1:], nil
	}
	s, o, e := ReadArrayHeaderBytes(b)
	return s, false, o, e
}

func ReadBreakBytes(b []byte) (rest []byte, ok bool, err error) {
	if len(b) < 1 {
		return b, false, ErrShortBytes
	}
	if b[0] == makeByte(majorTypeSimple, simpleBreak) {
		return b[1:], true, nil
	}
	return b, false, nil
}

func ReadNilBytes(b []byte) ([]byte, error) {
	if len(b) < 1 {
		return b, ErrShortBytes
	}
	if b[0] != makeByte(majorTypeSimple, simpleNull) {
		return b, ErrNotNil
	}
	return b[1:], nil
}

func ReadFloat64Bytes(b []byte) (f float64, o []byte, err error) {
	if len(b) < 9 {
		return 0, b, ErrShortBytes
	}

	if b[0] != 0xfb {
		return 0, b, badPrefix(getMajorType(b[0]), majorTypeSimple)
	}
	f = math.Float64frombits(be.Uint64(b[1:]))
	return f, b[9:], nil
}

func ReadFloat32Bytes(b []byte) (f float32, o []byte, err error) {
	if len(b) < 5 {
		return 0, b, ErrShortBytes
	}

	if b[0] != 0xfa {
		return 0, b, badPrefix(getMajorType(b[0]), majorTypeSimple)
	}
	f = math.Float32frombits(be.Uint32(b[1:]))
	return f, b[5:], nil
}

func ReadFloat16Bytes(b []byte) (f float32, o []byte, err error) {
	if len(b) < 3 {
		return 0, b, ErrShortBytes
	}
	if b[0] != 0xF9 {
		return 0, b, badPrefix(getMajorType(b[0]), majorTypeSimple)
	}
	h := binary.BigEndian.Uint16(b[1:])
	f = float16BitsToFloat32(h)
	return f, b[3:], nil
}

func ReadBoolBytes(b []byte) (bool, []byte, error) {
	if len(b) < 1 {
		return false, b, ErrShortBytes
	}

	if b[0] == 0xf5 {
		return true, b[1:], nil
	}
	if b[0] == 0xf4 {
		return false, b[1:], nil
	}
	return false, b, TypeError{Method: BoolType, Encoded: getType(b[0])}
}

func ReadInt64Bytes(b []byte) (i int64, o []byte, err error) {
	if len(b) < 1 {
		return 0, b, ErrShortBytes
	}

	lead := b[0]

	if lead <= 0x17 {
		return int64(lead), b[1:], nil
	}
	if lead == 0x18 {
		if len(b) < 2 {
			return 0, b, ErrShortBytes
		}
		return int64(b[1]), b[2:], nil
	}
	if lead == 0x19 {
		if len(b) < 3 {
			return 0, b, ErrShortBytes
		}
		return int64(be.Uint16(b[1:])), b[3:], nil
	}
	if lead == 0x1a {
		if len(b) < 5 {
			return 0, b, ErrShortBytes
		}
		u := uint64(be.Uint32(b[1:]))
		return int64(u), b[5:], nil
	}
	if lead == 0x1b {
		if len(b) < 9 {
			return 0, b, ErrShortBytes
		}
		u := be.Uint64(b[1:])
		if u > math.MaxInt64 {
			return 0, b, IntOverflow{Value: int64(u), FailedBitsize: 64}
		}
		return int64(u), b[9:], nil
	}

	if lead >= 0x20 && lead <= 0x37 {
		return -1 - int64(lead-0x20), b[1:], nil
	}
	if lead == 0x38 {
		if len(b) < 2 {
			return 0, b, ErrShortBytes
		}
		return -1 - int64(b[1]), b[2:], nil
	}
	if lead == 0x39 {
		if len(b) < 3 {
			return 0, b, ErrShortBytes
		}
		return -1 - int64(be.Uint16(b[1:])), b[3:], nil
	}
	if lead == 0x3a {
		if len(b) < 5 {
			return 0, b, ErrShortBytes
		}
		return -1 - int64(be.Uint32(b[1:])), b[5:], nil
	}
	if lead == 0x3b {
		if len(b) < 9 {
			return 0, b, ErrShortBytes
		}
		u := be.Uint64(b[1:])
		if u > math.MaxInt64 {
			return 0, b, IntOverflow{Value: -1, FailedBitsize: 64}
		}
		return -1 - int64(u), b[9:], nil
	}

	major := (lead >> 5) & 0x07
	return 0, b, badPrefix(major, majorTypeUint)
}

func ReadInt32Bytes(b []byte) (i int32, o []byte, err error) {
	i64, o, err := ReadInt64Bytes(b)
	if err != nil {
		return 0, b, err
	}
	if i64 > math.MaxInt32 || i64 < math.MinInt32 {
		return 0, b, IntOverflow{Value: i64, FailedBitsize: 32}
	}
	return int32(i64), o, nil
}

func ReadInt16Bytes(b []byte) (i int16, o []byte, err error) {
	i64, o, err := ReadInt64Bytes(b)
	if err != nil {
		return 0, b, err
	}
	if i64 > math.MaxInt16 || i64 < math.MinInt16 {
		return 0, b, IntOverflow{Value: i64, FailedBitsize: 16}
	}
	return int16(i64), o, nil
}

func ReadInt8Bytes(b []byte) (i int8, o []byte, err error) {
	i64, o, err := ReadInt64Bytes(b)
	if err != nil {
		return 0, b, err
	}
	if i64 > math.MaxInt8 || i64 < math.MinInt8 {
		return 0, b, IntOverflow{Value: i64, FailedBitsize: 8}
	}
	return int8(i64), o, nil
}

func ReadIntBytes(b []byte) (i int, o []byte, err error) {
	i64, o, err := ReadInt64Bytes(b)
	if err != nil {
		return 0, b, err
	}
	return int(i64), o, nil
}

func ReadUint64Bytes(b []byte) (u uint64, o []byte, err error) {
	return readUintCore(b, majorTypeUint)
}

func ReadUint32Bytes(b []byte) (u uint32, o []byte, err error) {
	u64, o, err := readUintCore(b, majorTypeUint)
	if err != nil {
		return 0, b, err
	}
	if u64 > math.MaxUint32 {
		return 0, b, UintOverflow{Value: u64, FailedBitsize: 32}
	}
	return uint32(u64), o, nil
}

func ReadUint16Bytes(b []byte) (u uint16, o []byte, err error) {
	u64, o, err := readUintCore(b, majorTypeUint)
	if err != nil {
		return 0, b, err
	}
	if u64 > math.MaxUint16 {
		return 0, b, UintOverflow{Value: u64, FailedBitsize: 16}
	}
	return uint16(u64), o, nil
}

func ReadUint8Bytes(b []byte) (u uint8, o []byte, err error) {
	u64, o, err := readUintCore(b, majorTypeUint)
	if err != nil {
		return 0, b, err
	}
	if u64 > math.MaxUint8 {
		return 0, b, UintOverflow{Value: u64, FailedBitsize: 8}
	}
	return uint8(u64), o, nil
}

func ReadUintBytes(b []byte) (u uint, o []byte, err error) {
	u64, o, err := readUintCore(b, majorTypeUint)
	if err != nil {
		return 0, b, err
	}
	return uint(u64), o, nil
}

func ReadBytesBytes(b []byte, scratch []byte) (v []byte, o []byte, err error) {
	if len(b) < 1 {
		return nil, b, ErrShortBytes
	}

	if b[0] == makeByte(majorTypeBytes, addInfoIndefinite) {
		out := scratch[:0]
		p := b[1:]
		for {
			if len(p) < 1 {
				return nil, b, ErrShortBytes
			}
			// Break?
			if p[0] == makeByte(majorTypeSimple, simpleBreak) {
				return out, p[1:], nil
			}
			// Next must be a definite-length byte string
			sz, q, e := readUintCore(p, majorTypeBytes)
			if e != nil {
				return nil, b, e
			}
			if uint64(len(q)) < sz {
				return nil, b, ErrShortBytes
			}
			out = append(out, q[:sz]...)
			p = q[sz:]
		}
	}
	sz, o, err := readUintCore(b, majorTypeBytes)
	if err != nil {
		return nil, b, err
	}
	if uint64(len(o)) < sz {
		return nil, b, ErrShortBytes
	}
	if sz == 0 {
		return scratch[:0], o, nil
	}
	return o[:sz], o[sz:], nil
}

// ReadStringZC reads a text string zero-copy (returns slice into original buffer)
func ReadStringZC(b []byte) (v []byte, o []byte, err error) {
	if len(b) < 1 {
		return nil, b, ErrShortBytes
	}

	lead := b[0]

	// Ultra-fast path for length 0-23
	if lead >= 0x60 && lead <= 0x77 {
		sz := int(lead & 0x1f)
		if len(b) < 1+sz {
			return nil, b, ErrShortBytes
		}
		return b[1 : 1+sz], b[1+sz:], nil
	}

	// Longer strings
	var sz int
	var start int

	switch lead {
	case 0x78: // uint8
		if len(b) < 2 {
			return nil, b, ErrShortBytes
		}
		sz = int(b[1])
		start = 2
	case 0x79: // uint16
		if len(b) < 3 {
			return nil, b, ErrShortBytes
		}
		sz = int(be.Uint16(b[1:]))
		start = 3
	case 0x7a: // uint32
		if len(b) < 5 {
			return nil, b, ErrShortBytes
		}
		sz = int(be.Uint32(b[1:]))
		start = 5
	case 0x7b: // uint64
		if len(b) < 9 {
			return nil, b, ErrShortBytes
		}
		u64 := be.Uint64(b[1:])
		if u64 > math.MaxInt {
			return nil, b, UintOverflow{Value: u64, FailedBitsize: 64}
		}
		sz = int(u64)
		start = 9
	default:
		// Invalid major type
		major := getMajorType(lead)
		return nil, b, badPrefix(major, majorTypeText)
	}

	// Guard against integer overflow and out-of-bounds slicing.
	// Use subtraction form to avoid start+sz overflow when sz is near MaxInt.
	if start < 0 || start > len(b) {
		return nil, b, ErrShortBytes
	}
	if sz < 0 || sz > len(b)-start {
		return nil, b, ErrShortBytes
	}
	end := start + sz
	return b[start:end], b[end:], nil
}

// ReadStringBytes reads a text string
func ReadStringBytes(b []byte) (s string, o []byte, err error) {
	if len(b) < 1 {
		return "", b, ErrShortBytes
	}
	// Indefinite-length text string (0x7f)
	if b[0] == makeByte(majorTypeText, addInfoIndefinite) {
		p := b[1:]
		var out []byte
		for {
			if len(p) < 1 {
				return "", b, ErrShortBytes
			}
			if p[0] == makeByte(majorTypeSimple, simpleBreak) {
				if ValidateUTF8OnDecode && !isUTF8Valid(out) {
					return "", b, ErrInvalidUTF8
				}
				return string(out), p[1:], nil
			}
			chunk, q, e := ReadStringZC(p)
			if e != nil {
				return "", b, e
			}
			out = append(out, chunk...)
			p = q
		}
	}
	v, o, err := ReadStringZC(b)
	if err != nil {
		return "", b, err
	}
	if ValidateUTF8OnDecode && !isUTF8Valid(v) {
		return "", b, ErrInvalidUTF8
	}
	if UnsafeStringDecode {
		return UnsafeString(v), o, nil
	}
	return string(v), o, nil
}

// ReadMapKeyZC reads a map key expecting a text string and returns its bytes zero-copy.
// It is a thin wrapper around ReadStringZC for generated code compatibility.
func ReadMapKeyZC(b []byte) (v []byte, o []byte, err error) {
	// For CBOR, map keys are typically text. Support text zero-copy here.
	if len(b) < 1 {
		return nil, b, ErrShortBytes
	}
	if getMajorType(b[0]) != majorTypeText {
		// Fallback: treat as text anyway to surface a type error consistently
		return nil, b, TypeError{Method: StrType, Encoded: getType(b[0])}
	}
	return ReadStringZC(b)
}

// ReadSimpleValue reads a simple value and returns its numeric value.
// Returns values 0..23 (including false/true/null/undefined) directly,
// or 32..255 following a 0xf8 prefix. Float encodings are not handled here.
func ReadSimpleValue(b []byte) (val uint8, o []byte, err error) {
	if len(b) < 1 {
		return 0, b, ErrShortBytes
	}
	major := getMajorType(b[0])
	if major != majorTypeSimple {
		return 0, b, badPrefix(major, majorTypeSimple)
	}
	addInfo := getAddInfo(b[0])
	switch addInfo {
	case simpleFloat16, simpleFloat32, simpleFloat64:
		return 0, b, &ErrUnsupportedType{}
	case addInfoUint8: // 0xf8 XX
		if len(b) < 2 {
			return 0, b, ErrShortBytes
		}
		return b[1], b[2:], nil
	default:
		if addInfo <= addInfoDirect {
			return addInfo, b[1:], nil
		}
		return 0, b, &ErrUnsupportedType{}
	}
}

// ReadTimeBytes reads a time.Time (CBOR tag 1 with Unix timestamp)
func ReadTimeBytes(b []byte) (t time.Time, o []byte, err error) {
	if len(b) < 2 {
		return time.Time{}, b, ErrShortBytes
	}
	if getMajorType(b[0]) != majorTypeTag {
		return time.Time{}, b, badPrefix(getMajorType(b[0]), majorTypeTag)
	}
	tag, o, err := readUintCore(b, majorTypeTag)
	if err != nil {
		return time.Time{}, b, err
	}
	if tag != tagEpochDateTime {
		return time.Time{}, b, errors.New("cbor: expected epoch datetime tag")
	}
	if len(o) < 1 {
		return time.Time{}, b, ErrShortBytes
	}
	switch getMajorType(o[0]) {
	case majorTypeUint, majorTypeNegInt:
		sec, o2, e := ReadInt64Bytes(o)
		if e != nil {
			return time.Time{}, b, e
		}
		return time.Unix(sec, 0), o2, nil
	case majorTypeSimple:
		add := getAddInfo(o[0])
		switch add {
		case simpleFloat64:
			f, o2, e := ReadFloat64Bytes(o)
			if e != nil {
				return time.Time{}, b, e
			}
			sec := math.Floor(f)
			ns := int64(math.Round((f - sec) * 1e9))
			secs := int64(sec)
			if ns >= 1e9 {
				secs++
				ns -= 1e9
			}
			return time.Unix(secs, ns), o2, nil
		case simpleFloat32:
			f, o2, e := ReadFloat32Bytes(o)
			if e != nil {
				return time.Time{}, b, e
			}
			sec := math.Floor(float64(f))
			ns := int64(math.Round((float64(f) - sec) * 1e9))
			secs := int64(sec)
			if ns >= 1e9 {
				secs++
				ns -= 1e9
			}
			return time.Unix(secs, ns), o2, nil
		case simpleFloat16:
			f, o2, e := ReadFloat16Bytes(o)
			if e != nil {
				return time.Time{}, b, e
			}
			sec := math.Floor(float64(f))
			ns := int64(math.Round((float64(f) - sec) * 1e9))
			secs := int64(sec)
			if ns >= 1e9 {
				secs++
				ns -= 1e9
			}
			return time.Unix(secs, ns), o2, nil
		default:
			return time.Time{}, b, &ErrUnsupportedType{}
		}
	default:
		return time.Time{}, b, &ErrUnsupportedType{}
	}
}

// ReadTagBytes reads a semantic tag value (major type 6)
func ReadTagBytes(b []byte) (tag uint64, o []byte, err error) {
	tag, o, err = readUintCore(b, majorTypeTag)
	if err != nil {
		return 0, b, err
	}
	return tag, o, nil
}

// ReadRFC3339TimeBytes reads a tag(0) RFC3339 time string into time.Time
func ReadRFC3339TimeBytes(b []byte) (t time.Time, o []byte, err error) {
	tag, o, err := ReadTagBytes(b)
	if err != nil {
		return time.Time{}, b, err
	}
	if tag != tagDateTimeString {
		return time.Time{}, b, badPrefix(majorTypeTag, majorTypeTag)
	}
	s, o2, err := ReadStringBytes(o)
	if err != nil {
		return time.Time{}, b, err
	}
	tt, perr := time.Parse(time.RFC3339Nano, s)
	if perr != nil {
		return time.Time{}, b, perr
	}
	return tt, o2, nil
}

// ReadBase64URLStringBytes reads tag(33) base64url text string
func ReadBase64URLStringBytes(b []byte) (s string, o []byte, err error) {
	tag, o, err := ReadTagBytes(b)
	if err != nil {
		return "", b, err
	}
	if tag != tagBase64URLString {
		return "", b, badPrefix(majorTypeTag, majorTypeTag)
	}
	return ReadStringBytes(o)
}

// ReadBase64StringBytes reads tag(34) base64 text string
func ReadBase64StringBytes(b []byte) (s string, o []byte, err error) {
	tag, o, err := ReadTagBytes(b)
	if err != nil {
		return "", b, err
	}
	if tag != tagBase64String {
		return "", b, badPrefix(majorTypeTag, majorTypeTag)
	}
	return ReadStringBytes(o)
}

// ReadURIStringBytes reads a tag(32) URI text string
func ReadURIStringBytes(b []byte) (uri string, o []byte, err error) {
	tag, o, err := ReadTagBytes(b)
	if err != nil {
		return "", b, err
	}
	if tag != tagURI {
		return "", b, badPrefix(majorTypeTag, majorTypeTag)
	}
	return ReadStringBytes(o)
}

// ReadEmbeddedCBORBytes reads tag(24) with embedded CBOR payload
func ReadEmbeddedCBORBytes(b []byte) (payload []byte, o []byte, err error) {
	tag, o, err := ReadTagBytes(b)
	if err != nil {
		return nil, b, err
	}
	if tag != tagCBOR {
		return nil, b, badPrefix(majorTypeTag, majorTypeTag)
	}
	return ReadBytesBytes(o, nil)
}

// ReadBase64URLBytes reads tag(21) byte string
func ReadBase64URLBytes(b []byte) (bs []byte, o []byte, err error) {
	tag, o, err := ReadTagBytes(b)
	if err != nil {
		return nil, b, err
	}
	if tag != tagBase64URL {
		return nil, b, badPrefix(majorTypeTag, majorTypeTag)
	}
	return ReadBytesBytes(o, nil)
}

// ReadBase64Bytes reads tag(22) byte string
func ReadBase64Bytes(b []byte) (bs []byte, o []byte, err error) {
	tag, o, err := ReadTagBytes(b)
	if err != nil {
		return nil, b, err
	}
	if tag != tagBase64 {
		return nil, b, badPrefix(majorTypeTag, majorTypeTag)
	}
	return ReadBytesBytes(o, nil)
}

// ReadBase16Bytes reads tag(23) byte string
func ReadBase16Bytes(b []byte) (bs []byte, o []byte, err error) {
	tag, o, err := ReadTagBytes(b)
	if err != nil {
		return nil, b, err
	}
	if tag != tagBase16 {
		return nil, b, badPrefix(majorTypeTag, majorTypeTag)
	}
	return ReadBytesBytes(o, nil)
}

// ReadUUIDBytes reads tag(37) UUID as 16-byte array
func ReadUUIDBytes(b []byte) (uuid [16]byte, o []byte, err error) {
	tag, o, err := ReadTagBytes(b)
	if err != nil {
		return uuid, b, err
	}
	if tag != 37 {
		return uuid, b, badPrefix(majorTypeTag, majorTypeTag)
	}
	bs, o2, err := ReadBytesBytes(o, nil)
	if err != nil {
		return uuid, b, err
	}
	if len(bs) != 16 {
		return uuid, b, errors.New("cbor: uuid must be 16 bytes")
	}
	copy(uuid[:], bs)
	return uuid, o2, nil
}

// ReadRegexpStringBytes reads tag(35) regular expression pattern as text string
func ReadRegexpStringBytes(b []byte) (pattern string, o []byte, err error) {
	tag, o, err := ReadTagBytes(b)
	if err != nil {
		return "", b, err
	}
	if tag != tagRegexp {
		return "", b, badPrefix(majorTypeTag, majorTypeTag)
	}
	return ReadStringBytes(o)
}

// ReadMIMEStringBytes reads tag(36) MIME message as text string
func ReadMIMEStringBytes(b []byte) (mime string, o []byte, err error) {
	tag, o, err := ReadTagBytes(b)
	if err != nil {
		return "", b, err
	}
	if tag != tagMIME {
		return "", b, badPrefix(majorTypeTag, majorTypeTag)
	}
	return ReadStringBytes(o)
}

// StripSelfDescribeCBOR checks for and consumes a self-describe CBOR tag (0xd9d9f7)
func StripSelfDescribeCBOR(b []byte) (rest []byte, found bool, err error) {
	if len(b) < 1 {
		return b, false, ErrShortBytes
	}
	if getMajorType(b[0]) != majorTypeTag {
		return b, false, nil
	}
	tag, o, e := ReadTagBytes(b)
	if e != nil {
		return b, false, e
	}
	if tag != tagSelfDescribeCBOR {
		return b, false, nil
	}
	return o, true, nil
}

// ReadRegexpBytes reads tag(35) and compiles the contained pattern into *regexp.Regexp
func ReadRegexpBytes(b []byte) (re *regexp.Regexp, o []byte, err error) {
	s, o, err := ReadRegexpStringBytes(b)
	if err != nil {
		return nil, b, err
	}
	r, e := regexp.Compile(s)
	if e != nil {
		return nil, b, e
	}
	return r, o, nil
}

// ReadBigIntBytes reads a bignum (tag 2 or 3) into a big.Int
func ReadBigIntBytes(b []byte) (z *bigmath.Int, o []byte, err error) {
	tag, o, err := ReadTagBytes(b)
	if err != nil {
		return nil, b, err
	}
	bs, o2, err := ReadBytesBytes(o, nil)
	if err != nil {
		return nil, b, err
	}
	mag := new(bigmath.Int).SetBytes(bs)
	switch tag {
	case tagPosBignum:
		return mag, o2, nil
	case tagNegBignum:
		mag.Add(mag, bigmath.NewInt(1))
		mag.Neg(mag)
		return mag, o2, nil
	default:
		return nil, b, badPrefix(majorTypeTag, majorTypeTag)
	}
}

// readCBORIntegerAsBigInt reads a CBOR integer (major type 0/1) or bignum (tags 2/3) into big.Int
func readCBORIntegerAsBigInt(b []byte) (*bigmath.Int, []byte, error) {
	if len(b) < 1 {
		return nil, b, ErrShortBytes
	}
	major := getMajorType(b[0])
	switch major {
	case majorTypeUint:
		u, o, err := readUintCore(b, majorTypeUint)
		if err != nil {
			return nil, b, err
		}
		zz := new(bigmath.Int).SetUint64(u)
		return zz, o, nil
	case majorTypeNegInt:
		i, o, err := ReadInt64Bytes(b)
		if err != nil {
			return nil, b, err
		}
		zz := bigmath.NewInt(i)
		return zz, o, nil
	case majorTypeTag:
		tag, o, err := ReadTagBytes(b)
		if err != nil {
			return nil, b, err
		}
		if tag != tagPosBignum && tag != tagNegBignum {
			return nil, b, &ErrUnsupportedType{}
		}
		bs, o2, err := ReadBytesBytes(o, nil)
		if err != nil {
			return nil, b, err
		}
		mag := new(bigmath.Int).SetBytes(bs)
		if tag == tagNegBignum {
			mag.Add(mag, bigmath.NewInt(1))
			mag.Neg(mag)
		}
		return mag, o2, nil
	default:
		return nil, b, &ErrUnsupportedType{}
	}
}

// ReadDecimalFractionBytes reads tag(4) decimal fraction [exponent, mantissa]
func ReadDecimalFractionBytes(b []byte) (exp int64, mant *bigmath.Int, o []byte, err error) {
	tag, o, err := ReadTagBytes(b)
	if err != nil {
		return 0, nil, b, err
	}
	if tag != tagDecimalFrac {
		return 0, nil, b, &ErrUnsupportedType{}
	}
	// Handle definite and indefinite arrays
	if len(o) < 1 {
		return 0, nil, b, ErrShortBytes
	}
	if o[0] == makeByte(majorTypeArray, addInfoIndefinite) {
		// skip header
		p := o[1:]
		// exponent
		exp, p, err = ReadInt64Bytes(p)
		if err != nil {
			return 0, nil, b, err
		}
		// mantissa
		mant, p, err = readCBORIntegerAsBigInt(p)
		if err != nil {
			return 0, nil, b, err
		}
		// expect break
		if len(p) < 1 || p[0] != makeByte(majorTypeSimple, simpleBreak) {
			return 0, nil, b, &ErrUnsupportedType{}
		}
		return exp, mant, p[1:], nil
	}
	// definite
	sz, p, err := ReadArrayHeaderBytes(o)
	if err != nil {
		return 0, nil, b, err
	}
	if sz != 2 {
		return 0, nil, b, ArrayError{Wanted: 2, Got: sz}
	}
	exp, p, err = ReadInt64Bytes(p)
	if err != nil {
		return 0, nil, b, err
	}
	mant, p, err = readCBORIntegerAsBigInt(p)
	if err != nil {
		return 0, nil, b, err
	}
	return exp, mant, p, nil
}

// ReadBigfloatBytes reads tag(5) bigfloat [exponent, mantissa]
func ReadBigfloatBytes(b []byte) (exp int64, mant *bigmath.Int, o []byte, err error) {
	tag, o, err := ReadTagBytes(b)
	if err != nil {
		return 0, nil, b, err
	}
	if tag != tagBigfloat {
		return 0, nil, b, &ErrUnsupportedType{}
	}
	if len(o) < 1 {
		return 0, nil, b, ErrShortBytes
	}
	if o[0] == makeByte(majorTypeArray, addInfoIndefinite) {
		p := o[1:]
		exp, p, err = ReadInt64Bytes(p)
		if err != nil {
			return 0, nil, b, err
		}
		mant, p, err = readCBORIntegerAsBigInt(p)
		if err != nil {
			return 0, nil, b, err
		}
		if len(p) < 1 || p[0] != makeByte(majorTypeSimple, simpleBreak) {
			return 0, nil, b, &ErrUnsupportedType{}
		}
		return exp, mant, p[1:], nil
	}
	sz, p, err := ReadArrayHeaderBytes(o)
	if err != nil {
		return 0, nil, b, err
	}
	if sz != 2 {
		return 0, nil, b, ArrayError{Wanted: 2, Got: sz}
	}
	exp, p, err = ReadInt64Bytes(p)
	if err != nil {
		return 0, nil, b, err
	}
	mant, p, err = readCBORIntegerAsBigInt(p)
	if err != nil {
		return 0, nil, b, err
	}
	return exp, mant, p, nil
}

// ReadMapNoDupBytes validates that the next CBOR item is a map and that it has no duplicate keys.
// Keys are compared by raw CBOR byte representation. Returns the bytes after the map or an error.
func ReadMapNoDupBytes(b []byte) (o []byte, err error) {
	if len(b) < 1 {
		return b, ErrShortBytes
	}
	if getMajorType(b[0]) != majorTypeMap {
		return b, badPrefix(majorTypeMap, getMajorType(b[0]))
	}
	// Indefinite-length map
	if getAddInfo(b[0]) == addInfoIndefinite {
		seen := make(map[string]struct{})
		p := b[1:]
		for {
			if len(p) < 1 {
				return b, ErrShortBytes
			}
			if p[0] == makeByte(majorTypeSimple, simpleBreak) {
				return p[1:], nil
			}
			// Capture raw key bytes
			r, err := Skip(p)
			if err != nil {
				return b, err
			}
			keyLen := len(p) - len(r)
			rawKey := p[:keyLen]
			keyStr := string(rawKey)
			if _, ok := seen[keyStr]; ok {
				return b, ErrDuplicateMapKey
			}
			seen[keyStr] = struct{}{}
			// Skip value
			r2, err := Skip(r)
			if err != nil {
				return b, err
			}
			p = r2
		}
	}
	// Definite-length map
	sz, p, err := ReadMapHeaderBytes(b)
	if err != nil {
		return b, err
	}
	seen := make(map[string]struct{}, sz)
	for i := uint32(0); i < sz; i++ {
		r, err := Skip(p)
		if err != nil {
			return b, err
		}
		keyLen := len(p) - len(r)
		rawKey := p[:keyLen]
		keyStr := string(rawKey)
		if _, ok := seen[keyStr]; ok {
			return b, ErrDuplicateMapKey
		}
		seen[keyStr] = struct{}{}
		// skip value
		p2, err := Skip(r)
		if err != nil {
			return b, err
		}
		p = p2
	}
	return p, nil
}

// ForEachSequenceBytes calls onItem for each CBOR item in a CBOR sequence buffer b.
// The item passed to onItem is a slice referencing b containing exactly one item.
func ForEachSequenceBytes(b []byte, onItem func(item []byte) error) error {
	p := b
	for len(p) > 0 {
		r, err := Skip(p)
		if err != nil {
			return err
		}
		seg := p[:len(p)-len(r)]
		if err := onItem(seg); err != nil {
			return err
		}
		p = r
	}
	return nil
}

// SplitSequenceBytes splits a CBOR sequence into a slice of item slices referencing the original buffer.
func SplitSequenceBytes(b []byte) (out [][]byte, err error) {
	err = ForEachSequenceBytes(b, func(it []byte) error { out = append(out, it); return nil })
	return out, err
}

// AppendSequence appends a sequence of pre-encoded CBOR items to b.
// Each item must be a complete CBOR data item.
func AppendSequence(b []byte, items ...[]byte) []byte {
	for _, it := range items {
		b = append(b, it...)
	}
	return b
}

// AppendSequenceFunc appends n items produced by fn(i), where each returned []byte is a full CBOR item.
func AppendSequenceFunc(b []byte, n int, fn func(i int) ([]byte, error)) ([]byte, error) {
	for i := 0; i < n; i++ {
		it, err := fn(i)
		if err != nil {
			return b, err
		}
		b = append(b, it...)
	}
	return b, nil
}

// ReadOrderedMapBytes reads the next CBOR map (definite or indefinite) and
// returns a slice of RawPair in the order they appeared on the wire.
// Each Key and Value contains exactly one CBOR item (copied).
func ReadOrderedMapBytes(b []byte) (pairs []RawPair, o []byte, err error) {
	if len(b) < 1 {
		return nil, b, ErrShortBytes
	}
	if getMajorType(b[0]) != majorTypeMap {
		return nil, b, badPrefix(majorTypeMap, getMajorType(b[0]))
	}
	// Indefinite-length map
	if getAddInfo(b[0]) == addInfoIndefinite {
		p := b[1:]
		var scratch []byte
		for {
			if len(p) < 1 {
				return nil, b, ErrShortBytes
			}
			if p[0] == makeByte(majorTypeSimple, simpleBreak) {
				return pairs, p[1:], nil
			}
			// Capture raw key
			r1, err := Skip(p)
			if err != nil {
				return nil, b, err
			}
			klen := len(p) - len(r1)
			// Append key bytes into a shared scratch buffer and take a subslice
			startK := len(scratch)
			scratch = append(scratch, p[:klen]...)
			kraw := scratch[startK:]
			// Capture raw value
			r2, err := Skip(r1)
			if err != nil {
				return nil, b, err
			}
			vlen := len(r1) - len(r2)
			startV := len(scratch)
			scratch = append(scratch, r1[:vlen]...)
			vraw := scratch[startV:]
			pairs = append(pairs, RawPair{Key: kraw, Value: vraw})
			p = r2
		}
	}
	// Definite-length map
	sz, p, err := ReadMapHeaderBytes(b)
	if err != nil {
		return nil, b, err
	}
	pairs = make([]RawPair, 0, sz)
	var scratch []byte
	for i := uint32(0); i < sz; i++ {
		r1, err := Skip(p)
		if err != nil {
			return nil, b, err
		}
		klen := len(p) - len(r1)
		startK := len(scratch)
		scratch = append(scratch, p[:klen]...)
		kraw := scratch[startK:]
		r2, err := Skip(r1)
		if err != nil {
			return nil, b, err
		}
		vlen := len(r1) - len(r2)
		startV := len(scratch)
		scratch = append(scratch, r1[:vlen]...)
		vraw := scratch[startV:]
		pairs = append(pairs, RawPair{Key: kraw, Value: vraw})
		p = r2
	}
	return pairs, p, nil
}

// float16BitsToFloat32 converts IEEE 754 binary16 bits to float32
func float16BitsToFloat32(h uint16) float32 {
	sign := uint32(h>>15) & 0x1
	exp := (h >> 10) & 0x1F
	mant := uint32(h & 0x03FF)
	var bits uint32
	switch exp {
	case 0:
		if mant == 0 {
			bits = sign << 31
		} else {
			// subnormal: value = mant / 2^10 * 2^-14 = mant * 2^-24
			// Build float by arithmetic
			f := math.Ldexp(float64(mant), -24)
			if sign != 0 {
				f = -f
			}
			return float32(f)
		}
	case 0x1F:
		// Inf/NaN
		bits = (sign << 31) | (0xFF << 23)
		if mant != 0 {
			bits |= (mant << 13)
		}
	default:
		// normalized
		e32 := int(exp) - 15 + 127
		bits = (sign << 31) | (uint32(e32) << 23) | (mant << 13)
	}
	return math.Float32frombits(bits)
}

// ReadDurationBytes reads a time.Duration
func ReadDurationBytes(b []byte) (d time.Duration, o []byte, err error) {
	i64, o, err := ReadInt64Bytes(b)
	if err != nil {
		return 0, b, err
	}
	return time.Duration(i64), o, nil
}

// ReadMapStrStrBytes reads a map[string]string
func ReadMapStrStrBytes(b []byte, m map[string]string) (o []byte, err error) {
	sz, o, err := ReadMapHeaderBytes(b)
	if err != nil {
		return b, err
	}

	for i := uint32(0); i < sz; i++ {
		var key, val string
		key, o, err = ReadStringBytes(o)
		if err != nil {
			return b, err
		}
		val, o, err = ReadStringBytes(o)
		if err != nil {
			return b, err
		}
		m[key] = val
	}
	return o, nil
}

// Skip skips over the next CBOR object
func Skip(b []byte) ([]byte, error) {
	return skip(b, 0)
}

func skip(b []byte, depth int) ([]byte, error) {
	if depth > recursionLimit {
		return b, ErrMaxDepthExceeded
	}
	if len(b) < 1 {
		return b, ErrShortBytes
	}

	major := getMajorType(b[0])
	addInfo := getAddInfo(b[0])

	switch major {
	case majorTypeUint, majorTypeNegInt, majorTypeTag:
		_, o, err := readUintCore(b, major)
		if err != nil {
			return b, err
		}
		if major == majorTypeTag {
			return skip(o, depth+1)
		}
		return o, nil

	case majorTypeBytes, majorTypeText:
		if addInfo == addInfoIndefinite {
			// Indefinite-length string: series of definite chunks terminated by break
			o := b[1:]
			for {
				if len(o) < 1 {
					return b, ErrShortBytes
				}
				if o[0] == makeByte(majorTypeSimple, simpleBreak) {
					return o[1:], nil
				}
				// Next must be a definite-length chunk of same major type
				sz, q, err := readUintCore(o, major)
				if err != nil {
					return b, err
				}
				if uint64(len(q)) < sz {
					return b, ErrShortBytes
				}
				o = q[sz:]
			}
		}
		sz, o, err := readUintCore(b, major)
		if err != nil {
			return b, err
		}
		if uint64(len(o)) < sz {
			return b, ErrShortBytes
		}
		return o[sz:], nil

	case majorTypeArray:
		if addInfo == addInfoIndefinite {
			o := b[1:]
			for {
				if len(o) < 1 {
					return b, ErrShortBytes
				}
				if o[0] == makeByte(majorTypeSimple, simpleBreak) {
					return o[1:], nil
				}
				var err error
				o, err = skip(o, depth+1)
				if err != nil {
					return b, err
				}
			}
		}
		sz, o, err := readUintCore(b, major)
		if err != nil {
			return b, err
		}
		for i := uint64(0); i < sz; i++ {
			o, err = skip(o, depth+1)
			if err != nil {
				return b, err
			}
		}
		return o, nil

	case majorTypeMap:
		if addInfo == addInfoIndefinite {
			o := b[1:]
			for {
				if len(o) < 1 {
					return b, ErrShortBytes
				}
				if o[0] == makeByte(majorTypeSimple, simpleBreak) {
					return o[1:], nil
				}
				var err error
				o, err = skip(o, depth+1) // key
				if err != nil {
					return b, err
				}
				o, err = skip(o, depth+1) // value
				if err != nil {
					return b, err
				}
			}
		}
		sz, o, err := readUintCore(b, major)
		if err != nil {
			return b, err
		}
		for i := uint64(0); i < sz; i++ {
			o, err = skip(o, depth+1) // key
			if err != nil {
				return b, err
			}
			o, err = skip(o, depth+1) // value
			if err != nil {
				return b, err
			}
		}
		return o, nil

	case majorTypeSimple:
		switch addInfo {
		case simpleFalse, simpleTrue, simpleNull, simpleUndefined:
			return b[1:], nil
		case simpleFloat16:
			if len(b) < 3 {
				return b, ErrShortBytes
			}
			return b[3:], nil
		case simpleFloat32:
			if len(b) < 5 {
				return b, ErrShortBytes
			}
			return b[5:], nil
		case simpleFloat64:
			if len(b) < 9 {
				return b, ErrShortBytes
			}
			return b[9:], nil
		default:
			if addInfo < 20 {
				return b[1:], nil
			}
			return b, &ErrUnsupportedType{}
		}
	}

	return b, &ErrUnsupportedType{}
}

// IsNil checks if the next value is nil
func IsNil(b []byte) bool {
	return len(b) > 0 && b[0] == makeByte(majorTypeSimple, simpleNull)
}

// Raw is raw CBOR data
type Raw []byte

// MarshalCBOR implements Marshaler
func (r Raw) MarshalCBOR(b []byte) ([]byte, error) {
	if len(r) == 0 {
		return AppendNil(b), nil
	}
	return append(b, r...), nil
}

// UnmarshalCBOR implements Unmarshaler

// Reader provides a minimal slice-based CBOR reader. It is intended
// for use by generated DecodeMsg implementations and operates on
// an in-memory buffer.

// NewReaderBytes constructs a Reader over the provided buffer.

// SetStrictDecode controls whether the reader should enforce canonical
// length encodings for containers (arrays, maps, strings, bytes).

// SetDeterministicDecode controls whether certain non-deterministic
// features such as indefinite-length containers are forbidden.

// SetMaxContainerLen configures an upper bound on container lengths
// (arrays, maps, byte strings, text strings). A value of zero disables
// the limit. When exceeded, ErrContainerTooLarge is returned.

// Remaining returns the unread portion of the underlying buffer.

// ReadArrayHeader reads an array header and advances the buffer.
// When strict decoding is enabled, non-canonical length encodings
// (i.e., using a larger integer encoding than necessary) will be
// rejected with ErrNonCanonicalLength.

// ReadArrayStart reads an array start and indicates whether it is
// indefinite-length. When deterministic decoding is enabled,
// indefinite-length arrays are rejected with ErrIndefiniteForbidden.

// ReadMapHeader reads a map header and advances the buffer.
// In strict mode, non-canonical length encodings are rejected.

// ReadString reads a text string and advances the buffer.
// In strict mode, non-canonical length encodings are rejected.
// In deterministic mode, indefinite-length strings are forbidden.

// ReadInt reads an int and advances the buffer.
// In strict mode, it enforces canonical integer encodings for both
// positive and negative values.

// ReadBytes reads a byte string and advances the buffer.

// Skip skips over the next CBOR item and advances the buffer.

// ReadBool reads a bool and advances the buffer.

// ReadInt64 reads an int64 and advances the buffer.
// In strict mode, it enforces canonical integer encodings for both
// positive and negative values.

// ReadUint reads a uint and advances the buffer.
// In strict mode, it enforces canonical unsigned integer encodings.

// ReadUint64 reads a uint64 and advances the buffer.
// In strict mode, it enforces canonical unsigned integer encodings.

// ReadFloat32 reads a float32 and advances the buffer.

// ReadFloat64 reads a float64 and advances the buffer.

// isNonCanonicalLength reports whether the leading header in b for the
// given major type uses a non-minimal integer encoding for its length
// according to RFC 8949 canonicalization rules.

// Canonicality applies to definite lengths; indefinite is
// handled separately by deterministic mode.

// Direct additional info encodes 0..23 canonically.

// Worst-case encoded sizes for common types. For variable-length types
// such as strings and byte slices, the total encoded size is the
// corresponding prefix size plus the length of the value.

// UnsafeString returns a string that shares the same underlying
// memory as b. It must only be used in Trusted decode paths where
// the backing buffer is immutable for the lifetime of the string.

// UnsafeBytes returns the string as a byte slice. It is
// equivalent to []byte(s) and retained for compatibility.

// isUTF8Valid validates UTF-8 for a byte slice. It can be overridden by
// architecture-specific, SIMD-accelerated implementations via build tags.

// ValidateWellFormedBytes validates that the next CBOR data item in b is well-formed per RFC 8949
// and returns the remaining bytes after that item.
// Checks performed:
// - Structural correctness of arrays, maps, tags, simple values
// - String UTF-8 validity (for major type 3)
// - Prohibits reserved additional info values 28,29,30

// ValidateDocument validates that all items in b are well-formed until input is exhausted.

// Reserved additional info values 28, 29, 30 are not well-formed

// indefinite bytes: series of definite byte strings terminated by break

// chunk must be bytes

// accumulate chunks and validate utf-8 progressively

// chunk must be text

// definite string

// key

// value

// key

// value

// one-byte simple value (0xf8 xx)

// unassigned simple values are still well-formed

// ensure 'sz' extra bytes in 'b' btw len(b) and cap(b)

// exponential growth

// appendUintCore encodes an unsigned integer with the given major type

// AppendMapHeader appends a map header with the given size

// AppendArrayHeader appends an array header with the given size

// AppendArrayHeaderIndefinite appends an indefinite-length array header (0x9f)

// AppendNil appends a nil value

// AppendUndefined appends an undefined simple value (23)

// AppendTextHeaderIndefinite appends an indefinite-length text string header (0x7f)

// AppendBytesHeaderIndefinite appends an indefinite-length byte string header (0x5f)

// AppendTextChunk appends a definite-length text string chunk (use within indefinite text)

// AppendBytesChunk appends a definite-length byte string chunk (use within indefinite bytes)

// AppendFloat64 appends a float64

// AppendFloat32 appends a float32

// AppendFloatCanonical appends the shortest-width float (f16/f32/f64) that preserves the value.

// Normalize -0 to +0 for canonical

// NaN: canonicalize to float16 NaN

// Try f16

// Try f32

// AppendFloat16 appends a float16 (IEEE 754 binary16) encoded value

// AppendFloat appends a float as float32 if it represents the same value, else float64

// AppendDuration appends a time.Duration as int64

// AppendInt64 appends an int64 using canonical CBOR integer encoding.
//
// For small values in the common ranges we specialize the encoding
// inline rather than routing through appendUintCore. This mirrors the
// fast-path treatment used in the original tinylib/msgp runtime while
// preserving CBOR's major-type and additional-info layout.

// Fast path for small positive values 0..23 (single-byte encoding).

// Fast path for small negative values -1..-24. CBOR encodes
// negative integers as -1-n with unsigned argument n.

// n such that value = -1-n

// Remaining positive values go through the generic uint encoder.

// AppendInt appends an int

// AppendInt8 appends an int8

// AppendInt16 appends an int16

// AppendInt32 appends an int32

// AppendUint64 appends a uint64

// AppendUint appends a uint

// AppendUint8 appends a uint8

// AppendUint16 appends a uint16

// AppendUint32 appends a uint32

// AppendBytes appends a byte string

// Compute header size and reserve in one shot to avoid double ensure + copy

// Write header

// Copy payload

// AppendString appends a text string

// Compute header size and reserve once

// Write header

// Copy payload

// AppendStringFromBytes appends a string from bytes

// AppendBool appends a bool

// AppendSimpleValue appends a generic simple value.
// Values 0..23 are encoded in the additional information;
// values 32..255 are encoded as 0xf8 XX.
// Note: 24..27 are reserved for float encodings and are not handled here.

// 0xf8

// AppendTime appends a time.Time as CBOR tag 1 (epoch timestamp)

// AppendTag appends a generic semantic tag

// AppendTagged appends a tag followed by a pre-encoded value

// AppendRFC3339Time appends a tag(0) RFC3339 datetime string

// AppendBase64URLString appends tag(33) with a base64url text string payload

// AppendBase64String appends tag(34) with a base64 text string payload

// AppendURI appends a tag(32) URI text string

// AppendEmbeddedCBOR appends tag(24) with a byte string containing embedded CBOR payload

// AppendUUID appends tag(37) with a 16-byte UUID (RFC 4122) as byte string

// AppendRegexpString appends tag(35) with a regular expression pattern as text

// AppendMIMEString appends tag(36) with a MIME message as text

// AppendSelfDescribeCBOR appends the self-describe CBOR tag (0xd9d9f7)

// AppendRegexp appends tag(35) from a compiled *regexp.Regexp

// AppendBigInt appends a big integer using bignum tags (2 positive, 3 negative)

// Negative: encode n = -1 - value
// -z
// -z - 1

// appendCBORIntegerFromBigInt encodes a big.Int as the shortest CBOR integer or bignum.

// AppendDecimalFraction appends tag(4) decimal fraction [exponent, mantissa]

// AppendBigfloat appends tag(5) bigfloat [exponent, mantissa]

// AppendBase64URL appends tag(21) with a byte string payload

// AppendBase64 appends tag(22) with a byte string payload

// AppendBase16 appends tag(23) with a byte string payload

// float32ToFloat16Bits converts float32 to IEEE 754 binary16 representation (round to nearest even)

// NaN or Inf

// Inf

// ensure NaN payload

// zero or subnormal in f32 => maps to zero in f16 or very small subnormals (flush to zero)
// Treat as subnormal; result rounds to 0 for f16 granularity

// Normalized number
// Unbias exponent: e32 = exp-127; target e16 = e32 + 15

// overflow => Inf

// subnormal or underflow
// subnormal half: significand = (mant | 1<<23) >> (1 - e16 + 13)
// shift = 14 - e32 = 14 - (exp-127) = 141 - exp

// too small => zero

// add rounding bias before shifting to 10 bits

// round to even

// normal half
// round mantissa from 23 to 10 bits

// mantissa overflow rounded up exponent
// carry into exponent

// AppendMapStrStr appends a map[string]string

// AppendMapStrInterface appends a map[string]any

// AppendStringSlice appends a []string as a CBOR array of text strings.

// AppendMapUint64Marshaler appends map[uint64]T to a CBOR map, where T has
// a corresponding Marshaler implementation (either as value or pointer).
// This is intended for generated code to avoid dynamic map handling in
// AppendInterface for map[uint64]*Struct shapes like ConsumerState.Pending.

// AppendMapUint64Uint64 appends a map[uint64]uint64 as a CBOR map with
// uint64 keys and values. This is used for ConsumerState.Redelivered and
// avoids reflection or interface-based encoding.

// AppendPtrMarshaler appends a pointer to a value that implements
// Marshaler. If the pointer is nil, a CBOR null is written. This is
// primarily for generated code (cborgen) to avoid the generic
// AppendInterface path for pointer-to-struct fields.

// AppendSliceMarshaler appends a slice of values that have a corresponding
// Marshaler implementation to a CBOR array. It is intended for use by
// generated code (cborgen) to avoid per-element AppendInterface overhead.
//
// T may be a type that itself implements Marshaler or whose pointer type
// implements Marshaler (the common case for generated methods).

// AppendInterface appends an arbitrary value

// Treat RawMessage as an opaque CBOR byte string.

// Fallback: handle slices and maps of Marshaler types via reflection.

// Encode the key according to its kind.

// Prefer Marshaler if available. For common generated
// patterns that use pointer receivers on value fields,
// synthesize a pointer and try that before falling back
// to AppendInterface.

// Try pointer to value type.

// AppendMapStrStrDeterministic appends a map[string]string with keys sorted by encoded key bytes.

// AppendMapStrInterfaceDeterministic appends a map[string]any with keys sorted by encoded key bytes.

// AppendMapHeaderIndefinite appends an indefinite-length map header (0xbf)

// AppendBreak appends a break stop code (0xff)

// AppendRawMapDeterministic appends a map with entries provided as raw CBOR key/value pairs.
// Pairs are sorted by CBOR-encoded key bytes to ensure RFC 8949 deterministic order.

// Deterministic order: by encoded key length, then bytewise lexicographic.

// Bucket indices by key length.

// Adaptive: comparator is faster for smaller groups/short keys.

// AppendMapDeterministic appends a map[K]V deterministically.
// encKey appends the CBOR encoding of key k to dst and returns the extended dst.
// encVal appends the CBOR encoding of value v to dst and returns the extended dst.
// Keys are encoded once for sorting and then reused to avoid re-encoding.

// Use a single growing scratch buffer to hold all encoded keys.
// This reduces per-key allocations. Each keyEnc stores a subslice
// of the scratch at the moment of encoding; later growth may reallocate
// scratch, but the subslices retain references to the older backing arrays.

// Bucket by encoded key length, then LSD radix within groups.

// Adaptive: comparator wins for small groups/short keys

// Common key encoders (for AppendMapDeterministic)

// Common value encoders (for AppendMapDeterministic)

// EncValInterface appends an arbitrary value.

// Typed deterministic appenders for common key/value types

// Writer provides a minimal CBOR writer backed by ByteBuffer.
// It is intended for use by generated EncodeMsg implementations.

// NewWriter constructs a Writer that appends to the provided ByteBuffer.

// Bytes returns the underlying encoded bytes.

// WriteMapHeader writes a map header with the given size.

// WriteString writes a text string value.

// WriteBool writes a bool value.

// WriteInt writes an int value.

// WriteInt64 writes an int64 value.

// WriteUint writes a uint value.

// WriteUint64 writes a uint64 value.

// WriteFloat32 writes a float32 value.

// WriteFloat64 writes a float64 value.

// WriteBytes writes a byte string value.

func (r *Raw) UnmarshalCBOR(b []byte) ([]byte, error) {
	l := len(b)
	out, err := Skip(b)
	if err != nil {
		return b, err
	}
	rlen := l - len(out)
	if IsNil(b[:rlen]) {
		rlen = 0
	}
	if cap(*r) < rlen {
		*r = make(Raw, rlen)
	} else {
		*r = (*r)[0:rlen]
	}
	copy(*r, b[:rlen])
	return out, nil
}

type Reader struct {
	buf           []byte
	strict        bool
	deterministic bool
	maxContainer  uint32
}

func NewReaderBytes(b []byte) *Reader { return &Reader{buf: b} }

func (r *Reader) SetStrictDecode(strict bool) { r.strict = strict }

func (r *Reader) SetDeterministicDecode(det bool) { r.deterministic = det }

func (r *Reader) SetMaxContainerLen(max uint32) { r.maxContainer = max }

func (r *Reader) Remaining() []byte { return r.buf }

func (r *Reader) ReadArrayHeader() (uint32, error) {
	if len(r.buf) < 1 {
		return 0, ErrShortBytes
	}
	if r.strict {
		nonCanon, err := isNonCanonicalArrayLength(r.buf)
		if err != nil {
			return 0, err
		}
		if nonCanon {
			return 0, ErrNonCanonicalLength
		}
	}
	sz, rest, err := ReadArrayHeaderBytes(r.buf)
	if err != nil {
		return 0, err
	}
	if r.maxContainer > 0 && sz > r.maxContainer {
		return 0, ErrContainerTooLarge
	}
	r.buf = rest
	return sz, nil
}

func (r *Reader) ReadArrayStart() (sz uint32, indefinite bool, err error) {
	sz, indef, rest, err := ReadArrayStartBytes(r.buf)
	if err != nil {
		return 0, false, err
	}
	if indef && r.deterministic {
		return 0, false, ErrIndefiniteForbidden
	}
	r.buf = rest
	return sz, indef, nil
}

func (r *Reader) ReadMapHeader() (uint32, error) {
	if len(r.buf) < 1 {
		return 0, ErrShortBytes
	}
	if r.strict {
		nonCanon, err := isNonCanonicalMapLength(r.buf)
		if err != nil {
			return 0, err
		}
		if nonCanon {
			return 0, ErrNonCanonicalLength
		}
	}
	sz, rest, err := ReadMapHeaderBytes(r.buf)
	if err != nil {
		return 0, err
	}
	if r.maxContainer > 0 && sz > r.maxContainer {
		return 0, ErrContainerTooLarge
	}
	r.buf = rest
	return sz, nil
}

func (r *Reader) ReadString() (string, error) {
	if len(r.buf) < 1 {
		return "", ErrShortBytes
	}
	if r.strict {
		nonCanon, err := isNonCanonicalTextLength(r.buf)
		if err != nil {
			return "", err
		}
		if nonCanon {
			return "", ErrNonCanonicalLength
		}
	}
	if r.deterministic && getMajorType(r.buf[0]) == majorTypeText && getAddInfo(r.buf[0]) == addInfoIndefinite {
		return "", ErrIndefiniteForbidden
	}
	s, rest, err := ReadStringBytes(r.buf)
	if err != nil {
		return "", err
	}
	r.buf = rest
	return s, nil
}

func (r *Reader) ReadInt() (int, error) {
	if len(r.buf) < 1 {
		return 0, ErrShortBytes
	}
	if r.strict {
		maj := getMajorType(r.buf[0])
		if maj == majorTypeUint || maj == majorTypeNegInt {
			nonCanon, err := isNonCanonicalLength(r.buf, maj)
			if err != nil {
				return 0, err
			}
			if nonCanon {
				return 0, ErrNonCanonicalLength
			}
		}
	}
	v, rest, err := ReadIntBytes(r.buf)
	if err != nil {
		return 0, err
	}
	r.buf = rest
	return v, nil
}

func (r *Reader) ReadBytes() ([]byte, error) {
	if len(r.buf) < 1 {
		return nil, ErrShortBytes
	}
	if r.strict {
		nonCanon, err := isNonCanonicalBytesLength(r.buf)
		if err != nil {
			return nil, err
		}
		if nonCanon {
			return nil, ErrNonCanonicalLength
		}
	}
	if r.deterministic && getMajorType(r.buf[0]) == majorTypeBytes && getAddInfo(r.buf[0]) == addInfoIndefinite {
		return nil, ErrIndefiniteForbidden
	}
	v, rest, err := ReadBytesBytes(r.buf, nil)
	if err != nil {
		return nil, err
	}
	r.buf = rest
	return v, nil
}

func (r *Reader) Skip() error {
	rest, err := Skip(r.buf)
	if err != nil {
		return err
	}
	r.buf = rest
	return nil
}

func (r *Reader) ReadBool() (bool, error) {
	v, rest, err := ReadBoolBytes(r.buf)
	if err != nil {
		return false, err
	}
	r.buf = rest
	return v, nil
}

func (r *Reader) ReadInt64() (int64, error) {
	if len(r.buf) < 1 {
		return 0, ErrShortBytes
	}
	if r.strict {
		maj := getMajorType(r.buf[0])
		if maj == majorTypeUint || maj == majorTypeNegInt {
			nonCanon, err := isNonCanonicalLength(r.buf, maj)
			if err != nil {
				return 0, err
			}
			if nonCanon {
				return 0, ErrNonCanonicalLength
			}
		}
	}
	v, rest, err := ReadInt64Bytes(r.buf)
	if err != nil {
		return 0, err
	}
	r.buf = rest
	return v, nil
}

func (r *Reader) ReadUint() (uint, error) {
	if len(r.buf) < 1 {
		return 0, ErrShortBytes
	}
	if r.strict && getMajorType(r.buf[0]) == majorTypeUint {
		nonCanon, err := isNonCanonicalLength(r.buf, majorTypeUint)
		if err != nil {
			return 0, err
		}
		if nonCanon {
			return 0, ErrNonCanonicalLength
		}
	}
	v, rest, err := ReadUintBytes(r.buf)
	if err != nil {
		return 0, err
	}
	r.buf = rest
	return v, nil
}

func (r *Reader) ReadUint64() (uint64, error) {
	if len(r.buf) < 1 {
		return 0, ErrShortBytes
	}
	if r.strict && getMajorType(r.buf[0]) == majorTypeUint {
		nonCanon, err := isNonCanonicalLength(r.buf, majorTypeUint)
		if err != nil {
			return 0, err
		}
		if nonCanon {
			return 0, ErrNonCanonicalLength
		}
	}
	v, rest, err := ReadUint64Bytes(r.buf)
	if err != nil {
		return 0, err
	}
	r.buf = rest
	return v, nil
}

func (r *Reader) ReadFloat32() (float32, error) {
	orig := r.buf
	v, rest, err := ReadFloat32Bytes(r.buf)
	if err != nil {
		return 0, err
	}
	if r.strict {
		canon := AppendFloatCanonical(nil, float64(v))
		encLen := len(orig) - len(rest)
		if encLen < 0 || encLen > len(orig) {
			return 0, ErrShortBytes
		}
		if len(canon) != encLen || !bytes.Equal(orig[:encLen], canon) {
			return 0, ErrNonCanonicalFloat
		}
	}
	r.buf = rest
	return v, nil
}

func (r *Reader) ReadFloat64() (float64, error) {
	orig := r.buf
	v, rest, err := ReadFloat64Bytes(r.buf)
	if err != nil {
		return 0, err
	}
	if r.strict {
		canon := AppendFloatCanonical(nil, v)
		encLen := len(orig) - len(rest)
		if encLen < 0 || encLen > len(orig) {
			return 0, ErrShortBytes
		}
		if len(canon) != encLen || !bytes.Equal(orig[:encLen], canon) {
			return 0, ErrNonCanonicalFloat
		}
	}
	r.buf = rest
	return v, nil
}

func isNonCanonicalLength(b []byte, expectedMajor uint8) (bool, error) {
	if len(b) < 1 {
		return false, ErrShortBytes
	}
	if getMajorType(b[0]) != expectedMajor {
		return false, badPrefix(getMajorType(b[0]), expectedMajor)
	}
	add := getAddInfo(b[0])
	switch add {
	case addInfoIndefinite:

		return false, nil
	case 0, 1, 2, 3, 4, 5, 6, 7,
		8, 9, 10, 11, 12, 13, 14, 15,
		16, 17, 18, 19, 20, 21, 22, 23:

		return false, nil
	case addInfoUint8:
		if len(b) < 2 {
			return false, ErrShortBytes
		}
		v := uint64(b[1])
		if v <= 23 {
			return true, nil
		}
		return false, nil
	case addInfoUint16:
		if len(b) < 3 {
			return false, ErrShortBytes
		}
		v := uint64(binary.BigEndian.Uint16(b[1:]))
		if v <= math.MaxUint8 {
			return true, nil
		}
		return false, nil
	case addInfoUint32:
		if len(b) < 5 {
			return false, ErrShortBytes
		}
		v := uint64(binary.BigEndian.Uint32(b[1:]))
		if v <= math.MaxUint16 {
			return true, nil
		}
		return false, nil
	case addInfoUint64:
		if len(b) < 9 {
			return false, ErrShortBytes
		}
		v := binary.BigEndian.Uint64(b[1:])
		if v <= math.MaxUint32 {
			return true, nil
		}
		return false, nil
	default:
		return false, &ErrUnsupportedType{}
	}
}

func isNonCanonicalArrayLength(b []byte) (bool, error) {
	return isNonCanonicalLength(b, majorTypeArray)
}
func isNonCanonicalMapLength(b []byte) (bool, error) { return isNonCanonicalLength(b, majorTypeMap) }
func isNonCanonicalBytesLength(b []byte) (bool, error) {
	return isNonCanonicalLength(b, majorTypeBytes)
}
func isNonCanonicalTextLength(b []byte) (bool, error) { return isNonCanonicalLength(b, majorTypeText) }

const (
	Int64Size           = 9
	IntSize             = Int64Size
	UintSize            = Int64Size
	Int8Size            = 2
	Int16Size           = 3
	Int32Size           = 5
	Uint8Size           = 2
	Uint16Size          = 3
	Uint32Size          = 5
	Uint64Size          = Int64Size
	Float64Size         = 9
	Float32Size         = 5
	DurationSize        = Int64Size
	TimeSize            = 15
	BoolSize            = 1
	NilSize             = 1
	MapHeaderSize       = 5
	ArrayHeaderSize     = 5
	BytesPrefixSize     = 5
	StringPrefixSize    = 5
	ExtensionPrefixSize = 6
)

func UnsafeString(b []byte) string {
	return *(*string)(unsafe.Pointer(&b))
}

func UnsafeBytes(s string) []byte { return []byte(s) }

var isUTF8Valid = func(b []byte) bool { return utf8.Valid(b) }

func ValidateWellFormedBytes(b []byte) (rest []byte, err error) {
	return validateWellFormed(b, 0)
}

func ValidateDocument(b []byte) error {
	var err error
	for len(b) > 0 {
		b, err = validateWellFormed(b, 0)
		if err != nil {
			return err
		}
	}
	return nil
}

func validateWellFormed(b []byte, depth int) ([]byte, error) {
	if depth > recursionLimit {
		return b, ErrMaxDepthExceeded
	}
	if len(b) < 1 {
		return b, ErrShortBytes
	}
	lead := b[0]
	major := getMajorType(lead)
	add := getAddInfo(lead)

	if add == 28 || add == 29 || add == 30 {
		return b, InvalidPrefixError{Want: major, Got: major}
	}

	switch major {
	case majorTypeUint, majorTypeNegInt, majorTypeTag:
		_, o, err := readUintCore(b, major)
		if err != nil {
			return b, err
		}
		if major == majorTypeTag {
			return validateWellFormed(o, depth+1)
		}
		return o, nil

	case majorTypeBytes:
		if add == addInfoIndefinite {

			p := b[1:]
			for {
				if len(p) < 1 {
					return b, ErrShortBytes
				}
				if p[0] == makeByte(majorTypeSimple, simpleBreak) {
					return p[1:], nil
				}

				sz, o, err := readUintCore(p, majorTypeBytes)
				if err != nil {
					return b, err
				}
				if uint64(len(o)) < sz {
					return b, ErrShortBytes
				}
				p = o[sz:]
			}
		}
		sz, o, err := readUintCore(b, majorTypeBytes)
		if err != nil {
			return b, err
		}
		if uint64(len(o)) < sz {
			return b, ErrShortBytes
		}
		return o[sz:], nil

	case majorTypeText:
		if add == addInfoIndefinite {
			p := b[1:]

			for {
				if len(p) < 1 {
					return b, ErrShortBytes
				}
				if p[0] == makeByte(majorTypeSimple, simpleBreak) {
					return p[1:], nil
				}

				chunk, o, err := ReadStringZC(p)
				if err != nil {
					return b, err
				}
				if !isUTF8Valid(chunk) {
					return b, ErrInvalidUTF8
				}
				p = o
			}
		}

		s, o, err := ReadStringZC(b)
		if err != nil {
			return b, err
		}
		if !isUTF8Valid(s) {
			return b, ErrInvalidUTF8
		}
		return o, nil

	case majorTypeArray:
		if add == addInfoIndefinite {
			p := b[1:]
			for {
				if len(p) < 1 {
					return b, ErrShortBytes
				}
				if p[0] == makeByte(majorTypeSimple, simpleBreak) {
					return p[1:], nil
				}
				var err error
				p, err = validateWellFormed(p, depth+1)
				if err != nil {
					return b, err
				}
			}
		}
		sz, p, err := readUintCore(b, majorTypeArray)
		if err != nil {
			return b, err
		}
		for i := uint64(0); i < sz; i++ {
			p, err = validateWellFormed(p, depth+1)
			if err != nil {
				return b, err
			}
		}
		return p, nil

	case majorTypeMap:
		if add == addInfoIndefinite {
			p := b[1:]
			for {
				if len(p) < 1 {
					return b, ErrShortBytes
				}
				if p[0] == makeByte(majorTypeSimple, simpleBreak) {
					return p[1:], nil
				}
				var err error
				p, err = validateWellFormed(p, depth+1)
				if err != nil {
					return b, err
				}
				p, err = validateWellFormed(p, depth+1)
				if err != nil {
					return b, err
				}
			}
		}
		sz, p, err := readUintCore(b, majorTypeMap)
		if err != nil {
			return b, err
		}
		for i := uint64(0); i < sz; i++ {
			p, err = validateWellFormed(p, depth+1)
			if err != nil {
				return b, err
			}
			p, err = validateWellFormed(p, depth+1)
			if err != nil {
				return b, err
			}
		}
		return p, nil

	case majorTypeSimple:
		switch add {
		case simpleFalse, simpleTrue, simpleNull, simpleUndefined:
			return b[1:], nil
		case simpleFloat16:
			if len(b) < 3 {
				return b, ErrShortBytes
			}
			return b[3:], nil
		case simpleFloat32:
			if len(b) < 5 {
				return b, ErrShortBytes
			}
			return b[5:], nil
		case simpleFloat64:
			if len(b) < 9 {
				return b, ErrShortBytes
			}
			return b[9:], nil
		case addInfoUint8:
			if len(b) < 2 {
				return b, ErrShortBytes
			}
			return b[2:], nil
		default:
			if add < 20 {
				return b[1:], nil
			}
			return b, &ErrUnsupportedType{}
		}
	}
	return b, &ErrUnsupportedType{}
}

func ensure(b []byte, sz int) ([]byte, int) {
	l := len(b)
	c := cap(b)
	if c-l < sz {
		o := make([]byte, (2*c)+sz)
		n := copy(o, b)
		return o[:n+sz], n
	}
	return b[:l+sz], l
}

func appendUintCore(b []byte, majorType uint8, u uint64) []byte {
	switch {
	case u <= addInfoDirect:
		return append(b, makeByte(majorType, uint8(u)))
	case u <= math.MaxUint8:
		o, n := ensure(b, 2)
		o[n] = makeByte(majorType, addInfoUint8)
		o[n+1] = uint8(u)
		return o
	case u <= math.MaxUint16:
		o, n := ensure(b, 3)
		o[n] = makeByte(majorType, addInfoUint16)
		binary.BigEndian.PutUint16(o[n+1:], uint16(u))
		return o
	case u <= math.MaxUint32:
		o, n := ensure(b, 5)
		o[n] = makeByte(majorType, addInfoUint32)
		binary.BigEndian.PutUint32(o[n+1:], uint32(u))
		return o
	default:
		o, n := ensure(b, 9)
		o[n] = makeByte(majorType, addInfoUint64)
		binary.BigEndian.PutUint64(o[n+1:], u)
		return o
	}
}

func AppendMapHeader(b []byte, sz uint32) []byte {
	return appendUintCore(b, majorTypeMap, uint64(sz))
}

func AppendArrayHeader(b []byte, sz uint32) []byte {
	return appendUintCore(b, majorTypeArray, uint64(sz))
}

func AppendArrayHeaderIndefinite(b []byte) []byte {
	return append(b, makeByte(majorTypeArray, addInfoIndefinite))
}

func AppendNil(b []byte) []byte {
	return append(b, makeByte(majorTypeSimple, simpleNull))
}

func AppendUndefined(b []byte) []byte {
	return append(b, makeByte(majorTypeSimple, simpleUndefined))
}

func AppendTextHeaderIndefinite(b []byte) []byte {
	return append(b, makeByte(majorTypeText, addInfoIndefinite))
}

func AppendBytesHeaderIndefinite(b []byte) []byte {
	return append(b, makeByte(majorTypeBytes, addInfoIndefinite))
}

func AppendTextChunk(b []byte, s string) []byte { return AppendString(b, s) }

func AppendBytesChunk(b []byte, bs []byte) []byte { return AppendBytes(b, bs) }

func AppendFloat64(b []byte, f float64) []byte {
	o, n := ensure(b, 9)
	o[n] = makeByte(majorTypeSimple, simpleFloat64)
	binary.BigEndian.PutUint64(o[n+1:], math.Float64bits(f))
	return o
}

func AppendFloat32(b []byte, f float32) []byte {
	o, n := ensure(b, 5)
	o[n] = makeByte(majorTypeSimple, simpleFloat32)
	binary.BigEndian.PutUint32(o[n+1:], math.Float32bits(f))
	return o
}

func AppendFloatCanonical(b []byte, f float64) []byte {

	if f == 0 && math.Signbit(f) {
		f = 0
	}

	if math.IsNaN(f) {
		return AppendFloat16(b, float32(f))
	}

	f16 := float32ToFloat16Bits(float32(f))
	if float64(float16BitsToFloat32(f16)) == f {
		return AppendFloat16(b, float32(f))
	}

	f32 := float32(f)
	if float64(f32) == f {
		return AppendFloat32(b, f32)
	}
	return AppendFloat64(b, f)
}

func AppendFloat16(b []byte, f float32) []byte {
	o, n := ensure(b, 3)
	o[n] = makeByte(majorTypeSimple, simpleFloat16)
	binary.BigEndian.PutUint16(o[n+1:], float32ToFloat16Bits(f))
	return o
}

func AppendFloat(b []byte, f float64) []byte {
	f32 := float32(f)
	if float64(f32) == f {
		return AppendFloat32(b, f32)
	}
	return AppendFloat64(b, f)
}

func AppendDuration(b []byte, d time.Duration) []byte {
	return AppendInt64(b, int64(d))
}

func AppendInt64(b []byte, i int64) []byte {

	if i >= 0 && i <= addInfoDirect {
		return append(b, makeByte(majorTypeUint, uint8(i)))
	}

	if i < 0 {
		neg := -1 - i
		if neg >= 0 && neg <= addInfoDirect {
			return append(b, makeByte(majorTypeNegInt, uint8(neg)))
		}
		return appendUintCore(b, majorTypeNegInt, uint64(neg))
	}

	return appendUintCore(b, majorTypeUint, uint64(i))
}

func AppendInt(b []byte, i int) []byte {
	return AppendInt64(b, int64(i))
}

func AppendInt8(b []byte, i int8) []byte {
	return AppendInt64(b, int64(i))
}

func AppendInt16(b []byte, i int16) []byte {
	return AppendInt64(b, int64(i))
}

func AppendInt32(b []byte, i int32) []byte {
	return AppendInt64(b, int64(i))
}

func AppendUint64(b []byte, u uint64) []byte {
	return appendUintCore(b, majorTypeUint, u)
}

func AppendUint(b []byte, u uint) []byte {
	return AppendUint64(b, uint64(u))
}

func AppendUint8(b []byte, u uint8) []byte {
	return appendUintCore(b, majorTypeUint, uint64(u))
}

func AppendUint16(b []byte, u uint16) []byte {
	return appendUintCore(b, majorTypeUint, uint64(u))
}

func AppendUint32(b []byte, u uint32) []byte {
	return appendUintCore(b, majorTypeUint, uint64(u))
}

func AppendBytes(b []byte, data []byte) []byte {
	sz := uint64(len(data))

	var h int
	switch {
	case sz <= addInfoDirect:
		h = 1
	case sz <= math.MaxUint8:
		h = 2
	case sz <= math.MaxUint16:
		h = 3
	case sz <= math.MaxUint32:
		h = 5
	default:
		h = 9
	}
	o, n := ensure(b, h+int(sz))

	switch h {
	case 1:
		o[n] = makeByte(majorTypeBytes, uint8(sz))
		n++
	case 2:
		o[n] = makeByte(majorTypeBytes, addInfoUint8)
		o[n+1] = uint8(sz)
		n += 2
	case 3:
		o[n] = makeByte(majorTypeBytes, addInfoUint16)
		binary.BigEndian.PutUint16(o[n+1:], uint16(sz))
		n += 3
	case 5:
		o[n] = makeByte(majorTypeBytes, addInfoUint32)
		binary.BigEndian.PutUint32(o[n+1:], uint32(sz))
		n += 5
	case 9:
		o[n] = makeByte(majorTypeBytes, addInfoUint64)
		binary.BigEndian.PutUint64(o[n+1:], sz)
		n += 9
	}

	copy(o[n:], data)
	return o[:n+int(sz)]
}

func AppendString(b []byte, s string) []byte {
	sz := uint64(len(s))

	var h int
	switch {
	case sz <= addInfoDirect:
		h = 1
	case sz <= math.MaxUint8:
		h = 2
	case sz <= math.MaxUint16:
		h = 3
	case sz <= math.MaxUint32:
		h = 5
	default:
		h = 9
	}
	o, n := ensure(b, h+int(sz))

	switch h {
	case 1:
		o[n] = makeByte(majorTypeText, uint8(sz))
		n++
	case 2:
		o[n] = makeByte(majorTypeText, addInfoUint8)
		o[n+1] = uint8(sz)
		n += 2
	case 3:
		o[n] = makeByte(majorTypeText, addInfoUint16)
		binary.BigEndian.PutUint16(o[n+1:], uint16(sz))
		n += 3
	case 5:
		o[n] = makeByte(majorTypeText, addInfoUint32)
		binary.BigEndian.PutUint32(o[n+1:], uint32(sz))
		n += 5
	case 9:
		o[n] = makeByte(majorTypeText, addInfoUint64)
		binary.BigEndian.PutUint64(o[n+1:], sz)
		n += 9
	}

	copy(o[n:], s)
	return o[:n+int(sz)]
}

func AppendStringFromBytes(b []byte, data []byte) []byte {
	sz := uint64(len(data))
	b = appendUintCore(b, majorTypeText, sz)
	return append(b, data...)
}

func AppendBool(b []byte, val bool) []byte {
	if val {
		return append(b, makeByte(majorTypeSimple, simpleTrue))
	}
	return append(b, makeByte(majorTypeSimple, simpleFalse))
}

func AppendSimpleValue(b []byte, val uint8) []byte {
	switch {
	case val <= addInfoDirect:
		return append(b, makeByte(majorTypeSimple, val))
	default:
		o, n := ensure(b, 2)
		o[n] = makeByte(majorTypeSimple, addInfoUint8)
		o[n+1] = val
		return o
	}
}

func AppendTime(b []byte, t time.Time) []byte {
	b = AppendTag(b, tagEpochDateTime)
	sec := t.Unix()
	nsec := t.Nanosecond()
	if nsec == 0 {
		return AppendInt64(b, sec)
	}
	f := float64(sec) + float64(nsec)/1e9
	return AppendFloat64(b, f)
}

func AppendTag(b []byte, tag uint64) []byte {
	return appendUintCore(b, majorTypeTag, tag)
}

func AppendTagged(b []byte, tag uint64, value []byte) []byte {
	b = AppendTag(b, tag)
	return append(b, value...)
}

func AppendRFC3339Time(b []byte, t time.Time) []byte {
	b = AppendTag(b, tagDateTimeString)
	return AppendString(b, t.Format(time.RFC3339Nano))
}

func AppendBase64URLString(b []byte, s string) []byte {
	b = AppendTag(b, tagBase64URLString)
	return AppendString(b, s)
}

func AppendBase64String(b []byte, s string) []byte {
	b = AppendTag(b, tagBase64String)
	return AppendString(b, s)
}

func AppendURI(b []byte, uri string) []byte {
	b = AppendTag(b, tagURI)
	return AppendString(b, uri)
}

func AppendEmbeddedCBOR(b []byte, payload []byte) []byte {
	b = AppendTag(b, tagCBOR)
	return AppendBytes(b, payload)
}

func AppendUUID(b []byte, uuid [16]byte) []byte {
	b = AppendTag(b, 37)
	return AppendBytes(b, uuid[:])
}

func AppendRegexpString(b []byte, re string) []byte {
	b = AppendTag(b, tagRegexp)
	return AppendString(b, re)
}

func AppendMIMEString(b []byte, mime string) []byte {
	b = AppendTag(b, tagMIME)
	return AppendString(b, mime)
}

func AppendSelfDescribeCBOR(b []byte) []byte {
	return appendUintCore(b, majorTypeTag, tagSelfDescribeCBOR)
}

func AppendRegexp(b []byte, re *regexp.Regexp) []byte {
	if re == nil {
		return AppendNil(b)
	}
	return AppendRegexpString(b, re.String())
}

func AppendBigInt(b []byte, z *bigmath.Int) []byte {
	if z == nil {
		return AppendNil(b)
	}
	if z.Sign() >= 0 {
		b = AppendTag(b, tagPosBignum)
		return AppendBytes(b, z.Bytes())
	}

	tmp := new(bigmath.Int).Neg(z)
	tmp.Sub(tmp, bigmath.NewInt(1))
	b = AppendTag(b, tagNegBignum)
	return AppendBytes(b, tmp.Bytes())
}

func appendCBORIntegerFromBigInt(b []byte, z *bigmath.Int) []byte {
	if z == nil {
		return AppendNil(b)
	}
	if z.Sign() >= 0 && z.BitLen() <= 64 {
		return AppendUint64(b, z.Uint64())
	}
	if z.Sign() < 0 && z.BitLen() <= 63 {
		return AppendInt64(b, z.Int64())
	}
	return AppendBigInt(b, z)
}

func AppendDecimalFraction(b []byte, exponent int64, mantissa *bigmath.Int) []byte {
	b = AppendTag(b, tagDecimalFrac)
	b = AppendArrayHeader(b, 2)
	b = AppendInt64(b, exponent)
	b = appendCBORIntegerFromBigInt(b, mantissa)
	return b
}

func AppendBigfloat(b []byte, exponent int64, mantissa *bigmath.Int) []byte {
	b = AppendTag(b, tagBigfloat)
	b = AppendArrayHeader(b, 2)
	b = AppendInt64(b, exponent)
	b = appendCBORIntegerFromBigInt(b, mantissa)
	return b
}

func AppendBase64URL(b []byte, data []byte) []byte {
	b = AppendTag(b, tagBase64URL)
	return AppendBytes(b, data)
}

func AppendBase64(b []byte, data []byte) []byte {
	b = AppendTag(b, tagBase64)
	return AppendBytes(b, data)
}

func AppendBase16(b []byte, data []byte) []byte {
	b = AppendTag(b, tagBase16)
	return AppendBytes(b, data)
}

func float32ToFloat16Bits(f float32) uint16 {
	bits := math.Float32bits(f)
	sign := uint16((bits >> 31) & 0x1)
	exp := int((bits >> 23) & 0xFF)
	mant := bits & 0x7FFFFF

	var h uint16
	switch exp {
	case 0xFF:
		if mant == 0 {
			h = (0x1F << 10)
		} else {
			h = (0x1F << 10) | uint16(mant>>13)
			if h&0x03FF == 0 {
				h |= 1
			}
		}
	case 0:

		h = 0
	default:

		e32 := exp - 127
		e16 := e32 + 15
		if e16 >= 0x1F {
			h = (0x1F << 10)
		} else if e16 <= 0 {

			shift := 14 - e32
			if shift > 24 {
				h = 0
			} else {
				mantissa := (mant | 1<<23)

				round := uint32(1) << (shift - 1)
				val := uint32(mantissa)
				val += round - 1 + ((val >> (shift)) & 1)
				frac := uint16(val >> shift)
				h = frac & 0x03FF
			}
		} else {

			mantR := mant
			round := uint32(1) << 12
			val := mantR + round - 1 + ((mantR >> 13) & 1)
			frac := uint16(val >> 13)
			h = (uint16(e16) << 10) | (frac & 0x03FF)
			if frac>>10 != 0 {

				e16++
				if e16 >= 0x1F {
					h = (0x1F << 10)
				} else {
					h = (uint16(e16) << 10)
				}
			}
		}
	}
	return (sign << 15) | h
}

func AppendMapStrStr(b []byte, m map[string]string) []byte {
	sz := uint32(len(m))
	b = AppendMapHeader(b, sz)
	for key, val := range m {
		b = AppendString(b, key)
		b = AppendString(b, val)
	}
	return b
}

func AppendMapStrInterface(b []byte, m map[string]any) ([]byte, error) {
	sz := uint32(len(m))
	b = AppendMapHeader(b, sz)
	for key, val := range m {
		b = AppendString(b, key)
		var err error
		b, err = AppendInterface(b, val)
		if err != nil {
			return b, err
		}
	}
	return b, nil
}

func AppendStringSlice(b []byte, v []string) []byte {
	b = AppendArrayHeader(b, uint32(len(v)))
	for _, s := range v {
		b = AppendString(b, s)
	}
	return b
}

func AppendMapUint64Marshaler[T any](b []byte, m map[uint64]T) ([]byte, error) {
	b = AppendMapHeader(b, uint32(len(m)))
	var err error
	for k, v := range m {
		b = AppendUint64(b, k)
		var mval Marshaler
		if mm, ok := any(v).(Marshaler); ok {
			mval = mm
		} else if mm, ok := any(&v).(Marshaler); ok {
			mval = mm
		} else {
			return b, &ErrUnsupportedType{}
		}
		b, err = mval.MarshalCBOR(b)
		if err != nil {
			return b, err
		}
	}
	return b, nil
}

func AppendMapUint64Uint64(b []byte, m map[uint64]uint64) []byte {
	b = AppendMapHeader(b, uint32(len(m)))
	for k, v := range m {
		b = AppendUint64(b, k)
		b = AppendUint64(b, v)
	}
	return b
}

func AppendPtrMarshaler[T any](b []byte, v *T) ([]byte, error) {
	if v == nil {
		return AppendNil(b), nil
	}
	if m, ok := any(v).(Marshaler); ok {
		return m.MarshalCBOR(b)
	}
	return b, &ErrUnsupportedType{}
}

func AppendSliceMarshaler[T any](b []byte, v []T) ([]byte, error) {
	b = AppendArrayHeader(b, uint32(len(v)))
	var err error
	for i := range v {
		var m Marshaler
		if mm, ok := any(v[i]).(Marshaler); ok {
			m = mm
		} else if mm, ok := any(&v[i]).(Marshaler); ok {
			m = mm
		} else {
			return b, &ErrUnsupportedType{}
		}
		b, err = m.MarshalCBOR(b)
		if err != nil {
			return b, err
		}
	}
	return b, nil
}

func AppendInterface(b []byte, i any) ([]byte, error) {
	if i == nil {
		return AppendNil(b), nil
	}

	switch v := i.(type) {
	case Marshaler:
		return v.MarshalCBOR(b)
	case string:
		return AppendString(b, v), nil
	case bool:
		return AppendBool(b, v), nil
	case int:
		return AppendInt(b, v), nil
	case int8:
		return AppendInt8(b, v), nil
	case int16:
		return AppendInt16(b, v), nil
	case int32:
		return AppendInt32(b, v), nil
	case int64:
		return AppendInt64(b, v), nil
	case uint:
		return AppendUint(b, v), nil
	case uint8:
		return AppendUint8(b, v), nil
	case uint16:
		return AppendUint16(b, v), nil
	case uint32:
		return AppendUint32(b, v), nil
	case uint64:
		return AppendUint64(b, v), nil
	case float32:
		return AppendFloat32(b, v), nil
	case float64:
		return AppendFloat64(b, v), nil
	case []byte:
		return AppendBytes(b, v), nil
	case time.Time:
		return AppendTime(b, v), nil
	case time.Duration:
		return AppendDuration(b, v), nil
	case []int:
		b = AppendArrayHeader(b, uint32(len(v)))
		for _, elem := range v {
			b = AppendInt(b, elem)
		}
		return b, nil
	case []int8:
		b = AppendArrayHeader(b, uint32(len(v)))
		for _, elem := range v {
			b = AppendInt8(b, elem)
		}
		return b, nil
	case []int16:
		b = AppendArrayHeader(b, uint32(len(v)))
		for _, elem := range v {
			b = AppendInt16(b, elem)
		}
		return b, nil
	case []int32:
		b = AppendArrayHeader(b, uint32(len(v)))
		for _, elem := range v {
			b = AppendInt32(b, elem)
		}
		return b, nil
	case []int64:
		b = AppendArrayHeader(b, uint32(len(v)))
		for _, elem := range v {
			b = AppendInt64(b, elem)
		}
		return b, nil
	case []uint:
		b = AppendArrayHeader(b, uint32(len(v)))
		for _, elem := range v {
			b = AppendUint(b, elem)
		}
		return b, nil
	case []uint16:
		b = AppendArrayHeader(b, uint32(len(v)))
		for _, elem := range v {
			b = AppendUint16(b, elem)
		}
		return b, nil
	case []uint32:
		b = AppendArrayHeader(b, uint32(len(v)))
		for _, elem := range v {
			b = AppendUint32(b, elem)
		}
		return b, nil
	case []uint64:
		b = AppendArrayHeader(b, uint32(len(v)))
		for _, elem := range v {
			b = AppendUint64(b, elem)
		}
		return b, nil
	case []float32:
		b = AppendArrayHeader(b, uint32(len(v)))
		for _, elem := range v {
			b = AppendFloat32(b, elem)
		}
		return b, nil
	case []float64:
		b = AppendArrayHeader(b, uint32(len(v)))
		for _, elem := range v {
			b = AppendFloat64(b, elem)
		}
		return b, nil
	case []string:
		b = AppendArrayHeader(b, uint32(len(v)))
		for _, elem := range v {
			b = AppendString(b, elem)
		}
		return b, nil
	case map[string]int:
		b = AppendMapHeader(b, uint32(len(v)))
		for k, val := range v {
			b = AppendString(b, k)
			b = AppendInt(b, val)
		}
		return b, nil
	case map[string]int64:
		b = AppendMapHeader(b, uint32(len(v)))
		for k, val := range v {
			b = AppendString(b, k)
			b = AppendInt64(b, val)
		}
		return b, nil
	case map[string]uint:
		b = AppendMapHeader(b, uint32(len(v)))
		for k, val := range v {
			b = AppendString(b, k)
			b = AppendUint(b, val)
		}
		return b, nil
	case map[string]uint64:
		b = AppendMapHeader(b, uint32(len(v)))
		for k, val := range v {
			b = AppendString(b, k)
			b = AppendUint64(b, val)
		}
		return b, nil
	case map[string]float64:
		b = AppendMapHeader(b, uint32(len(v)))
		for k, val := range v {
			b = AppendString(b, k)
			b = AppendFloat64(b, val)
		}
		return b, nil
	case map[string]string:
		b = AppendMapHeader(b, uint32(len(v)))
		for k, val := range v {
			b = AppendString(b, k)
			b = AppendString(b, val)
		}
		return b, nil
	case json.RawMessage:

		return AppendBytes(b, []byte(v)), nil
	case json.Number:
		if iv, err := v.Int64(); err == nil {
			return AppendInt64(b, iv), nil
		}
		if fv, err := v.Float64(); err == nil {
			return AppendFloat64(b, fv), nil
		}
		return b, &ErrUnsupportedType{}
	case map[string]any:
		return AppendMapStrInterface(b, v)
	case []any:
		b = AppendArrayHeader(b, uint32(len(v)))
		var err error
		for _, elem := range v {
			b, err = AppendInterface(b, elem)
			if err != nil {
				return b, err
			}
		}
		return b, nil
	default:

		rv := reflect.ValueOf(i)
		t := rv.Type()
		if rv.Kind() == reflect.Slice {
			b = AppendArrayHeader(b, uint32(rv.Len()))
			for idx := 0; idx < rv.Len(); idx++ {
				val := rv.Index(idx)
				elem := val.Interface()
				m, ok := elem.(Marshaler)
				if !ok && val.CanAddr() {
					m, ok = val.Addr().Interface().(Marshaler)
				}
				if !ok {
					return b, &ErrUnsupportedType{}
				}
				var err error
				b, err = m.MarshalCBOR(b)
				if err != nil {
					return b, err
				}
			}
			return b, nil
		}
		if rv.Kind() == reflect.Map {
			keyKind := t.Key().Kind()
			keys := rv.MapKeys()
			b = AppendMapHeader(b, uint32(len(keys)))
			for _, k := range keys {

				switch keyKind {
				case reflect.String:
					b = AppendString(b, k.String())
				case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
					b = AppendUint64(b, k.Uint())
				case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
					b = AppendInt64(b, k.Int())
				default:
					return b, &ErrUnsupportedType{}
				}

				mv := rv.MapIndex(k)
				val := mv.Interface()

				if m, ok := val.(Marshaler); ok {
					var err error
					b, err = m.MarshalCBOR(b)
					if err != nil {
						return b, err
					}
				} else {

					ptr := reflect.New(mv.Type())
					ptr.Elem().Set(mv)
					if m, ok := ptr.Interface().(Marshaler); ok {
						var err error
						b, err = m.MarshalCBOR(b)
						if err != nil {
							return b, err
						}
						continue
					}

					var err error
					b, err = AppendInterface(b, val)
					if err != nil {
						return b, err
					}
				}
			}
			return b, nil
		}
		return b, &ErrUnsupportedType{}
	}
}

func AppendMapStrStrDeterministic(b []byte, m map[string]string) []byte {
	sz := uint32(len(m))
	b = AppendMapHeader(b, sz)
	type kv struct {
		key string
		enc []byte
	}
	arr := make([]kv, 0, len(m))
	for k := range m {
		arr = append(arr, kv{key: k, enc: AppendString(nil, k)})
	}
	sort.Slice(arr, func(i, j int) bool { return bytes.Compare(arr[i].enc, arr[j].enc) < 0 })
	for _, it := range arr {
		b = AppendString(b, it.key)
		b = AppendString(b, m[it.key])
	}
	return b
}

func AppendMapStrInterfaceDeterministic(b []byte, m map[string]any) ([]byte, error) {
	sz := uint32(len(m))
	b = AppendMapHeader(b, sz)
	type kv struct {
		key string
		enc []byte
	}
	arr := make([]kv, 0, len(m))
	for k := range m {
		arr = append(arr, kv{key: k, enc: AppendString(nil, k)})
	}
	sort.Slice(arr, func(i, j int) bool { return bytes.Compare(arr[i].enc, arr[j].enc) < 0 })
	for _, it := range arr {
		b = AppendString(b, it.key)
		var err error
		b, err = AppendInterface(b, m[it.key])
		if err != nil {
			return b, err
		}
	}
	return b, nil
}

func AppendMapHeaderIndefinite(b []byte) []byte {
	return append(b, makeByte(majorTypeMap, addInfoIndefinite))
}

func AppendBreak(b []byte) []byte {
	return append(b, makeByte(majorTypeSimple, simpleBreak))
}

func AppendRawMapDeterministic(b []byte, pairs []RawPair) []byte {

	n := len(pairs)
	if n == 0 {
		return AppendMapHeader(b, 0)
	}

	byLen := make(map[int][]int)
	for i := 0; i < n; i++ {
		l := len(pairs[i].Key)
		byLen[l] = append(byLen[l], i)
	}
	lens := make([]int, 0, len(byLen))
	for l := range byLen {
		lens = append(lens, l)
	}
	sort.Ints(lens)
	order := make([]int, 0, n)
	counts := make([]int, 256)
	var tmp []int
	for _, l := range lens {
		grp := byLen[l]
		if len(grp) <= 1 {
			order = append(order, grp...)
			continue
		}

		if l < 64 && len(grp) < 1024 {
			sort.Slice(grp, func(i, j int) bool { return bytes.Compare(pairs[grp[i]].Key, pairs[grp[j]].Key) < 0 })
			order = append(order, grp...)
			continue
		}
		if cap(tmp) < len(grp) {
			tmp = make([]int, len(grp))
		} else {
			tmp = tmp[:len(grp)]
		}
		cur := grp
		aux := tmp
		for pos := l - 1; pos >= 0; pos-- {
			for i := range counts {
				counts[i] = 0
			}
			for _, idx := range cur {
				counts[int(pairs[idx].Key[pos])]++
			}
			sum := 0
			for i := 0; i < 256; i++ {
				c := counts[i]
				counts[i] = sum
				sum += c
			}
			for _, idx := range cur {
				bv := pairs[idx].Key[pos]
				p := counts[int(bv)]
				aux[p] = idx
				counts[int(bv)] = p + 1
			}
			cur, aux = aux, cur
		}
		order = append(order, cur...)
	}
	b = AppendMapHeader(b, uint32(n))
	for _, i := range order {
		b = append(b, pairs[i].Key...)
		b = append(b, pairs[i].Value...)
	}
	return b
}

func AppendMapDeterministic[K comparable, V any](b []byte, m map[K]V,
	encKey func(dst []byte, k K) []byte,
	encVal func(dst []byte, v V) ([]byte, error),
) ([]byte, error) {
	type item struct {
		keyEnc []byte
		key    K
		val    V
	}
	items := make([]item, 0, len(m))

	var scratch []byte
	for k, v := range m {
		prev := len(scratch)
		scratch = encKey(scratch, k)
		ke := scratch[prev:]
		items = append(items, item{keyEnc: ke, key: k, val: v})
	}

	byLen := make(map[int][]int)
	for i := range items {
		byLen[len(items[i].keyEnc)] = append(byLen[len(items[i].keyEnc)], i)
	}
	lens := make([]int, 0, len(byLen))
	for l := range byLen {
		lens = append(lens, l)
	}
	sort.Ints(lens)
	order := make([]int, 0, len(items))
	counts := make([]int, 256)
	var tmpIdx []int
	for _, l := range lens {
		grp := byLen[l]
		if len(grp) <= 1 {
			order = append(order, grp...)
			continue
		}

		if l < 64 && len(grp) < 1024 {
			sort.Slice(grp, func(i, j int) bool { return bytes.Compare(items[grp[i]].keyEnc, items[grp[j]].keyEnc) < 0 })
			order = append(order, grp...)
			continue
		}
		if cap(tmpIdx) < len(grp) {
			tmpIdx = make([]int, len(grp))
		} else {
			tmpIdx = tmpIdx[:len(grp)]
		}
		cur := grp
		aux := tmpIdx
		for pos := l - 1; pos >= 0; pos-- {
			for i := range counts {
				counts[i] = 0
			}
			for _, idx := range cur {
				counts[int(items[idx].keyEnc[pos])]++
			}
			sum := 0
			for i := 0; i < 256; i++ {
				c := counts[i]
				counts[i] = sum
				sum += c
			}
			for _, idx := range cur {
				bv := items[idx].keyEnc[pos]
				p := counts[int(bv)]
				aux[p] = idx
				counts[int(bv)] = p + 1
			}
			cur, aux = aux, cur
		}
		order = append(order, cur...)
	}
	b = AppendMapHeader(b, uint32(len(items)))
	var err error
	for _, oi := range order {
		b = append(b, items[oi].keyEnc...)
		b, err = encVal(b, items[oi].val)
		if err != nil {
			return b, err
		}
	}
	return b, nil
}

func EncKeyString(dst []byte, s string) []byte   { return AppendString(dst, s) }
func EncKeyBytes(dst []byte, bs []byte) []byte   { return AppendBytes(dst, bs) }
func EncKeyInt(dst []byte, i int) []byte         { return AppendInt(dst, i) }
func EncKeyInt64(dst []byte, i int64) []byte     { return AppendInt64(dst, i) }
func EncKeyUint64(dst []byte, u uint64) []byte   { return AppendUint64(dst, u) }
func EncKeyBool(dst []byte, v bool) []byte       { return AppendBool(dst, v) }
func EncKeyFloat64(dst []byte, f float64) []byte { return AppendFloat64(dst, f) }
func EncKeyTime(dst []byte, t time.Time) []byte  { return AppendTime(dst, t) }

func EncValString(dst []byte, s string) ([]byte, error)   { return AppendString(dst, s), nil }
func EncValBytes(dst []byte, bs []byte) ([]byte, error)   { return AppendBytes(dst, bs), nil }
func EncValInt(dst []byte, i int) ([]byte, error)         { return AppendInt(dst, i), nil }
func EncValInt64(dst []byte, i int64) ([]byte, error)     { return AppendInt64(dst, i), nil }
func EncValUint64(dst []byte, u uint64) ([]byte, error)   { return AppendUint64(dst, u), nil }
func EncValBool(dst []byte, v bool) ([]byte, error)       { return AppendBool(dst, v), nil }
func EncValFloat64(dst []byte, f float64) ([]byte, error) { return AppendFloat64(dst, f), nil }
func EncValFloat32(dst []byte, f float32) ([]byte, error) { return AppendFloat32(dst, f), nil }
func EncValTime(dst []byte, t time.Time) ([]byte, error)  { return AppendTime(dst, t), nil }

func EncValInterface(dst []byte, v any) ([]byte, error) { return AppendInterface(dst, v) }

func AppendMapDeterministicStrStr(b []byte, m map[string]string) []byte {
	out, _ := AppendMapDeterministic(b, m, EncKeyString, EncValString)
	return out
}

func AppendMapDeterministicStrInt64(b []byte, m map[string]int64) []byte {
	out, _ := AppendMapDeterministic(b, m, EncKeyString, EncValInt64)
	return out
}

func AppendMapDeterministicStrInt(b []byte, m map[string]int) []byte {
	out, _ := AppendMapDeterministic(b, m, EncKeyString, EncValInt)
	return out
}

func AppendMapDeterministicStrUint64(b []byte, m map[string]uint64) []byte {
	out, _ := AppendMapDeterministic(b, m, EncKeyString, EncValUint64)
	return out
}

func AppendMapDeterministicStrBool(b []byte, m map[string]bool) []byte {
	out, _ := AppendMapDeterministic(b, m, EncKeyString, EncValBool)
	return out
}

func AppendMapDeterministicStrFloat64(b []byte, m map[string]float64) []byte {
	out, _ := AppendMapDeterministic(b, m, EncKeyString, EncValFloat64)
	return out
}

func AppendMapDeterministicStrBytes(b []byte, m map[string][]byte) []byte {
	out, _ := AppendMapDeterministic(b, m, EncKeyString, EncValBytes)
	return out
}

func AppendMapDeterministicStrInterface(b []byte, m map[string]any) ([]byte, error) {
	return AppendMapDeterministic(b, m, EncKeyString, EncValInterface)
}

type Writer struct {
	bb *ByteBuffer
}

func NewWriter(bb *ByteBuffer) *Writer { return &Writer{bb: bb} }

func (w *Writer) Bytes() []byte { return w.bb.Bytes() }

func (w *Writer) WriteMapHeader(sz uint32) error {
	w.bb.AppendMapHeader(sz)
	return nil
}

func (w *Writer) WriteString(s string) error {
	w.bb.AppendString(s)
	return nil
}

func (w *Writer) WriteBool(v bool) error {
	w.bb.AppendBool(v)
	return nil
}

func (w *Writer) WriteInt(v int) error {
	w.bb.AppendInt64(int64(v))
	return nil
}

func (w *Writer) WriteInt64(v int64) error {
	w.bb.AppendInt64(v)
	return nil
}

func (w *Writer) WriteUint(v uint) error {
	w.bb.AppendUint64(uint64(v))
	return nil
}

func (w *Writer) WriteUint64(v uint64) error {
	w.bb.AppendUint64(v)
	return nil
}

func (w *Writer) WriteFloat32(v float32) error {
	w.bb.AppendFloat32(v)
	return nil
}

func (w *Writer) WriteFloat64(v float64) error {
	w.bb.AppendFloat64(v)
	return nil
}

func (w *Writer) WriteBytes(v []byte) error {
	w.bb.AppendBytes(v)
	return nil
}
