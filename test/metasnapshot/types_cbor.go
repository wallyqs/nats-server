// Code generated by cborgen DO NOT EDIT.

package metasnapshot

import "time"

func (x ClientInfo) Msgsize() (s int) {
	s = cborMapHeaderSize + cborStringPrefixSize + len("acc") + cborStringPrefixSize + len(x.Account) + cborStringPrefixSize + len("svc") + cborStringPrefixSize + len(x.Service) + cborStringPrefixSize + len("cluster") + cborStringPrefixSize + len(x.Cluster)
	return
}

func (x *ClientInfo) MarshalCBOR(b []byte) ([]byte, error) {
	if x == nil {
		return cborAppendNil(b), nil
	}

	b = cborRequire(b, x.Msgsize())

	count := uint32(0)
	if !(x.Account == "") {
		count++
	}
	if !(x.Service == "") {
		count++
	}
	if !(x.Cluster == "") {
		count++
	}
	b = cborAppendMapHeader(b, count)
	var err error
	if !(x.Account == "") {
		b = cborAppendString(b, "acc")
		b, err = cborAppendString(b, x.Account), nil
		if err != nil {
			return b, err
		}
	}
	if !(x.Service == "") {
		b = cborAppendString(b, "svc")
		b, err = cborAppendString(b, x.Service), nil
		if err != nil {
			return b, err
		}
	}
	if !(x.Cluster == "") {
		b = cborAppendString(b, "cluster")
		b, err = cborAppendString(b, x.Cluster), nil
		if err != nil {
			return b, err
		}
	}

	return b, nil
}

// DecodeSafe decodes using validated, allocating string handling.
func (x *ClientInfo) DecodeSafe(b []byte) ([]byte, error) {
	if x == nil {
		return b, cborErrNotNil
	}
	sz, rest, err := cborReadMapHeaderBytes(b)
	if err != nil {
		return b, err
	}
	for i := uint32(0); i < sz; i++ {
		key, v, err := cborReadStringBytes(rest)
		if err != nil {
			return b, err
		}
		switch key {
		case "acc":

			var tmp string
			tmp, v, err = cborReadStringBytes(v)
			if err != nil {
				return b, err
			}
			x.Account = tmp
		case "svc":

			var tmp string
			tmp, v, err = cborReadStringBytes(v)
			if err != nil {
				return b, err
			}
			x.Service = tmp
		case "cluster":

			var tmp string
			tmp, v, err = cborReadStringBytes(v)
			if err != nil {
				return b, err
			}
			x.Cluster = tmp
		default:
			v, err = cborSkip(v)
			if err != nil {
				return b, err
			}
		}
		rest = v
	}
	return rest, nil
}

// DecodeTrusted decodes using zero-copy strings and no per-string UTF-8 validation.
func (x *ClientInfo) DecodeTrusted(b []byte) ([]byte, error) {
	if x == nil {
		return b, cborErrNotNil
	}
	sz, rest, err := cborReadMapHeaderBytes(b)
	if err != nil {
		return b, err
	}
	for i := uint32(0); i < sz; i++ {
		keyBytes, v, err := cborReadStringZC(rest)
		if err != nil {
			return b, err
		}
		key := cborUnsafeString(keyBytes)
		switch key {
		case "acc":

			var tmpBytes []byte
			tmpBytes, v, err = cborReadStringZC(v)
			if err != nil {
				return b, err
			}
			x.Account = cborUnsafeString(tmpBytes)
		case "svc":

			var tmpBytes []byte
			tmpBytes, v, err = cborReadStringZC(v)
			if err != nil {
				return b, err
			}
			x.Service = cborUnsafeString(tmpBytes)
		case "cluster":

			var tmpBytes []byte
			tmpBytes, v, err = cborReadStringZC(v)
			if err != nil {
				return b, err
			}
			x.Cluster = cborUnsafeString(tmpBytes)
		default:
			v, err = cborSkip(v)
			if err != nil {
				return b, err
			}
		}
		rest = v
	}
	return rest, nil
}

// UnmarshalCBOR implements cbor.Unmarshaler using the Safe path.
func (x *ClientInfo) UnmarshalCBOR(b []byte) ([]byte, error) {
	return x.DecodeSafe(b)
}

func (x RaftGroup) Msgsize() (s int) {
	s = cborMapHeaderSize + cborStringPrefixSize + len("name") + cborStringPrefixSize + len(x.Name) + cborStringPrefixSize + len("peers") + cborArrayHeaderSize + len(x.Peers)*cborStringPrefixSize + cborStringPrefixSize + len("cluster") + cborStringPrefixSize + len(x.Cluster) + cborStringPrefixSize + len("preferred") + cborStringPrefixSize + len(x.Preferred) + cborStringPrefixSize + len("scale_up") + cborBoolSize
	return
}

func (x *RaftGroup) MarshalCBOR(b []byte) ([]byte, error) {
	if x == nil {
		return cborAppendNil(b), nil
	}

	b = cborRequire(b, x.Msgsize())

	count := uint32(0)
	count++
	count++
	count++
	if !(x.Cluster == "") {
		count++
	}
	if !(x.Preferred == "") {
		count++
	}
	if !(!x.ScaleUp) {
		count++
	}
	b = cborAppendMapHeader(b, count)
	var err error
	b = cborAppendString(b, "name")
	b, err = cborAppendString(b, x.Name), nil
	if err != nil {
		return b, err
	}

	b = cborAppendString(b, "peers")
	b = cborAppendArrayHeader(b, uint32(len(x.Peers)))
	for _, v := range x.Peers {
		b = cborAppendString(b, v)
	}
	b = cborAppendString(b, "store")
	b, err = x.Storage.MarshalCBOR(b)
	if err != nil {
		return b, err
	}
	if !(x.Cluster == "") {
		b = cborAppendString(b, "cluster")
		b, err = cborAppendString(b, x.Cluster), nil
		if err != nil {
			return b, err
		}
	}
	if !(x.Preferred == "") {
		b = cborAppendString(b, "preferred")
		b, err = cborAppendString(b, x.Preferred), nil
		if err != nil {
			return b, err
		}
	}
	if !(!x.ScaleUp) {
		b = cborAppendString(b, "scale_up")
		b, err = cborAppendBool(b, x.ScaleUp), nil
		if err != nil {
			return b, err
		}
	}

	return b, nil
}

// DecodeSafe decodes using validated, allocating string handling.
func (x *RaftGroup) DecodeSafe(b []byte) ([]byte, error) {
	if x == nil {
		return b, cborErrNotNil
	}
	sz, rest, err := cborReadMapHeaderBytes(b)
	if err != nil {
		return b, err
	}
	for i := uint32(0); i < sz; i++ {
		key, v, err := cborReadStringBytes(rest)
		if err != nil {
			return b, err
		}
		switch key {
		case "name":

			var tmp string
			tmp, v, err = cborReadStringBytes(v)
			if err != nil {
				return b, err
			}
			x.Name = tmp
		case "peers":

			var sz uint32
			sz, v, err = cborReadArrayHeaderBytes(v)
			if err != nil {
				return b, err
			}
			if cap(x.Peers) >= int(sz) {
				x.Peers = x.Peers[:sz]
			} else {
				x.Peers = make([]string, sz)
			}
			if sz > 0 {
				_ = x.Peers[sz-1]
			}
			for iPeers := uint32(0); iPeers < sz; iPeers++ {
				var tmp string
				tmp, v, err = cborReadStringBytes(v)
				if err != nil {
					return b, err
				}
				x.Peers[iPeers] = tmp
			}
		case "store":

			v, err = x.Storage.UnmarshalCBOR(v)
			if err != nil {
				return b, err
			}
		case "cluster":

			var tmp string
			tmp, v, err = cborReadStringBytes(v)
			if err != nil {
				return b, err
			}
			x.Cluster = tmp
		case "preferred":

			var tmp string
			tmp, v, err = cborReadStringBytes(v)
			if err != nil {
				return b, err
			}
			x.Preferred = tmp
		case "scale_up":

			var tmp bool
			tmp, v, err = cborReadBoolBytes(v)
			if err != nil {
				return b, err
			}
			x.ScaleUp = tmp
		default:
			v, err = cborSkip(v)
			if err != nil {
				return b, err
			}
		}
		rest = v
	}
	return rest, nil
}

// DecodeTrusted decodes using zero-copy strings and no per-string UTF-8 validation.
func (x *RaftGroup) DecodeTrusted(b []byte) ([]byte, error) {
	if x == nil {
		return b, cborErrNotNil
	}
	sz, rest, err := cborReadMapHeaderBytes(b)
	if err != nil {
		return b, err
	}
	for i := uint32(0); i < sz; i++ {
		keyBytes, v, err := cborReadStringZC(rest)
		if err != nil {
			return b, err
		}
		key := cborUnsafeString(keyBytes)
		switch key {
		case "name":

			var tmpBytes []byte
			tmpBytes, v, err = cborReadStringZC(v)
			if err != nil {
				return b, err
			}
			x.Name = cborUnsafeString(tmpBytes)
		case "peers":

			var sz uint32
			sz, v, err = cborReadArrayHeaderBytes(v)
			if err != nil {
				return b, err
			}
			if cap(x.Peers) >= int(sz) {
				x.Peers = x.Peers[:sz]
			} else {
				x.Peers = make([]string, sz)
			}
			if sz > 0 {
				_ = x.Peers[sz-1]
			}
			for iPeers := uint32(0); iPeers < sz; iPeers++ {
				var tmp string
				tmp, v, err = cborReadStringBytes(v)
				if err != nil {
					return b, err
				}
				x.Peers[iPeers] = tmp
			}
		case "store":

			v, err = x.Storage.UnmarshalCBOR(v)
			if err != nil {
				return b, err
			}
		case "cluster":

			var tmpBytes []byte
			tmpBytes, v, err = cborReadStringZC(v)
			if err != nil {
				return b, err
			}
			x.Cluster = cborUnsafeString(tmpBytes)
		case "preferred":

			var tmpBytes []byte
			tmpBytes, v, err = cborReadStringZC(v)
			if err != nil {
				return b, err
			}
			x.Preferred = cborUnsafeString(tmpBytes)
		case "scale_up":

			var tmp bool
			tmp, v, err = cborReadBoolBytes(v)
			if err != nil {
				return b, err
			}
			x.ScaleUp = tmp
		default:
			v, err = cborSkip(v)
			if err != nil {
				return b, err
			}
		}
		rest = v
	}
	return rest, nil
}

// UnmarshalCBOR implements cbor.Unmarshaler using the Safe path.
func (x *RaftGroup) UnmarshalCBOR(b []byte) ([]byte, error) {
	return x.DecodeSafe(b)
}

func (x SequencePair) Msgsize() (s int) {
	s = cborMapHeaderSize + cborStringPrefixSize + len("consumer_seq") + cborUint64Size + cborStringPrefixSize + len("stream_seq") + cborUint64Size
	return
}

func (x *SequencePair) MarshalCBOR(b []byte) ([]byte, error) {
	if x == nil {
		return cborAppendNil(b), nil
	}

	b = cborRequire(b, x.Msgsize())

	b = cborAppendMapHeader(b, uint32(2))
	var err error
	b = cborAppendString(b, "consumer_seq")
	b, err = cborAppendUint64(b, x.Consumer), nil
	if err != nil {
		return b, err
	}
	b = cborAppendString(b, "stream_seq")
	b, err = cborAppendUint64(b, x.Stream), nil
	if err != nil {
		return b, err
	}

	return b, nil
}

// DecodeSafe decodes using validated, allocating string handling.
func (x *SequencePair) DecodeSafe(b []byte) ([]byte, error) {
	if x == nil {
		return b, cborErrNotNil
	}
	sz, rest, err := cborReadMapHeaderBytes(b)
	if err != nil {
		return b, err
	}
	for i := uint32(0); i < sz; i++ {
		key, v, err := cborReadStringBytes(rest)
		if err != nil {
			return b, err
		}
		switch key {
		case "consumer_seq":

			var tmp uint64
			tmp, v, err = cborReadUint64Bytes(v)
			if err != nil {
				return b, err
			}
			x.Consumer = tmp
		case "stream_seq":

			var tmp uint64
			tmp, v, err = cborReadUint64Bytes(v)
			if err != nil {
				return b, err
			}
			x.Stream = tmp
		default:
			v, err = cborSkip(v)
			if err != nil {
				return b, err
			}
		}
		rest = v
	}
	return rest, nil
}

// DecodeTrusted decodes using zero-copy strings and no per-string UTF-8 validation.
func (x *SequencePair) DecodeTrusted(b []byte) ([]byte, error) {
	if x == nil {
		return b, cborErrNotNil
	}
	sz, rest, err := cborReadMapHeaderBytes(b)
	if err != nil {
		return b, err
	}
	for i := uint32(0); i < sz; i++ {
		keyBytes, v, err := cborReadStringZC(rest)
		if err != nil {
			return b, err
		}
		key := cborUnsafeString(keyBytes)
		switch key {
		case "consumer_seq":

			var tmp uint64
			tmp, v, err = cborReadUint64Bytes(v)
			if err != nil {
				return b, err
			}
			x.Consumer = tmp
		case "stream_seq":

			var tmp uint64
			tmp, v, err = cborReadUint64Bytes(v)
			if err != nil {
				return b, err
			}
			x.Stream = tmp
		default:
			v, err = cborSkip(v)
			if err != nil {
				return b, err
			}
		}
		rest = v
	}
	return rest, nil
}

// UnmarshalCBOR implements cbor.Unmarshaler using the Safe path.
func (x *SequencePair) UnmarshalCBOR(b []byte) ([]byte, error) {
	return x.DecodeSafe(b)
}

func (x Pending) Msgsize() (s int) {
	s = cborMapHeaderSize + cborStringPrefixSize + len("sequence") + cborUint64Size + cborStringPrefixSize + len("ts") + cborInt64Size
	return
}

func (x *Pending) MarshalCBOR(b []byte) ([]byte, error) {
	if x == nil {
		return cborAppendNil(b), nil
	}

	b = cborRequire(b, x.Msgsize())

	b = cborAppendMapHeader(b, uint32(2))
	var err error
	b = cborAppendString(b, "sequence")
	b, err = cborAppendUint64(b, x.Sequence), nil
	if err != nil {
		return b, err
	}
	b = cborAppendString(b, "ts")
	b, err = cborAppendInt64(b, x.Timestamp), nil
	if err != nil {
		return b, err
	}

	return b, nil
}

// DecodeSafe decodes using validated, allocating string handling.
func (x *Pending) DecodeSafe(b []byte) ([]byte, error) {
	if x == nil {
		return b, cborErrNotNil
	}
	sz, rest, err := cborReadMapHeaderBytes(b)
	if err != nil {
		return b, err
	}
	for i := uint32(0); i < sz; i++ {
		key, v, err := cborReadStringBytes(rest)
		if err != nil {
			return b, err
		}
		switch key {
		case "sequence":

			var tmp uint64
			tmp, v, err = cborReadUint64Bytes(v)
			if err != nil {
				return b, err
			}
			x.Sequence = tmp
		case "ts":

			var tmp int64
			tmp, v, err = cborReadInt64Bytes(v)
			if err != nil {
				return b, err
			}
			x.Timestamp = tmp
		default:
			v, err = cborSkip(v)
			if err != nil {
				return b, err
			}
		}
		rest = v
	}
	return rest, nil
}

// DecodeTrusted decodes using zero-copy strings and no per-string UTF-8 validation.
func (x *Pending) DecodeTrusted(b []byte) ([]byte, error) {
	if x == nil {
		return b, cborErrNotNil
	}
	sz, rest, err := cborReadMapHeaderBytes(b)
	if err != nil {
		return b, err
	}
	for i := uint32(0); i < sz; i++ {
		keyBytes, v, err := cborReadStringZC(rest)
		if err != nil {
			return b, err
		}
		key := cborUnsafeString(keyBytes)
		switch key {
		case "sequence":

			var tmp uint64
			tmp, v, err = cborReadUint64Bytes(v)
			if err != nil {
				return b, err
			}
			x.Sequence = tmp
		case "ts":

			var tmp int64
			tmp, v, err = cborReadInt64Bytes(v)
			if err != nil {
				return b, err
			}
			x.Timestamp = tmp
		default:
			v, err = cborSkip(v)
			if err != nil {
				return b, err
			}
		}
		rest = v
	}
	return rest, nil
}

// UnmarshalCBOR implements cbor.Unmarshaler using the Safe path.
func (x *Pending) UnmarshalCBOR(b []byte) ([]byte, error) {
	return x.DecodeSafe(b)
}

func (x *ConsumerState) MarshalCBOR(b []byte) ([]byte, error) {
	if x == nil {
		return cborAppendNil(b), nil
	}

	count := uint32(0)
	count++
	count++
	if !(len(x.Pending) == 0) {
		count++
	}
	if !(len(x.Redelivered) == 0) {
		count++
	}
	b = cborAppendMapHeader(b, count)
	var err error
	b = cborAppendString(b, "delivered")
	b, err = x.Delivered.MarshalCBOR(b)
	if err != nil {
		return b, err
	}
	b = cborAppendString(b, "ack_floor")
	b, err = x.AckFloor.MarshalCBOR(b)
	if err != nil {
		return b, err
	}
	if !(len(x.Pending) == 0) {

		b = cborAppendString(b, "pending")
		b = cborAppendMapHeader(b, uint32(len(x.Pending)))
		for k, v := range x.Pending {
			b = cborAppendUint64(b, k)
			if v == nil {
				b = cborAppendNil(b)
			} else {
				b, err = v.MarshalCBOR(b)
				if err != nil {
					return b, err
				}
			}
		}
	}
	if !(len(x.Redelivered) == 0) {

		b = cborAppendString(b, "redelivered")
		b = cborAppendMapHeader(b, uint32(len(x.Redelivered)))
		for k, v := range x.Redelivered {
			b = cborAppendUint64(b, k)
			b = cborAppendUint64(b, v)
		}
	}

	return b, nil
}

// DecodeSafe decodes using validated, allocating string handling.
func (x *ConsumerState) DecodeSafe(b []byte) ([]byte, error) {
	if x == nil {
		return b, cborErrNotNil
	}
	sz, rest, err := cborReadMapHeaderBytes(b)
	if err != nil {
		return b, err
	}
	for i := uint32(0); i < sz; i++ {
		key, v, err := cborReadStringBytes(rest)
		if err != nil {
			return b, err
		}
		switch key {
		case "delivered":

			v, err = x.Delivered.UnmarshalCBOR(v)
			if err != nil {
				return b, err
			}
		case "ack_floor":

			v, err = x.AckFloor.UnmarshalCBOR(v)
			if err != nil {
				return b, err
			}
		case "pending":

			var sz uint32
			sz, v, err = cborReadMapHeaderBytes(v)
			if err != nil {
				return b, err
			}
			if x.Pending == nil && sz > 0 {
				x.Pending = make(map[uint64]*Pending, sz)
			} else if x.Pending != nil {
				clear(x.Pending)
			}
			for iPending := uint32(0); iPending < sz; iPending++ {
				var key uint64
				key, v, err = cborReadUint64Bytes(v)
				if err != nil {
					return b, err
				}
				if len(v) == 0 {
					return b, cborErrShortBytes
				}
				if v[0] == 0xf6 { // null
					var tmpBytes []byte
					tmpBytes, err = cborReadNilBytes(v)
					if err != nil {
						return b, err
					}
					v = tmpBytes
					x.Pending[key] = nil
					continue
				}
				tmp := new(Pending)
				v, err = tmp.UnmarshalCBOR(v)
				if err != nil {
					return b, err
				}
				x.Pending[key] = tmp
			}
		case "redelivered":

			var sz uint32
			sz, v, err = cborReadMapHeaderBytes(v)
			if err != nil {
				return b, err
			}
			if x.Redelivered == nil && sz > 0 {
				x.Redelivered = make(map[uint64]uint64, sz)
			} else if x.Redelivered != nil {
				clear(x.Redelivered)
			}
			for iRedelivered := uint32(0); iRedelivered < sz; iRedelivered++ {
				var key uint64
				key, v, err = cborReadUint64Bytes(v)
				if err != nil {
					return b, err
				}
				var val uint64
				val, v, err = cborReadUint64Bytes(v)
				if err != nil {
					return b, err
				}
				x.Redelivered[key] = val
			}
		default:
			v, err = cborSkip(v)
			if err != nil {
				return b, err
			}
		}
		rest = v
	}
	return rest, nil
}

// DecodeTrusted decodes using zero-copy strings and no per-string UTF-8 validation.
func (x *ConsumerState) DecodeTrusted(b []byte) ([]byte, error) {
	if x == nil {
		return b, cborErrNotNil
	}
	sz, rest, err := cborReadMapHeaderBytes(b)
	if err != nil {
		return b, err
	}
	for i := uint32(0); i < sz; i++ {
		keyBytes, v, err := cborReadStringZC(rest)
		if err != nil {
			return b, err
		}
		key := cborUnsafeString(keyBytes)
		switch key {
		case "delivered":

			v, err = (&x.Delivered).DecodeTrusted(v)
			if err != nil {
				return b, err
			}
		case "ack_floor":

			v, err = (&x.AckFloor).DecodeTrusted(v)
			if err != nil {
				return b, err
			}
		case "pending":

			var sz uint32
			sz, v, err = cborReadMapHeaderBytes(v)
			if err != nil {
				return b, err
			}
			if x.Pending == nil && sz > 0 {
				x.Pending = make(map[uint64]*Pending, sz)
			}
			for iPending := uint32(0); iPending < sz; iPending++ {
				var key uint64
				key, v, err = cborReadUint64Bytes(v)
				if err != nil {
					return b, err
				}
				if len(v) == 0 {
					return b, cborErrShortBytes
				}
				if v[0] == 0xf6 { // null
					var tmp []byte
					tmp, err = cborReadNilBytes(v)
					if err != nil {
						return b, err
					}
					v = tmp
					x.Pending[key] = nil
					continue
				}
				val := new(Pending)
				v, err = val.DecodeTrusted(v)
				if err != nil {
					return b, err
				}
				x.Pending[key] = val
			}
		case "redelivered":

			var sz uint32
			sz, v, err = cborReadMapHeaderBytes(v)
			if err != nil {
				return b, err
			}
			if x.Redelivered == nil && sz > 0 {
				x.Redelivered = make(map[uint64]uint64, sz)
			}
			for iRedelivered := uint32(0); iRedelivered < sz; iRedelivered++ {
				var key uint64
				key, v, err = cborReadUint64Bytes(v)
				if err != nil {
					return b, err
				}
				var val uint64
				val, v, err = cborReadUint64Bytes(v)
				if err != nil {
					return b, err
				}
				x.Redelivered[key] = val
			}
		default:
			v, err = cborSkip(v)
			if err != nil {
				return b, err
			}
		}
		rest = v
	}
	return rest, nil
}

// UnmarshalCBOR implements cbor.Unmarshaler using the Safe path.
func (x *ConsumerState) UnmarshalCBOR(b []byte) ([]byte, error) {
	return x.DecodeSafe(b)
}

func (x WriteableConsumerAssignment) Msgsize() (s int) {
	s = cborMapHeaderSize + cborStringPrefixSize + len("created") + cborTimeSize + cborStringPrefixSize + len("name") + cborStringPrefixSize + len(x.Name) + cborStringPrefixSize + len("stream") + cborStringPrefixSize + len(x.Stream)
	return
}

func (x *WriteableConsumerAssignment) MarshalCBOR(b []byte) ([]byte, error) {
	if x == nil {
		return cborAppendNil(b), nil
	}

	b = cborRequire(b, x.Msgsize())

	count := uint32(0)
	if !(x.Client == nil) {
		count++
	}
	count++
	count++
	count++
	count++
	count++
	if !(x.State == nil) {
		count++
	}
	b = cborAppendMapHeader(b, count)
	var err error
	if !(x.Client == nil) {
		b = cborAppendString(b, "client")
		b, err = cborAppendPtrMarshaler(b, x.Client)
		if err != nil {
			return b, err
		}
	}
	b = cborAppendString(b, "created")
	b, err = cborAppendTime(b, x.Created), nil
	if err != nil {
		return b, err
	}
	b = cborAppendString(b, "name")
	b, err = cborAppendString(b, x.Name), nil
	if err != nil {
		return b, err
	}
	b = cborAppendString(b, "stream")
	b, err = cborAppendString(b, x.Stream), nil
	if err != nil {
		return b, err
	}
	b = cborAppendString(b, "consumer")
	b, err = cborAppendBytes(b, []byte(x.ConfigJSON)), nil
	if err != nil {
		return b, err
	}
	b = cborAppendString(b, "group")
	b, err = cborAppendPtrMarshaler(b, x.Group)
	if err != nil {
		return b, err
	}
	if !(x.State == nil) {
		b = cborAppendString(b, "state")
		b, err = cborAppendPtrMarshaler(b, x.State)
		if err != nil {
			return b, err
		}
	}

	return b, nil
}

// DecodeSafe decodes using validated, allocating string handling.
func (x *WriteableConsumerAssignment) DecodeSafe(b []byte) ([]byte, error) {
	if x == nil {
		return b, cborErrNotNil
	}
	sz, rest, err := cborReadMapHeaderBytes(b)
	if err != nil {
		return b, err
	}
	for i := uint32(0); i < sz; i++ {
		key, v, err := cborReadStringBytes(rest)
		if err != nil {
			return b, err
		}
		switch key {
		case "client":

			if x.Client == nil {
				x.Client = new(ClientInfo)
			}
			v, err = x.Client.UnmarshalCBOR(v)
			if err != nil {
				return b, err
			}
		case "created":

			var tmp time.Time
			tmp, v, err = cborReadTimeBytes(v)
			if err != nil {
				return b, err
			}
			x.Created = tmp
		case "name":

			var tmp string
			tmp, v, err = cborReadStringBytes(v)
			if err != nil {
				return b, err
			}
			x.Name = tmp
		case "stream":

			var tmp string
			tmp, v, err = cborReadStringBytes(v)
			if err != nil {
				return b, err
			}
			x.Stream = tmp
		case "consumer":

			v, err = cborSkip(v)
			if err != nil {
				return b, err
			}
		case "group":

			if x.Group == nil {
				x.Group = new(RaftGroup)
			}
			v, err = x.Group.UnmarshalCBOR(v)
			if err != nil {
				return b, err
			}
		case "state":

			if x.State == nil {
				x.State = new(ConsumerState)
			}
			v, err = x.State.UnmarshalCBOR(v)
			if err != nil {
				return b, err
			}
		default:
			v, err = cborSkip(v)
			if err != nil {
				return b, err
			}
		}
		rest = v
	}
	return rest, nil
}

// DecodeTrusted decodes using zero-copy strings and no per-string UTF-8 validation.
func (x *WriteableConsumerAssignment) DecodeTrusted(b []byte) ([]byte, error) {
	if x == nil {
		return b, cborErrNotNil
	}
	sz, rest, err := cborReadMapHeaderBytes(b)
	if err != nil {
		return b, err
	}
	for i := uint32(0); i < sz; i++ {
		keyBytes, v, err := cborReadStringZC(rest)
		if err != nil {
			return b, err
		}
		key := cborUnsafeString(keyBytes)
		switch key {
		case "client":

			if x.Client == nil {
				x.Client = new(ClientInfo)
			}
			v, err = x.Client.DecodeTrusted(v)
			if err != nil {
				return b, err
			}
		case "created":

			var tmp time.Time
			tmp, v, err = cborReadTimeBytes(v)
			if err != nil {
				return b, err
			}
			x.Created = tmp
		case "name":

			var tmpBytes []byte
			tmpBytes, v, err = cborReadStringZC(v)
			if err != nil {
				return b, err
			}
			x.Name = cborUnsafeString(tmpBytes)
		case "stream":

			var tmpBytes []byte
			tmpBytes, v, err = cborReadStringZC(v)
			if err != nil {
				return b, err
			}
			x.Stream = cborUnsafeString(tmpBytes)
		case "consumer":

			v, err = cborSkip(v)
			if err != nil {
				return b, err
			}
		case "group":

			if x.Group == nil {
				x.Group = new(RaftGroup)
			}
			v, err = x.Group.DecodeTrusted(v)
			if err != nil {
				return b, err
			}
		case "state":

			if x.State == nil {
				x.State = new(ConsumerState)
			}
			v, err = x.State.DecodeTrusted(v)
			if err != nil {
				return b, err
			}
		default:
			v, err = cborSkip(v)
			if err != nil {
				return b, err
			}
		}
		rest = v
	}
	return rest, nil
}

// UnmarshalCBOR implements cbor.Unmarshaler using the Safe path.
func (x *WriteableConsumerAssignment) UnmarshalCBOR(b []byte) ([]byte, error) {
	return x.DecodeSafe(b)
}

func (x WriteableStreamAssignment) Msgsize() (s int) {
	s = cborMapHeaderSize + cborStringPrefixSize + len("created") + cborTimeSize + cborStringPrefixSize + len("sync") + cborStringPrefixSize + len(x.Sync)
	return
}

func (x *WriteableStreamAssignment) MarshalCBOR(b []byte) ([]byte, error) {
	if x == nil {
		return cborAppendNil(b), nil
	}

	b = cborRequire(b, x.Msgsize())

	count := uint32(0)
	if !(x.Client == nil) {
		count++
	}
	count++
	count++
	count++
	count++
	if !(len(x.Consumers) == 0) {
		count++
	}
	b = cborAppendMapHeader(b, count)
	var err error
	if !(x.Client == nil) {
		b = cborAppendString(b, "client")
		b, err = cborAppendPtrMarshaler(b, x.Client)
		if err != nil {
			return b, err
		}
	}
	b = cborAppendString(b, "created")
	b, err = cborAppendTime(b, x.Created), nil
	if err != nil {
		return b, err
	}
	b = cborAppendString(b, "stream")
	b, err = cborAppendBytes(b, []byte(x.ConfigJSON)), nil
	if err != nil {
		return b, err
	}
	b = cborAppendString(b, "group")
	b, err = cborAppendPtrMarshaler(b, x.Group)
	if err != nil {
		return b, err
	}
	b = cborAppendString(b, "sync")
	b, err = cborAppendString(b, x.Sync), nil
	if err != nil {
		return b, err
	}
	if !(len(x.Consumers) == 0) {

		b = cborAppendString(b, "consumers")
		b = cborAppendArrayHeader(b, uint32(len(x.Consumers)))
		for _, w := range x.Consumers {
			if w == nil {
				b = cborAppendNil(b)
			} else {
				b, err = w.MarshalCBOR(b)
				if err != nil {
					return b, err
				}
			}
		}
	}

	return b, nil
}

// DecodeSafe decodes using validated, allocating string handling.
func (x *WriteableStreamAssignment) DecodeSafe(b []byte) ([]byte, error) {
	if x == nil {
		return b, cborErrNotNil
	}
	sz, rest, err := cborReadMapHeaderBytes(b)
	if err != nil {
		return b, err
	}
	for i := uint32(0); i < sz; i++ {
		key, v, err := cborReadStringBytes(rest)
		if err != nil {
			return b, err
		}
		switch key {
		case "client":

			if x.Client == nil {
				x.Client = new(ClientInfo)
			}
			v, err = x.Client.UnmarshalCBOR(v)
			if err != nil {
				return b, err
			}
		case "created":

			var tmp time.Time
			tmp, v, err = cborReadTimeBytes(v)
			if err != nil {
				return b, err
			}
			x.Created = tmp
		case "stream":

			v, err = cborSkip(v)
			if err != nil {
				return b, err
			}
		case "group":

			if x.Group == nil {
				x.Group = new(RaftGroup)
			}
			v, err = x.Group.UnmarshalCBOR(v)
			if err != nil {
				return b, err
			}
		case "sync":

			var tmp string
			tmp, v, err = cborReadStringBytes(v)
			if err != nil {
				return b, err
			}
			x.Sync = tmp
		case "consumers":

			var sz uint32
			sz, v, err = cborReadArrayHeaderBytes(v)
			if err != nil {
				return b, err
			}
			if cap(x.Consumers) >= int(sz) {
				x.Consumers = x.Consumers[:sz]
			} else {
				x.Consumers = make([]*WriteableConsumerAssignment, sz)
			}
			if sz > 0 {
				_ = x.Consumers[sz-1]
			}
			for iConsumers := uint32(0); iConsumers < sz; iConsumers++ {
				if x.Consumers[iConsumers] == nil {
					x.Consumers[iConsumers] = new(WriteableConsumerAssignment)
				}
				v, err = x.Consumers[iConsumers].UnmarshalCBOR(v)
				if err != nil {
					return b, err
				}
			}
		default:
			v, err = cborSkip(v)
			if err != nil {
				return b, err
			}
		}
		rest = v
	}
	return rest, nil
}

// DecodeTrusted decodes using zero-copy strings and no per-string UTF-8 validation.
func (x *WriteableStreamAssignment) DecodeTrusted(b []byte) ([]byte, error) {
	if x == nil {
		return b, cborErrNotNil
	}
	sz, rest, err := cborReadMapHeaderBytes(b)
	if err != nil {
		return b, err
	}
	for i := uint32(0); i < sz; i++ {
		keyBytes, v, err := cborReadStringZC(rest)
		if err != nil {
			return b, err
		}
		key := cborUnsafeString(keyBytes)
		switch key {
		case "client":

			if x.Client == nil {
				x.Client = new(ClientInfo)
			}
			v, err = x.Client.DecodeTrusted(v)
			if err != nil {
				return b, err
			}
		case "created":

			var tmp time.Time
			tmp, v, err = cborReadTimeBytes(v)
			if err != nil {
				return b, err
			}
			x.Created = tmp
		case "stream":

			v, err = cborSkip(v)
			if err != nil {
				return b, err
			}
		case "group":

			if x.Group == nil {
				x.Group = new(RaftGroup)
			}
			v, err = x.Group.DecodeTrusted(v)
			if err != nil {
				return b, err
			}
		case "sync":

			var tmpBytes []byte
			tmpBytes, v, err = cborReadStringZC(v)
			if err != nil {
				return b, err
			}
			x.Sync = cborUnsafeString(tmpBytes)
		case "consumers":

			var sz uint32
			sz, v, err = cborReadArrayHeaderBytes(v)
			if err != nil {
				return b, err
			}
			if cap(x.Consumers) >= int(sz) {
				x.Consumers = x.Consumers[:sz]
			} else {
				x.Consumers = make([]*WriteableConsumerAssignment, sz)
			}
			if sz > 0 {
				_ = x.Consumers[sz-1]
			}
			for iConsumers := uint32(0); iConsumers < sz; iConsumers++ {
				if x.Consumers[iConsumers] == nil {
					x.Consumers[iConsumers] = new(WriteableConsumerAssignment)
				}
				v, err = x.Consumers[iConsumers].DecodeTrusted(v)
				if err != nil {
					return b, err
				}
			}
		default:
			v, err = cborSkip(v)
			if err != nil {
				return b, err
			}
		}
		rest = v
	}
	return rest, nil
}

// UnmarshalCBOR implements cbor.Unmarshaler using the Safe path.
func (x *WriteableStreamAssignment) UnmarshalCBOR(b []byte) ([]byte, error) {
	return x.DecodeSafe(b)
}

func (x MetaSnapshot) Msgsize() (s int) {
	s = cborMapHeaderSize + cborStringPrefixSize + len("streams") + cborArrayHeaderSize + len(x.Streams)*0
	return
}

func (x *MetaSnapshot) MarshalCBOR(b []byte) ([]byte, error) {
	if x == nil {
		return cborAppendNil(b), nil
	}

	b = cborRequire(b, x.Msgsize())

	b = cborAppendMapHeader(b, uint32(1))
	var err error

	b = cborAppendString(b, "streams")
	b = cborAppendArrayHeader(b, uint32(len(x.Streams)))
	for i := range x.Streams {
		b, err = x.Streams[i].MarshalCBOR(b)
		if err != nil {
			return b, err
		}
	}

	return b, nil
}

// DecodeSafe decodes using validated, allocating string handling.
func (x *MetaSnapshot) DecodeSafe(b []byte) ([]byte, error) {
	if x == nil {
		return b, cborErrNotNil
	}
	sz, rest, err := cborReadMapHeaderBytes(b)
	if err != nil {
		return b, err
	}
	for i := uint32(0); i < sz; i++ {
		key, v, err := cborReadStringBytes(rest)
		if err != nil {
			return b, err
		}
		switch key {
		case "streams":

			var sz uint32
			sz, v, err = cborReadArrayHeaderBytes(v)
			if err != nil {
				return b, err
			}
			if cap(x.Streams) >= int(sz) {
				x.Streams = x.Streams[:sz]
			} else {
				x.Streams = make([]WriteableStreamAssignment, sz)
			}
			if sz > 0 {
				_ = x.Streams[sz-1]
			}
			for iStreams := uint32(0); iStreams < sz; iStreams++ {
				var tmp WriteableStreamAssignment
				v, err = (&tmp).UnmarshalCBOR(v)
				if err != nil {
					return b, err
				}
				x.Streams[iStreams] = tmp
			}
		default:
			v, err = cborSkip(v)
			if err != nil {
				return b, err
			}
		}
		rest = v
	}
	return rest, nil
}

// DecodeTrusted decodes using zero-copy strings and no per-string UTF-8 validation.
func (x *MetaSnapshot) DecodeTrusted(b []byte) ([]byte, error) {
	if x == nil {
		return b, cborErrNotNil
	}
	sz, rest, err := cborReadMapHeaderBytes(b)
	if err != nil {
		return b, err
	}
	for i := uint32(0); i < sz; i++ {
		keyBytes, v, err := cborReadStringZC(rest)
		if err != nil {
			return b, err
		}
		key := cborUnsafeString(keyBytes)
		switch key {
		case "streams":

			var sz uint32
			sz, v, err = cborReadArrayHeaderBytes(v)
			if err != nil {
				return b, err
			}
			if cap(x.Streams) >= int(sz) {
				x.Streams = x.Streams[:sz]
			} else {
				x.Streams = make([]WriteableStreamAssignment, sz)
			}
			if sz > 0 {
				_ = x.Streams[sz-1]
			}
			for iStreams := uint32(0); iStreams < sz; iStreams++ {
				var tmp WriteableStreamAssignment
				v, err = (&tmp).DecodeTrusted(v)
				if err != nil {
					return b, err
				}
				x.Streams[iStreams] = tmp
			}
		default:
			v, err = cborSkip(v)
			if err != nil {
				return b, err
			}
		}
		rest = v
	}
	return rest, nil
}

// UnmarshalCBOR implements cbor.Unmarshaler using the Safe path.
func (x *MetaSnapshot) UnmarshalCBOR(b []byte) ([]byte, error) {
	return x.DecodeSafe(b)
}
