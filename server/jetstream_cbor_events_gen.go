// Code generated by cborgen DO NOT EDIT.

package server

import "time"

func (x ClientInfo) Msgsize() (s int) {
	s = cborMapHeaderSize + cborStringPrefixSize + len("host") + cborStringPrefixSize + len(x.Host) + cborStringPrefixSize + len("id") + cborUint64Size + cborStringPrefixSize + len("acc") + cborStringPrefixSize + len(x.Account) + cborStringPrefixSize + len("svc") + cborStringPrefixSize + len(x.Service) + cborStringPrefixSize + len("user") + cborStringPrefixSize + len(x.User) + cborStringPrefixSize + len("name") + cborStringPrefixSize + len(x.Name) + cborStringPrefixSize + len("lang") + cborStringPrefixSize + len(x.Lang) + cborStringPrefixSize + len("ver") + cborStringPrefixSize + len(x.Version) + cborStringPrefixSize + len("rtt") + cborDurationSize + cborStringPrefixSize + len("server") + cborStringPrefixSize + len(x.Server) + cborStringPrefixSize + len("cluster") + cborStringPrefixSize + len(x.Cluster) + cborStringPrefixSize + len("alts") + cborArrayHeaderSize + len(x.Alternates)*cborStringPrefixSize + cborStringPrefixSize + len("jwt") + cborStringPrefixSize + len(x.Jwt) + cborStringPrefixSize + len("issuer_key") + cborStringPrefixSize + len(x.IssuerKey) + cborStringPrefixSize + len("name_tag") + cborStringPrefixSize + len(x.NameTag) + cborStringPrefixSize + len("kind") + cborStringPrefixSize + len(x.Kind) + cborStringPrefixSize + len("client_type") + cborStringPrefixSize + len(x.ClientType) + cborStringPrefixSize + len("client_id") + cborStringPrefixSize + len(x.MQTTClient) + cborStringPrefixSize + len("nonce") + cborStringPrefixSize + len(x.Nonce)
	return
}

func (x *ClientInfo) MarshalCBOR(b []byte) ([]byte, error) {
	if x == nil {
		return cborAppendNil(b), nil
	}

	b = cborRequire(b, x.Msgsize())

	count := uint32(0)
	if !(x.Start == nil) {
		count++
	}
	if !(x.Host == "") {
		count++
	}
	if !(x.ID == 0) {
		count++
	}
	if !(x.Account == "") {
		count++
	}
	if !(x.Service == "") {
		count++
	}
	if !(x.User == "") {
		count++
	}
	if !(x.Name == "") {
		count++
	}
	if !(x.Lang == "") {
		count++
	}
	if !(x.Version == "") {
		count++
	}
	if !(x.RTT == 0) {
		count++
	}
	if !(x.Server == "") {
		count++
	}
	if !(x.Cluster == "") {
		count++
	}
	if !(len(x.Alternates) == 0) {
		count++
	}
	if !(x.Stop == nil) {
		count++
	}
	if !(x.Jwt == "") {
		count++
	}
	if !(x.IssuerKey == "") {
		count++
	}
	if !(x.NameTag == "") {
		count++
	}
	count++
	if !(x.Kind == "") {
		count++
	}
	if !(x.ClientType == "") {
		count++
	}
	if !(x.MQTTClient == "") {
		count++
	}
	if !(x.Nonce == "") {
		count++
	}
	b = cborAppendMapHeader(b, count)
	var err error
	if !(x.Start == nil) {
		b = cborAppendString(b, "start")
		b, err = cborAppendInterface(b, x.Start)
		if err != nil {
			return b, err
		}
	}
	if !(x.Host == "") {
		b = cborAppendString(b, "host")
		b, err = cborAppendString(b, x.Host), nil
		if err != nil {
			return b, err
		}
	}
	if !(x.ID == 0) {
		b = cborAppendString(b, "id")
		b, err = cborAppendUint64(b, x.ID), nil
		if err != nil {
			return b, err
		}
	}
	if !(x.Account == "") {
		b = cborAppendString(b, "acc")
		b, err = cborAppendString(b, x.Account), nil
		if err != nil {
			return b, err
		}
	}
	if !(x.Service == "") {
		b = cborAppendString(b, "svc")
		b, err = cborAppendString(b, x.Service), nil
		if err != nil {
			return b, err
		}
	}
	if !(x.User == "") {
		b = cborAppendString(b, "user")
		b, err = cborAppendString(b, x.User), nil
		if err != nil {
			return b, err
		}
	}
	if !(x.Name == "") {
		b = cborAppendString(b, "name")
		b, err = cborAppendString(b, x.Name), nil
		if err != nil {
			return b, err
		}
	}
	if !(x.Lang == "") {
		b = cborAppendString(b, "lang")
		b, err = cborAppendString(b, x.Lang), nil
		if err != nil {
			return b, err
		}
	}
	if !(x.Version == "") {
		b = cborAppendString(b, "ver")
		b, err = cborAppendString(b, x.Version), nil
		if err != nil {
			return b, err
		}
	}
	if !(x.RTT == 0) {
		b = cborAppendString(b, "rtt")
		b, err = cborAppendDuration(b, x.RTT), nil
		if err != nil {
			return b, err
		}
	}
	if !(x.Server == "") {
		b = cborAppendString(b, "server")
		b, err = cborAppendString(b, x.Server), nil
		if err != nil {
			return b, err
		}
	}
	if !(x.Cluster == "") {
		b = cborAppendString(b, "cluster")
		b, err = cborAppendString(b, x.Cluster), nil
		if err != nil {
			return b, err
		}
	}
	if !(len(x.Alternates) == 0) {

		b = cborAppendString(b, "alts")
		b = cborAppendArrayHeader(b, uint32(len(x.Alternates)))
		for _, v := range x.Alternates {
			b = cborAppendString(b, v)
		}
	}
	if !(x.Stop == nil) {
		b = cborAppendString(b, "stop")
		b, err = cborAppendInterface(b, x.Stop)
		if err != nil {
			return b, err
		}
	}
	if !(x.Jwt == "") {
		b = cborAppendString(b, "jwt")
		b, err = cborAppendString(b, x.Jwt), nil
		if err != nil {
			return b, err
		}
	}
	if !(x.IssuerKey == "") {
		b = cborAppendString(b, "issuer_key")
		b, err = cborAppendString(b, x.IssuerKey), nil
		if err != nil {
			return b, err
		}
	}
	if !(x.NameTag == "") {
		b = cborAppendString(b, "name_tag")
		b, err = cborAppendString(b, x.NameTag), nil
		if err != nil {
			return b, err
		}
	}
	b = cborAppendString(b, "tags")
	b, err = cborAppendInterface(b, x.Tags)
	if err != nil {
		return b, err
	}
	if !(x.Kind == "") {
		b = cborAppendString(b, "kind")
		b, err = cborAppendString(b, x.Kind), nil
		if err != nil {
			return b, err
		}
	}
	if !(x.ClientType == "") {
		b = cborAppendString(b, "client_type")
		b, err = cborAppendString(b, x.ClientType), nil
		if err != nil {
			return b, err
		}
	}
	if !(x.MQTTClient == "") {
		b = cborAppendString(b, "client_id")
		b, err = cborAppendString(b, x.MQTTClient), nil
		if err != nil {
			return b, err
		}
	}
	if !(x.Nonce == "") {
		b = cborAppendString(b, "nonce")
		b, err = cborAppendString(b, x.Nonce), nil
		if err != nil {
			return b, err
		}
	}

	return b, nil
}

// DecodeSafe decodes using validated, allocating string handling.
func (x *ClientInfo) DecodeSafe(b []byte) ([]byte, error) {
	if x == nil {
		return b, cborErrNotNil
	}
	sz, rest, err := cborReadMapHeaderBytes(b)
	if err != nil {
		return b, err
	}
	for i := uint32(0); i < sz; i++ {
		key, v, err := cborReadStringBytes(rest)
		if err != nil {
			return b, err
		}
		switch key {
		case "start":

			v, err = cborSkip(v)
			if err != nil {
				return b, err
			}
		case "host":

			var tmp string
			tmp, v, err = cborReadStringBytes(v)
			if err != nil {
				return b, err
			}
			x.Host = tmp
		case "id":

			var tmp uint64
			tmp, v, err = cborReadUint64Bytes(v)
			if err != nil {
				return b, err
			}
			x.ID = tmp
		case "acc":

			var tmp string
			tmp, v, err = cborReadStringBytes(v)
			if err != nil {
				return b, err
			}
			x.Account = tmp
		case "svc":

			var tmp string
			tmp, v, err = cborReadStringBytes(v)
			if err != nil {
				return b, err
			}
			x.Service = tmp
		case "user":

			var tmp string
			tmp, v, err = cborReadStringBytes(v)
			if err != nil {
				return b, err
			}
			x.User = tmp
		case "name":

			var tmp string
			tmp, v, err = cborReadStringBytes(v)
			if err != nil {
				return b, err
			}
			x.Name = tmp
		case "lang":

			var tmp string
			tmp, v, err = cborReadStringBytes(v)
			if err != nil {
				return b, err
			}
			x.Lang = tmp
		case "ver":

			var tmp string
			tmp, v, err = cborReadStringBytes(v)
			if err != nil {
				return b, err
			}
			x.Version = tmp
		case "rtt":

			var tmp time.Duration
			tmp, v, err = cborReadDurationBytes(v)
			if err != nil {
				return b, err
			}
			x.RTT = tmp
		case "server":

			var tmp string
			tmp, v, err = cborReadStringBytes(v)
			if err != nil {
				return b, err
			}
			x.Server = tmp
		case "cluster":

			var tmp string
			tmp, v, err = cborReadStringBytes(v)
			if err != nil {
				return b, err
			}
			x.Cluster = tmp
		case "alts":

			var sz uint32
			sz, v, err = cborReadArrayHeaderBytes(v)
			if err != nil {
				return b, err
			}
			if cap(x.Alternates) >= int(sz) {
				x.Alternates = x.Alternates[:sz]
			} else {
				x.Alternates = make([]string, sz)
			}
			if sz > 0 {
				_ = x.Alternates[sz-1]
			}
			for iAlternates := uint32(0); iAlternates < sz; iAlternates++ {
				var tmp string
				tmp, v, err = cborReadStringBytes(v)
				if err != nil {
					return b, err
				}
				x.Alternates[iAlternates] = tmp
			}
		case "stop":

			v, err = cborSkip(v)
			if err != nil {
				return b, err
			}
		case "jwt":

			var tmp string
			tmp, v, err = cborReadStringBytes(v)
			if err != nil {
				return b, err
			}
			x.Jwt = tmp
		case "issuer_key":

			var tmp string
			tmp, v, err = cborReadStringBytes(v)
			if err != nil {
				return b, err
			}
			x.IssuerKey = tmp
		case "name_tag":

			var tmp string
			tmp, v, err = cborReadStringBytes(v)
			if err != nil {
				return b, err
			}
			x.NameTag = tmp
		case "tags":

			v, err = cborSkip(v)
			if err != nil {
				return b, err
			}
		case "kind":

			var tmp string
			tmp, v, err = cborReadStringBytes(v)
			if err != nil {
				return b, err
			}
			x.Kind = tmp
		case "client_type":

			var tmp string
			tmp, v, err = cborReadStringBytes(v)
			if err != nil {
				return b, err
			}
			x.ClientType = tmp
		case "client_id":

			var tmp string
			tmp, v, err = cborReadStringBytes(v)
			if err != nil {
				return b, err
			}
			x.MQTTClient = tmp
		case "nonce":

			var tmp string
			tmp, v, err = cborReadStringBytes(v)
			if err != nil {
				return b, err
			}
			x.Nonce = tmp
		default:
			v, err = cborSkip(v)
			if err != nil {
				return b, err
			}
		}
		rest = v
	}
	return rest, nil
}

// DecodeTrusted decodes using zero-copy strings and no per-string UTF-8 validation.
func (x *ClientInfo) DecodeTrusted(b []byte) ([]byte, error) {
	if x == nil {
		return b, cborErrNotNil
	}
	sz, rest, err := cborReadMapHeaderBytes(b)
	if err != nil {
		return b, err
	}
	for i := uint32(0); i < sz; i++ {
		keyBytes, v, err := cborReadStringZC(rest)
		if err != nil {
			return b, err
		}
		key := cborUnsafeString(keyBytes)
		switch key {
		case "start":

			v, err = cborSkip(v)
			if err != nil {
				return b, err
			}
		case "host":

			var tmpBytes []byte
			tmpBytes, v, err = cborReadStringZC(v)
			if err != nil {
				return b, err
			}
			x.Host = cborUnsafeString(tmpBytes)
		case "id":

			var tmp uint64
			tmp, v, err = cborReadUint64Bytes(v)
			if err != nil {
				return b, err
			}
			x.ID = tmp
		case "acc":

			var tmpBytes []byte
			tmpBytes, v, err = cborReadStringZC(v)
			if err != nil {
				return b, err
			}
			x.Account = cborUnsafeString(tmpBytes)
		case "svc":

			var tmpBytes []byte
			tmpBytes, v, err = cborReadStringZC(v)
			if err != nil {
				return b, err
			}
			x.Service = cborUnsafeString(tmpBytes)
		case "user":

			var tmpBytes []byte
			tmpBytes, v, err = cborReadStringZC(v)
			if err != nil {
				return b, err
			}
			x.User = cborUnsafeString(tmpBytes)
		case "name":

			var tmpBytes []byte
			tmpBytes, v, err = cborReadStringZC(v)
			if err != nil {
				return b, err
			}
			x.Name = cborUnsafeString(tmpBytes)
		case "lang":

			var tmpBytes []byte
			tmpBytes, v, err = cborReadStringZC(v)
			if err != nil {
				return b, err
			}
			x.Lang = cborUnsafeString(tmpBytes)
		case "ver":

			var tmpBytes []byte
			tmpBytes, v, err = cborReadStringZC(v)
			if err != nil {
				return b, err
			}
			x.Version = cborUnsafeString(tmpBytes)
		case "rtt":

			var tmp time.Duration
			tmp, v, err = cborReadDurationBytes(v)
			if err != nil {
				return b, err
			}
			x.RTT = tmp
		case "server":

			var tmpBytes []byte
			tmpBytes, v, err = cborReadStringZC(v)
			if err != nil {
				return b, err
			}
			x.Server = cborUnsafeString(tmpBytes)
		case "cluster":

			var tmpBytes []byte
			tmpBytes, v, err = cborReadStringZC(v)
			if err != nil {
				return b, err
			}
			x.Cluster = cborUnsafeString(tmpBytes)
		case "alts":

			var sz uint32
			sz, v, err = cborReadArrayHeaderBytes(v)
			if err != nil {
				return b, err
			}
			if cap(x.Alternates) >= int(sz) {
				x.Alternates = x.Alternates[:sz]
			} else {
				x.Alternates = make([]string, sz)
			}
			if sz > 0 {
				_ = x.Alternates[sz-1]
			}
			for iAlternates := uint32(0); iAlternates < sz; iAlternates++ {
				var tmp string
				tmp, v, err = cborReadStringBytes(v)
				if err != nil {
					return b, err
				}
				x.Alternates[iAlternates] = tmp
			}
		case "stop":

			v, err = cborSkip(v)
			if err != nil {
				return b, err
			}
		case "jwt":

			var tmpBytes []byte
			tmpBytes, v, err = cborReadStringZC(v)
			if err != nil {
				return b, err
			}
			x.Jwt = cborUnsafeString(tmpBytes)
		case "issuer_key":

			var tmpBytes []byte
			tmpBytes, v, err = cborReadStringZC(v)
			if err != nil {
				return b, err
			}
			x.IssuerKey = cborUnsafeString(tmpBytes)
		case "name_tag":

			var tmpBytes []byte
			tmpBytes, v, err = cborReadStringZC(v)
			if err != nil {
				return b, err
			}
			x.NameTag = cborUnsafeString(tmpBytes)
		case "tags":

			v, err = cborSkip(v)
			if err != nil {
				return b, err
			}
		case "kind":

			var tmpBytes []byte
			tmpBytes, v, err = cborReadStringZC(v)
			if err != nil {
				return b, err
			}
			x.Kind = cborUnsafeString(tmpBytes)
		case "client_type":

			var tmpBytes []byte
			tmpBytes, v, err = cborReadStringZC(v)
			if err != nil {
				return b, err
			}
			x.ClientType = cborUnsafeString(tmpBytes)
		case "client_id":

			var tmpBytes []byte
			tmpBytes, v, err = cborReadStringZC(v)
			if err != nil {
				return b, err
			}
			x.MQTTClient = cborUnsafeString(tmpBytes)
		case "nonce":

			var tmpBytes []byte
			tmpBytes, v, err = cborReadStringZC(v)
			if err != nil {
				return b, err
			}
			x.Nonce = cborUnsafeString(tmpBytes)
		default:
			v, err = cborSkip(v)
			if err != nil {
				return b, err
			}
		}
		rest = v
	}
	return rest, nil
}

// UnmarshalCBOR implements cbor.Unmarshaler using the Safe path.
func (x *ClientInfo) UnmarshalCBOR(b []byte) ([]byte, error) {
	return x.DecodeSafe(b)
}
