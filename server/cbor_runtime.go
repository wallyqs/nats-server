// Code generated by cborgen runtime DO NOT EDIT.

package server

import (
	"io"
	"sync"

	// Local byte buffer pool under our control.
	//
	// Guidelines:
	// - Do not call Reset() before Put() unless you intend to reuse the buffer
	//   before putting it back. The pool does not require Reset() before Put().
	// - Use Ensure(n) to grow capacity up-front when you know you will append
	//   at least n more bytes. This avoids repeated reallocations.

	// GetByteBuffer obtains a pooled ByteBuffer. The buffer is Reset() before
	// being returned so length is zero (capacity may be reused).

	// GetMinSize obtains a pooled ByteBuffer with capacity for at least size bytes.
	// The buffer is Reset() and then grown if needed.
	"encoding/base64"
	"encoding/hex"
	"errors"
	"fmt"
	"math"
	"reflect"
	"strconv"
	"unicode/utf8"

	"encoding/json"

	"encoding/binary"
	"math/big"
	"math/bits"
	"regexp"
	"strings"
	"time"

	"bytes"
	bigmath "math/big"
	"unsafe"

	"sort"
)

type cborByteBuffer struct {
	b []byte
}

var cborbbPool = sync.Pool{New: func() any { return &cborByteBuffer{b: make([]byte, 0, 1024)} }}

func cborGetByteBuffer() *cborByteBuffer {
	bb := cborbbPool.Get().(*cborByteBuffer)
	bb.Reset()
	return bb
}

func cborGetMinSize(size int) *cborByteBuffer {
	bb := cborbbPool.Get().(*cborByteBuffer)
	bb.Reset()
	if size > 0 {
		bb.Ensure(size)
	}
	return bb
}

// PutByteBuffer returns the buffer to the pool. The content is left intact
// (no implicit Reset). Call Reset() yourself if you want to clear before reuse
// without returning to the pool.
// PutByteBuffer returns the buffer to the pool after Resetting length to zero.
func cborPutByteBuffer(bb *cborByteBuffer) { bb.Reset(); cborbbPool.Put(bb) }

// Bytes returns the underlying bytes.
func (bb *cborByteBuffer) Bytes() []byte { return bb.b }

// Len returns length.
func (bb *cborByteBuffer) Len() int { return len(bb.b) }

// Cap returns capacity.
func (bb *cborByteBuffer) Cap() int { return cap(bb.b) }

// Reset resets the length to zero; capacity is unchanged.
func (bb *cborByteBuffer) Reset() { bb.b = bb.b[:0] }

// Ensure ensures there is room for at least n more bytes without reallocation.
// If needed, it grows the underlying slice.
func (bb *cborByteBuffer) Ensure(n int) {
	need := len(bb.b) + n
	if cap(bb.b) >= need {
		return
	}
	// Grow: double until enough, then allocate
	c := cap(bb.b)
	if c == 0 {
		c = 1024
	}
	for c < need {
		c <<= 1
	}
	nb := make([]byte, len(bb.b), c)
	copy(nb, bb.b)
	bb.b = nb
}

// Extend grows the buffer by n bytes and returns a slice to the newly
// appended region for direct writes. The buffer length is advanced by n.
func (bb *cborByteBuffer) Extend(n int) []byte {
	old := len(bb.b)
	bb.Ensure(n)
	bb.b = bb.b[:old+n]
	return bb.b[old:]
}

// Write implements io.Writer.
func (bb *cborByteBuffer) Write(p []byte) (int, error) {
	bb.Ensure(len(p))
	bb.b = append(bb.b, p...)
	return len(p), nil
}

// WriteString appends a string.
func (bb *cborByteBuffer) WriteString(s string) (int, error) {
	bb.Ensure(len(s))
	bb.b = append(bb.b, s...)
	return len(s), nil
}

// WriteByte appends a single byte.
func (bb *cborByteBuffer) WriteByte(c byte) error {
	bb.Ensure(1)
	bb.b = append(bb.b, c)
	return nil
}

// ReadFrom implements io.ReaderFrom for efficient streaming into the buffer.
func (bb *cborByteBuffer) ReadFrom(r io.Reader) (int64, error) {
	var total int64
	for {
		// Grow a chunk (~32KB) if no free space
		if cap(bb.b)-len(bb.b) < 32*1024 {
			bb.Ensure(32 * 1024)
		}
		// Read into free tail
		n, err := r.Read(bb.b[len(bb.b):cap(bb.b)])
		if n > 0 {
			bb.b = bb.b[:len(bb.b)+n]
			total += int64(n)
		}
		if err != nil {
			if err == io.EOF {
				return total, nil
			}
			return total, err
		}
	}
}

// Convenience CBOR appenders on ByteBuffer
// These mirror the package-level AppendXxx functions but operate directly on
// the ByteBuffer, enabling a fluent, zero-alloc style when combined with
// upfront Ensure()/GetMinSize().

// This package is the support library for the cborp code generator.
//
// This package defines the utilities used by the cborp code generator for encoding and decoding CBOR
// from []byte and io.Reader/io.Writer types. Much of this package is devoted to helping the cborp code
// generator implement the Marshaler/Unmarshaler and Encodable/Decodable interfaces.
//
// This package defines four "families" of functions:
//   - AppendXxxx() appends an object to a []byte in CBOR encoding.
//   - ReadXxxxBytes() reads an object from a []byte and returns the remaining bytes.
//   - (*Writer).WriteXxxx() writes an object to the buffered *Writer type.
//   - (*Reader).ReadXxxx() reads an object from a buffered *Reader type.
//
// Once a type has satisfied the `Encodable` and `Decodable` interfaces,
// it can be written and read from arbitrary `io.Writer`s and `io.Reader`s using
//
//	cbor.Encode(io.Writer, cbor.Encodable)
//
// and
//
//	cbor.Decode(io.Reader, cbor.Decodable)

// RawPair represents an already-encoded CBOR key/value pair.
// Key and Value must each contain exactly one CBOR item.

// recursionLimit is the limit of recursive calls.
// This limits the call depth of dynamic code, like Skip and interface conversions.

// ErrNonCanonicalFloat is returned when a float is not encoded in the shortest form (strict mode).

// ErrContainerTooLarge is returned when a container length exceeds configured Reader limits.

// CBOR major types (3 bits)

// unsigned integer
// negative integer
// byte string
// text string (UTF-8)
// array
// map
// semantic tag
// float, simple values, break

// Additional info values (5 bits)

// 0-23: literal value
// max direct value
// 1-byte uint8 follows
// 2-byte uint16 follows
// 4-byte uint32 follows
// 8-byte uint64 follows
// indefinite length (for bytes, text, array, map)

// Simple values in major type 7

// Common CBOR semantic tags

// RFC3339 date/time string
// Unix timestamp (int or float)
// Positive bignum
// Negative bignum
// Decimal fraction
// Bigfloat
// Expected base64url encoding
// Expected base64 encoding
// Expected base16 encoding
// Embedded CBOR data item
// URI
// base64url
// base64
// Regular expression
// MIME message
// Self-describe CBOR (0xd9d9f7)

// makeByte creates a CBOR initial byte from major type and additional info

// getMajorType extracts the major type from a CBOR initial byte

func (bb *cborByteBuffer) AppendMapHeader(sz uint32) *

// getAddInfo extracts the additional info from a CBOR initial byte

cborByteBuffer {
	bb.b = cborAppendMapHeader(bb.b, sz)
	return bb
}

func (bb *cborByteBuffer) AppendArrayHeader(sz uint32) *

// Type represents CBOR data types

cborByteBuffer {
	bb.b = cborAppendArrayHeader(bb.

		// CBOR Types

		b, sz)
	return bb
}

func (bb *cborByteBuffer) AppendArrayHeaderIndefinite(

// text string

) *cborByteBuffer {

	// byte string

	bb.b = cborAppendArrayHeaderIndefinite(

		// map

		bb.b)
	return bb

	// array

}

func (bb *cborByteBuffer) AppendBreak(

// float64

) *cborByteBuffer {

	// float32

	bb.b = cborAppendBreak(

		// bool

		bb.b)
	return bb

	// signed integer

}

func (bb *cborByteBuffer) AppendString(

	// unsigned integer

	s string) *cborByteBuffer {

	// nil

	bb.b = cborAppendString(bb.

		// duration (encoded as int64)

		b, s)
	return bb
}

func (bb *cborByteBuffer) AppendBytes(

	// tagged value

	bs []byte) *cborByteBuffer {

	// time (tagged epoch timestamp)

	bb.b = cborAppendBytes(bb.b, bs)

	// String implements fmt.Stringer

	return bb
}

func (bb *cborByteBuffer) AppendInt64(i int64) *cborByteBuffer {
	bb.b = cborAppendInt64(bb.b, i)
	return bb
}

func (bb *cborByteBuffer) AppendUint64(u uint64) *cborByteBuffer {
	bb.b = cborAppendUint64(bb.b, u)
	return bb
}

func (bb *cborByteBuffer) AppendBool(v bool) *cborByteBuffer {
	bb.b = cborAppendBool(bb.b, v)
	return bb
}

func (bb *cborByteBuffer) AppendFloat64(f float64) *cborByteBuffer {
	bb.b = cborAppendFloat64(bb.b, f)
	return bb
}

func (bb *cborByteBuffer) AppendFloat32(f float32) *cborByteBuffer {
	bb.b = cborAppendFloat32(bb.b, f)

	// Marshaler is the interface implemented by types that know how to marshal
	// themselves as CBOR. MarshalCBOR appends the marshalled form to the provided
	// byte slice, returning the extended slice and any errors encountered.

	return bb
}

func (bb *cborByteBuffer) AppendTag(tag uint64) *cborByteBuffer {
	bb.b = cborAppendTag(bb.b, tag)
	return bb
}

type cborRawPair struct {
	Key   []byte
	Value []byte
}

const (
	cborrecursionLimit = 100000
)

var cborErrNonCanonicalFloat = errors.New("cbor: non-canonical float encoding")

var cborErrContainerTooLarge = errors.New("cbor: container too large")

const (
	cbormajorTypeUint   = 0
	cbormajorTypeNegInt = 1
	cbormajorTypeBytes  = 2
	cbormajorTypeText   = 3
	cbormajorTypeArray  = 4
	cbormajorTypeMap    = 5
	cbormajorTypeTag    = 6
	cbormajorTypeSimple = 7
)

const (
	cboraddInfoDirect     = 23
	cboraddInfoUint8      = 24
	cboraddInfoUint16     = 25
	cboraddInfoUint32     = 26
	cboraddInfoUint64     = 27
	cboraddInfoIndefinite = 31
)

const (
	cborsimpleFalse     = 20
	cborsimpleTrue      = 21
	cborsimpleNull      = 22
	cborsimpleUndefined = 23
	cborsimpleFloat16   = 25
	cborsimpleFloat32   = 26
	cborsimpleFloat64   = 27
	cborsimpleBreak     = 31
)

const (
	cbortagDateTimeString   = 0
	cbortagEpochDateTime    = 1
	cbortagPosBignum        = 2
	cbortagNegBignum        = 3
	cbortagDecimalFrac      = 4
	cbortagBigfloat         = 5
	cbortagBase64URL        = 21
	cbortagBase64           = 22
	cbortagBase16           = 23
	cbortagCBOR             = 24
	cbortagURI              = 32
	cbortagBase64URLString  = 33
	cbortagBase64String     = 34
	cbortagRegexp           = 35
	cbortagMIME             = 36
	cbortagSelfDescribeCBOR = 55799
)

func cbormakeByte(majorType, addInfo uint8) byte {
	return byte((majorType << 5) | addInfo)
}

func cborgetMajorType(b byte) uint8 {
	return (b >> 5) & 0x07
}

func cborgetAddInfo(b byte) uint8 {
	return b & 0x1f
}

type cborType byte

const (
	cborInvalidType cborType = iota

	cborStrType
	cborBinType
	cborMapType
	cborArrayType
	cborFloat64Type
	cborFloat32Type
	cborBoolType
	cborIntType
	cborUintType
	cborNilType
	cborDurationType
	cborExtensionType
	cborTimeType
)

func (t cborType) String() string {
	switch t {
	case cborStrType:
		return "str"
	case cborBinType:
		return "bin"
	case cborMapType:
		return "map"
	case cborArrayType:
		return "array"
	case cborFloat64Type:
		return "float64"
	case cborFloat32Type:
		return "float32"
	case cborBoolType:
		return "bool"
	case cborUintType:
		return "uint"
	case cborIntType:
		return "int"
	case cborExtensionType:
		return "ext"
	case cborNilType:
		return "nil"
	case cborTimeType:
		return "time"
	case cborDurationType:
		return "duration"
	default:
		return "<invalid>"
	}
}

type cborMarshaler interface {
	MarshalCBOR([]byte) ([]byte, error)
}

// Unmarshaler is the interface fulfilled by objects that know how to unmarshal
// themselves from CBOR. UnmarshalCBOR unmarshals the object from binary,
// returning any leftover bytes and any errors encountered.
type cborUnmarshaler interface {
	UnmarshalCBOR([]byte) ([]byte, error)
}

// ValidateUTF8OnDecode controls whether ReadStringBytes validates UTF-8.
// Enabled by default for spec compliance; can be disabled in hot paths.
var cborValidateUTF8OnDecode = true

// UnsafeStringDecode controls whether ReadStringBytes converts zero-copy using
// UnsafeString (unsafe) instead of allocating a new string. Disabled by default.
var cborUnsafeStringDecode = false

func cborDiagBytes(b []byte) (string, []byte, error) {
	bb := cborGetByteBuffer()
	defer cborPutByteBuffer(bb)
	rest, err := cbordiagOneBuf(bb, b, 0)
	if err != nil {
		return "", b, err
	}
	out := make([]byte, bb.Len())
	copy(out, bb.Bytes())
	return string(out), rest, nil
}

func cbordiagOneBuf(buf *cborByteBuffer, b []byte, depth int) ([]byte, error) {
	if depth > cborrecursionLimit {
		return b, cborErrMaxDepthExceeded
	}
	if len(b) < 1 {
		return b, cborErrShortBytes
	}
	maj := cborgetMajorType(b[0])
	add := cborgetAddInfo(b[0])

	switch maj {
	case cbormajorTypeUint:
		u, o, err := cborreadUintCore(b, cbormajorTypeUint)
		if err != nil {
			return b, err
		}
		buf.WriteString(strconv.FormatUint(u, 10))
		return o, nil
	case cbormajorTypeNegInt:
		u, o, err := cborreadUintCore(b, cbormajorTypeNegInt)
		if err != nil {
			return b, err
		}
		n := int64(-1) - int64(u)
		buf.WriteString(strconv.FormatInt(n, 10))
		return o, nil
	case cbormajorTypeBytes:
		if add == cboraddInfoIndefinite {
			p := b[1:]
			buf.WriteString("(_")
			first := true
			for {
				if len(p) < 1 {
					return b, cborErrShortBytes
				}
				if p[0] == cbormakeByte(cbormajorTypeSimple, cborsimpleBreak) {
					buf.WriteString(")")
					return p[1:], nil
				}
				sz, o, err := cborreadUintCore(p, cbormajorTypeBytes)
				if err != nil {
					return b, err
				}
				if uint64(len(o)) < sz {
					return b, cborErrShortBytes
				}
				if !first {
					buf.WriteString(", ")
				} else {
					buf.WriteString(" ")
					first = false
				}
				buf.WriteString("h'")
				d := buf.Extend(hex.EncodedLen(int(sz)))
				hex.Encode(d, o[:sz])
				buf.WriteString("'")
				p = o[sz:]
			}
		}
		bs, o, err := cborReadBytesBytes(b, nil)
		if err != nil {
			return b, err
		}
		buf.WriteString("h'")
		d := buf.Extend(hex.EncodedLen(len(bs)))
		hex.Encode(d, bs)
		buf.WriteString("'")
		return o, nil
	case cbormajorTypeText:
		if add == cboraddInfoIndefinite {
			p := b[1:]
			buf.WriteString("(_")
			first := true
			for {
				if len(p) < 1 {
					return b, cborErrShortBytes
				}
				if p[0] == cbormakeByte(cbormajorTypeSimple, cborsimpleBreak) {
					buf.WriteString(")")
					return p[1:], nil
				}
				chunk, o, err := cborReadStringZC(p)
				if err != nil {
					return b, err
				}
				q := strconv.Quote(string(chunk))
				if !first {
					buf.WriteString(", ")
				} else {
					buf.WriteString(" ")
					first = false
				}
				buf.WriteString(q)
				p = o
			}
		}
		s, o, err := cborReadStringBytes(b)
		if err != nil {
			return b, err
		}
		buf.WriteString(strconv.Quote(s))
		return o, nil
	case cbormajorTypeArray:
		if add == cboraddInfoIndefinite {
			p := b[1:]
			buf.WriteString("[_")
			first := true
			for {
				if len(p) < 1 {
					return b, cborErrShortBytes
				}
				if p[0] == cbormakeByte(cbormajorTypeSimple, cborsimpleBreak) {
					buf.WriteString("]")
					return p[1:], nil
				}
				if !first {
					buf.WriteString(", ")
				} else {
					buf.WriteString(" ")
					first = false
				}
				var err error
				p, err = cbordiagOneBuf(buf, p, depth+1)
				if err != nil {
					return b, err
				}
			}
		}
		sz, p, err := cborreadUintCore(b, cbormajorTypeArray)
		if err != nil {
			return b, err
		}
		buf.WriteString("[")
		for i := uint64(0); i < sz; i++ {
			if i > 0 {
				buf.WriteString(", ")
			}
			var err error
			p, err = cbordiagOneBuf(buf, p, depth+1)
			if err != nil {
				return b, err
			}
		}
		buf.WriteString("]")
		return p, nil
	case cbormajorTypeMap:
		if add == cboraddInfoIndefinite {
			p := b[1:]
			buf.WriteString("{_")
			first := true
			for {
				if len(p) < 1 {
					return b, cborErrShortBytes
				}
				if p[0] == cbormakeByte(cbormajorTypeSimple, cborsimpleBreak) {
					buf.WriteString("}")
					return p[1:], nil
				}
				if !first {
					buf.WriteString(", ")
				} else {
					buf.WriteString(" ")
					first = false
				}

				var err error
				p, err = cbordiagOneBuf(buf, p, depth+1)
				if err != nil {
					return b, err
				}
				buf.WriteString(": ")

				p, err = cbordiagOneBuf(buf, p, depth+1)
				if err != nil {
					return b, err
				}
			}
		}
		sz, p, err := cborreadUintCore(b, cbormajorTypeMap)
		if err != nil {
			return b, err
		}
		buf.WriteString("{")
		for i := uint64(0); i < sz; i++ {
			if i > 0 {
				buf.WriteString(", ")
			}
			var err error
			p, err = cbordiagOneBuf(buf, p, depth+1)
			if err != nil {
				return b, err
			}
			buf.WriteString(": ")
			p, err = cbordiagOneBuf(buf, p, depth+1)
			if err != nil {
				return b, err
			}
		}
		buf.WriteString("}")
		return p, nil
	case cbormajorTypeTag:
		tag, o, err := cborReadTagBytes(b)
		if err != nil {
			return b, err
		}
		buf.WriteString(strconv.FormatUint(tag, 10))
		buf.WriteString("(")
		o2, err := cbordiagOneBuf(buf, o, depth+1)
		if err != nil {
			return b, err
		}
		buf.WriteString(")")
		return o2, nil
	case cbormajorTypeSimple:
		switch add {
		case cborsimpleFalse:

			// (duplicate removed)

			// DiagBytes renders the next CBOR item in RFC diagnostic notation and returns the remaining bytes.

			// key

			// value

			// key

			// value

			buf.WriteString("false")
			return b[1:], nil
		case cborsimpleTrue:
			buf.WriteString("true")
			return b[1:], nil
		case cborsimpleNull:
			buf.WriteString("null")
			return b[1:], nil
		case cborsimpleUndefined:
			buf.WriteString("undefined")
			return b[1:], nil
		case cborsimpleFloat16:
			f, o, err := cborReadFloat16Bytes(b)
			if err != nil {
				return b, err
			}
			buf.WriteString(cborformatFloat32Diag(f))
			return o, nil
		case cborsimpleFloat32:
			f, o, err := cborReadFloat32Bytes(b)
			if err != nil {
				return b, err
			}
			buf.WriteString(cborformatFloat32Diag(f))
			return o, nil
		case cborsimpleFloat64:
			f, o, err := cborReadFloat64Bytes(b)
			if err != nil {
				return b, err
			}
			buf.WriteString(cborformatFloat64Diag(f))
			return o, nil
		default:
			if add < 20 {
				buf.WriteString(fmt.Sprintf("simple(%d)", add))
				return b[1:], nil
			}
			if add == cboraddInfoUint8 {
				if len(b) < 2 {
					return b, cborErrShortBytes
				}
				buf.WriteString(fmt.Sprintf("simple(%d)", b[1]))
				return b[2:], nil
			}
			return b, &cborErrUnsupportedType{}
		}
	}
	return b, &cborErrUnsupportedType{}
}

// formatFloat64Diag returns a diagnostic string for float64 matching RFC examples
func cborformatFloat64Diag(f float64) string {
	if math.IsInf(f, +1) {
		return "Infinity"
	}
	if math.IsInf(f, -1) {
		return "-Infinity"
	}
	if math.IsNaN(f) {
		return "NaN"
	}
	af := math.Abs(f)
	// Prefer fixed-point for reasonable magnitudes
	if af == 0 || af < 1e15 {
		s := strconv.FormatFloat(f, 'f', -1, 64)
		return cbortrimTrailingZerosDot(s)
	}
	return strconv.FormatFloat(f, 'g', -1, 64)
}

// formatFloat32Diag returns a diagnostic string for float32 matching RFC examples
func cborformatFloat32Diag(f float32) string {
	if math.IsInf(float64(f), +1) {
		return "Infinity"
	}
	if math.IsInf(float64(f), -1) {
		return "-Infinity"
	}
	if math.IsNaN(float64(f)) {
		return "NaN"
	}
	af := math.Abs(float64(f))
	if af == 0 || af < 1e15 {
		s := strconv.FormatFloat(float64(f), 'f', -1, 32)
		return cbortrimTrailingZerosDot(s)
	}
	return strconv.FormatFloat(float64(f), 'g', -1, 32)
}

func cbortrimTrailingZerosDot(s string) string {
	// Trim trailing zeros and optional dot

	// ErrShortBytes is returned when the
	// slice being decoded is too short to
	// contain the contents of the message

	// ErrRecursion is returned when the maximum recursion limit is reached for an operation.
	// This should only realistically be seen on adversarial data trying to exhaust the stack.

	// ErrLimitExceeded is returned when a set limit is exceeded.
	// Limits can be set on the Reader to prevent excessive memory usage by adversarial data.

	// ErrMaxDepthExceeded is returned when skip recursion depth exceeds limit

	// ErrNotNil is returned when expecting nil

	// ErrInvalidUTF8 is returned when a text string contains invalid UTF-8

	// ErrDuplicateMapKey is returned when a map contains duplicate keys where
	// duplicates are not allowed (e.g., deterministic/strict decoding).

	// ErrIndefiniteForbidden is returned when an indefinite-length item is present
	// but strict/deterministic decoding forbids it.

	// ErrNonCanonicalInteger is returned when an integer is not encoded in the shortest form.

	// ErrNonCanonicalLength is returned when a length (array/map/str/bytes) is not encoded in the shortest form.

	// Error is the interface satisfied
	// by all of the errors that originate
	// from this package.

	// Resumable returns whether
	// or not the error means that
	// the stream of data is malformed
	// and the information is unrecoverable.

	// contextError allows msgp Error instances to be enhanced with additional
	// context about their origin.

	// withContext must not modify the error instance - it must clone and
	// return a new error with the context added.

	// Cause returns the underlying cause of an error that has been wrapped
	// with additional context.

	// Resumable returns whether or not the error means that the stream of data is
	// malformed and the information is unrecoverable.

	// WrapError wraps an error with additional context that allows the part of the
	// serialized type that caused the problem to be identified. Underlying errors
	// can be retrieved using Cause()
	//
	// The input error is not modified - a new error should be returned.
	//
	// ErrShortBytes is not wrapped with any context due to backward compatibility
	// issues with the public API.

	// errWrapped allows arbitrary errors passed to WrapError to be enhanced with
	// context and unwrapped with Cause()

	// Unwrap returns the cause.

	// ArrayError is an error returned
	// when decoding a fix-sized array
	// of the wrong size

	// Error implements the error interface

	// Resumable is always 'true' for ArrayErrors

	// IntOverflow is returned when a call
	// would downcast an integer to a type
	// with too few bits to hold its value.

	// the value of the integer
	// the bit size that the int64 could not fit into

	// Error implements the error interface

	// Resumable is always 'true' for overflows

	// UintOverflow is returned when a call
	// would downcast an unsigned integer to a type
	// with too few bits to hold its value

	// value of the uint
	// the bit size that couldn't fit the value

	// Error implements the error interface

	// Resumable is always 'true' for overflows

	// InvalidTimestamp is returned when an invalid timestamp is encountered

	// value of the nano, if invalid
	// Unexpected field length.

	// Error implements the error interface

	// Resumable is always 'true' for overflows

	// UintBelowZero is returned when a call
	// would cast a signed integer below zero
	// to an unsigned integer.

	// value of the incoming int

	// Error implements the error interface

	// Resumable is always 'true' for overflows

	// A TypeError is returned when a particular
	// decoding method is unsuitable for decoding
	// a particular MessagePack value.

	// Type expected by method
	// Type actually encoded
	i := len(s)
	for i > 0 && s[i-1] ==

		// Error implements the error interface
		'0' {
		i--
	}
	if i > 0 && s[i-1] == '.' {
		i--
	}
	return s[:i]
}

const cborresumableDefault = false

var (
	cborErrShortBytes error = cborerrShort{}

	cborErrRecursion error = cborerrRecursion{}

	cborErrLimitExceeded error = cborerrLimitExceeded{}

	cborErrMaxDepthExceeded error = errors.New("cbor: max depth exceeded")

	cborErrNotNil error = errors.New("cbor: not nil")

	cborErrInvalidUTF8 error = errors.New("cbor: invalid UTF-8 in text string")

	cborErrDuplicateMapKey error = errors.New("cbor: duplicate map key")

	cborErrIndefiniteForbidden error = errors.New("cbor: indefinite-length item not allowed in strict/deterministic mode")

	cborErrNonCanonicalInteger error = errors.New("cbor: non-canonical integer encoding")

	cborErrNonCanonicalLength error = errors.New("cbor: non-canonical length encoding")
)

type cborError interface {
	error

	Resumable() bool
}

type cborcontextError interface {
	cborError

	withContext(ctx string) error
}

func cborCause(e error) error {
	out := e
	if e, ok := e.(cborerrWrapped); ok && e.cause != nil {
		out = e.cause
	}
	return out
}

func cborResumable(e error) bool {
	if e, ok := e.(cborError); ok {
		return e.Resumable()
	}
	return cborresumableDefault
}

func cborWrapError(err error, ctx ...any) error {
	switch e := err.(type) {
	case cborerrShort:
		return e
	case cborcontextError:
		return e.withContext(cborctxString(ctx))
	default:
		return cborerrWrapped{cause: err, ctx: cborctxString(ctx)}
	}
}

func cboraddCtx(ctx, add string) string {
	if ctx != "" {
		return add + "/" + ctx
	} else {
		return add
	}
}

type cborerrWrapped struct {
	cause error
	ctx   string
}

func (e cborerrWrapped) Error() string {
	if e.ctx != "" {
		return e.cause.Error() + " at " + e.ctx
	} else {
		return e.cause.Error()
	}
}

func (e cborerrWrapped) Resumable() bool {
	if e, ok := e.cause.(cborError); ok {
		return e.Resumable()
	}
	return cborresumableDefault
}

func (e cborerrWrapped) Unwrap() error { return e.cause }

type cborerrShort struct{}

func (e cborerrShort) Error() string   { return "cbor: too few bytes left to read object" }
func (e cborerrShort) Resumable() bool { return false }

type cborerrRecursion struct{}

func (e cborerrRecursion) Error() string   { return "cbor: recursion limit reached" }
func (e cborerrRecursion) Resumable() bool { return false }

type cborerrLimitExceeded struct{}

func (e cborerrLimitExceeded) Error() string   { return "cbor: configured reader limit exceeded" }
func (e cborerrLimitExceeded) Resumable() bool { return false }

type cborArrayError struct {
	Wanted uint32
	Got    uint32
	ctx    string
}

func (a cborArrayError) Error() string {
	out := "cbor: wanted array of size " + strconv.Itoa(int(a.Wanted)) + "; got " + strconv.Itoa(int(a.Got))
	if a.ctx != "" {
		out += " at " + a.ctx
	}
	return out
}

func (a cborArrayError) Resumable() bool { return true }

func (a cborArrayError) withContext(ctx string) error { a.ctx = cboraddCtx(a.ctx, ctx); return a }

type cborIntOverflow struct {
	Value         int64
	FailedBitsize int
	ctx           string
}

func (i cborIntOverflow) Error() string {
	str := "cbor: " + strconv.FormatInt(i.Value, 10) + " overflows int" + strconv.Itoa(i.FailedBitsize)
	if i.ctx != "" {
		str += " at " + i.ctx
	}
	return str
}

func (i cborIntOverflow) Resumable() bool { return true }

func (i cborIntOverflow) withContext(ctx string) error { i.ctx = cboraddCtx(i.ctx, ctx); return i }

type cborUintOverflow struct {
	Value         uint64
	FailedBitsize int
	ctx           string
}

func (u cborUintOverflow) Error() string {
	str := "cbor: " + strconv.FormatUint(u.Value, 10) + " overflows uint" + strconv.Itoa(u.FailedBitsize)
	if u.ctx != "" {
		str += " at " + u.ctx
	}
	return str
}

func (u cborUintOverflow) Resumable() bool { return true }

func (u cborUintOverflow) withContext(ctx string) error { u.ctx = cboraddCtx(u.ctx, ctx); return u }

type cborInvalidTimestamp struct {
	Nanos       int64
	FieldLength int
	ctx         string
}

func (u cborInvalidTimestamp) Error() (str string) {
	if u.Nanos > 0 {
		str = "msgp: timestamp nanosecond field value " + strconv.FormatInt(u.Nanos, 10) + " exceeds maximum allows of 999999999"
	} else if u.FieldLength >= 0 {
		str = "msgp: invalid timestamp field length " + strconv.FormatInt(int64(u.FieldLength), 10) + " - must be 4, 8 or 12"
	}
	if u.ctx != "" {
		str += " at " + u.ctx
	}
	return str
}

func (u cborInvalidTimestamp) Resumable() bool { return true }

func (u cborInvalidTimestamp) withContext(ctx string) error { u.ctx = cboraddCtx(u.ctx, ctx); return u }

type cborUintBelowZero struct {
	Value int64
	ctx   string
}

func (u cborUintBelowZero) Error() string {
	str := "cbor: attempted to cast int " + strconv.FormatInt(u.Value, 10) + " to unsigned"
	if u.ctx != "" {
		str += " at " + u.ctx
	}
	return str
}

func (u cborUintBelowZero) Resumable() bool { return true }

func (u cborUintBelowZero) withContext(ctx string) error {
	u.ctx = ctx
	return u
}

type cborTypeError struct {
	Method  cborType
	Encoded cborType

	ctx string
}

func (t cborTypeError) Error() string {
	out := "cbor: attempted to decode type " + cborquoteStr(t.Encoded.String()) + " with method for " + cborquoteStr(t.Method.String())
	if t.ctx != "" {
		out += " at " + t.ctx
	}
	return out
}

// Resumable returns 'true' for TypeErrors
func (t cborTypeError) Resumable() bool { return true }

func (t cborTypeError) withContext(ctx string) error { t.ctx = cboraddCtx(t.ctx, ctx); return t }

// returns either InvalidPrefixError or
// TypeError depending on whether or not
// the prefix is recognized
func cborbadPrefix(wantMajor uint8, gotMajor uint8) error {
	return cborInvalidPrefixError{Want: wantMajor, Got: gotMajor}
}

// InvalidPrefixError is returned when a bad encoding
// uses a major type that is not expected.
// This kind of error is unrecoverable.
type cborInvalidPrefixError struct {
	Want uint8
	Got  uint8
}

// Error implements the error interface
func (i cborInvalidPrefixError) Error() string {
	return "cbor: expected major type " + strconv.Itoa(int(i.Want)) + " but got " + strconv.Itoa(int(i.Got))
}

// Resumable returns 'false' for InvalidPrefixErrors
func (i cborInvalidPrefixError) Resumable() bool { return false }

// ErrUnsupportedType is returned when a bad argument is supplied to
// a function that accepts arbitrary values.
type cborErrUnsupportedType struct {
	T reflect.Type

	ctx string
}

// Error implements error
func (e *cborErrUnsupportedType) Error() string {
	out := "cbor: type " + cborquoteStr(e.T.String()) + " not supported"
	if e.ctx != "" {
		out += " at " + e.ctx
	}
	return out
}

// Resumable returns 'true' for ErrUnsupportedType

// ctxString converts the incoming context slice into a single string.

// getType returns the CBOR type from a byte

// NextType returns the type of the next object in the slice

// Require ensures that b has capacity for at least n additional bytes
// without reallocation. It returns a slice that shares the original
// contents and has sufficient capacity for appending n bytes.

// IsLikelyJSON reports whether the given byte slice looks like JSON text
// rather than CBOR. It is a heuristic and not a formal discriminator:
//
//   - It requires the data to be valid UTF-8.
//   - It then checks the first non-whitespace byte against the JSON
//     value grammar (object/array/string/number/true/false/null).
//
// Most CBOR payloads will fail one of these checks (non-UTF-8 or
// invalid JSON starter) and thus be classified as non-JSON.

// Require valid UTF-8 for JSON.

// Skip leading ASCII whitespace.

// Valid JSON value starters:
//  - object/array: '{', '['
//  - string: '"'
//  - number: '-', '0'..'9'
//  - true/false/null: 't', 'f', 'n'

// FromJSONBytes converts a JSON document into CBOR bytes using a
// wrapper convention similar to RFC examples and the prototype:
//
//  - null/bool/number/string/array/object map naturally to CBOR
//    nil/bool/float-or-int/text/array/map.
//  - Wrapper objects are recognized and mapped to semantic tags:
//      {"$rfc3339": string}         -> tag(0) RFC3339 time string
//      {"$epoch": number}           -> tag(1) epoch seconds (int or float)
//      {"$decimal":[exp, mant]}     -> tag(4)
//      {"$bigfloat":[exp, mant]}    -> tag(5)
//      {"$base64url": string}       -> tag(21) bytes (base64url)
//      {"$base64": string}          -> tag(22) bytes (base64 std)
//      {"$base16": string}          -> tag(23) bytes (hex)
//      {"$cbor": string}            -> tag(24) embedded CBOR (base64)
//      {"$uri": string}             -> tag(32) URI (text)
//      {"$base64urlstr": string}    -> tag(33) text
//      {"$base64str": string}       -> tag(34) text
//      {"$regex": string}           -> tag(35) regex (text)
//      {"$mime": string}            -> tag(36) MIME (text)
//      {"$uuid": string}            -> tag(37) UUID (canonical hyphenated)
//      {"$selfdescribe": true}      -> tag(55799)
//      {"$tag":N, "$":value}       -> generic tag N

// Prefer integers when possible, otherwise float64.

// Wrapper detection

// Plain object

// Generic {"$tag":N, "$":value}

// $rfc3339

// $epoch

// Accept json.Number, float64, or integer-like

// $decimal

// $bigfloat

// $base64url -> tagBase64URL

// $base64 -> tagBase64

// $base16 -> tagBase16

// $cbor -> embedded CBOR (tag24)

// $uri

// $base64urlstr

// $base64str

// $regex

// $mime

// $uuid

// 8-4-4-4-12

// $selfdescribe

// ToJSONBytes converts the next CBOR item into a JSON encoding and
// returns the JSON bytes and remainder. It follows a similar mapping
// as FromJSONBytes, including unwrapping common semantic tags into
// wrapper objects where appropriate.

// base64-encode byte strings

// key must be JSON string; try fast path

// fallback: use diagnostic notation as key

// 0

// 1

// 2/3

// 4 -> {"$decimal":[exp, mant]}

// 5 -> {"$bigfloat":[exp, mant]}

// 21 -> {"$base64url":"..."}

// 22 -> {"$base64":"..."}

// 23 -> {"$base16":"..."}

// 24 embedded CBOR -> {"$cbor":"..."}

// 32 -> plain JSON string

// 33 -> {"$base64urlstr":string}

// 34 -> {"$base64str":string}

// 35 -> {"$regex":string}

// 36 -> {"$mime":string}

// UUID -> {"$uuid":"..."}

// 55799 -> {"$selfdescribe":true}

// Generic: {"$tag":N, "$": value}

// application-defined simple value; map to null in JSON by default

// unassigned simple values -> null
func (e *cborErrUnsupportedType) Resumable() bool { return true }

func (e *cborErrUnsupportedType) withContext(ctx string) error {
	o :=

		// encodeBase64Std writes standard base64 of src into buf.
		*e
	o.ctx = cboraddCtx(o.ctx, ctx)
	return &o
}

func cborctxString(ctx []any) string {
	out := ""
	for idx, cv := range ctx {
		if idx > 0 {
			out += "/"
		}
		out += fmt.Sprintf("%v", cv)
	}
	return out
}

func cborquoteStr(s string) string {
	return strconv.Quote(s)
}

func cborgetType(b byte) cborType {
	major := cborgetMajorType(b)
	switch major {
	case cbormajorTypeUint:
		return cborUintType
	case cbormajorTypeNegInt:
		return cborIntType
	case cbormajorTypeBytes:
		return cborBinType
	case cbormajorTypeText:
		return cborStrType
	case cbormajorTypeArray:
		return cborArrayType
	case cbormajorTypeMap:
		return cborMapType
	case cbormajorTypeTag:
		return cborExtensionType
	case cbormajorTypeSimple:
		addInfo := cborgetAddInfo(b)
		switch addInfo {
		case cborsimpleTrue, cborsimpleFalse:
			return cborBoolType
		case cborsimpleNull:
			return cborNilType
		case cborsimpleFloat32, cborsimpleFloat64:
			return cborFloat64Type
		}
	}
	return cborInvalidType
}

func cborNextType(b []byte) cborType {
	if len(b) == 0 {
		return cborInvalidType
	}
	return cborgetType(b[0])
}

func cborRequire(b []byte, n int) []byte {
	if cap(b)-len(b) >= n {
		return b
	}
	nb := make([]byte, len(b), len(b)+n)
	copy(nb, b)
	return nb
}

func cborIsLikelyJSON(b []byte) bool {

	if !utf8.Valid(b) {
		return false
	}

	i := 0
	for i < len(b) {
		c := b[i]
		if c == ' ' || c == '\n' || c == '\r' || c == '\t' {
			i++
			continue
		}
		break
	}
	if i >= len(b) {
		return false
	}
	ch := b[i]

	if ch == '{' || ch == '[' || ch == '"' || ch == '-' {
		return true
	}
	if ch >= '0' && ch <= '9' {
		return true
	}
	if ch == 't' || ch == 'f' || ch == 'n' {
		return true
	}
	return false
}

func cborFromJSONBytes(js []byte) ([]byte, error) {
	dec := json.NewDecoder(strings.NewReader(string(js)))
	dec.UseNumber()
	var v any
	if err := dec.Decode(&v); err != nil {
		return nil, err
	}
	return cborjsonToCBOR(nil, v)
}

func cborjsonToCBOR(b []byte, v any) ([]byte, error) {
	switch x := v.(type) {
	case nil:
		return cborAppendNil(b), nil
	case bool:
		return cborAppendBool(b, x), nil
	case json.Number:

		if strings.ContainsAny(string(x), ".eE") {
			f, err := x.Float64()
			if err != nil {
				return b, err
			}
			return cborAppendFloat64(b, f), nil
		}
		if i, err := x.Int64(); err == nil {
			return cborAppendInt64(b, i), nil
		}
		f, err := x.Float64()
		if err != nil {
			return b, err
		}
		return cborAppendFloat64(b, f), nil
	case float64:
		return cborAppendFloat64(b, x), nil
	case string:
		return cborAppendString(b, x), nil
	case []any:
		b = cborAppendArrayHeader(b, uint32(len(x)))
		var err error
		for _, e := range x {
			b, err = cborjsonToCBOR(b, e)
			if err != nil {
				return b, err
			}
		}
		return b, nil
	case map[string]any:

		if out, ok, err := cbortryWrapper(b, x); ok || err != nil {
			return out, err
		}

		b = cborAppendMapHeader(b, uint32(len(x)))
		var err error
		for k, vv := range x {
			b = cborAppendString(b, k)
			b, err = cborjsonToCBOR(b, vv)
			if err != nil {
				return b, err
			}
		}
		return b, nil
	default:
		return b, &cborErrUnsupportedType{}
	}
}

func cbortryWrapper(b []byte, m map[string]any) ([]byte, bool, error) {

	if tagv, ok := m["$tag"]; ok {
		iv, ok2 := m["$"]
		if !ok2 {
			return b, true, errors.New("cbor: $tag wrapper missing $ field")
		}
		tag, err := cbornumToUint64(tagv)
		if err != nil {
			return b, true, err
		}
		inner, err := cborjsonToCBOR(nil, iv)
		if err != nil {
			return b, true, err
		}
		return cborAppendTagged(b, tag, inner), true, nil
	}

	if v, ok := m["$rfc3339"]; ok {
		s, _ := v.(string)
		if s == "" {
			return b, true, errors.New("cbor: $rfc3339 expects string")
		}
		t, err := time.Parse(time.RFC3339Nano, s)
		if err != nil {
			return b, true, err
		}
		return cborAppendRFC3339Time(b, t), true, nil
	}

	if v, ok := m["$epoch"]; ok {

		var f float64
		switch vv := v.(type) {
		case json.Number:
			ff, err := vv.Float64()
			if err != nil {
				return b, true, err
			}
			f = ff
		case float64:
			f = vv
		case int64:
			f = float64(vv)
		default:
			return b, true, errors.New("cbor: $epoch expects number")
		}
		sec := cbormathFloor(f)
		ns := int64(cbormathRound((f - float64(sec)) * 1e9))
		secs := int64(sec)
		if ns >= 1e9 {
			secs++
			ns -= 1e9
		}
		t := time.Unix(secs, ns).UTC()
		return cborAppendTime(b, t), true, nil
	}

	if v, ok := m["$decimal"]; ok {
		arr, ok := v.([]any)
		if !ok || len(arr) != 2 {
			return b, true, errors.New("cbor: $decimal expects [exp, mant]")
		}
		exp, err := cboranyToInt64(arr[0])
		if err != nil {
			return b, true, err
		}
		mantStr, ok := arr[1].(string)
		if !ok {
			return b, true, errors.New("cbor: $decimal mantissa must be string")
		}
		z, ok := new(big.Int).SetString(mantStr, 10)
		if !ok {
			return b, true, errors.New("cbor: invalid $decimal mantissa")
		}
		return cborAppendDecimalFraction(b, exp, z), true, nil
	}

	if v, ok := m["$bigfloat"]; ok {
		arr, ok := v.([]any)
		if !ok || len(arr) != 2 {
			return b, true, errors.New("cbor: $bigfloat expects [exp, mant]")
		}
		exp, err := cboranyToInt64(arr[0])
		if err != nil {
			return b, true, err
		}
		mantStr, ok := arr[1].(string)
		if !ok {
			return b, true, errors.New("cbor: $bigfloat mantissa must be string")
		}
		z, ok := new(big.Int).SetString(mantStr, 10)
		if !ok {
			return b, true, errors.New("cbor: invalid $bigfloat mantissa")
		}
		return cborAppendBigfloat(b, exp, z), true, nil
	}

	if v, ok := m["$base64url"]; ok {
		s, _ := v.(string)
		bs, err := base64.RawURLEncoding.DecodeString(s)
		if err != nil {
			return b, true, err
		}
		return cborAppendBase64URL(b, bs), true, nil
	}

	if v, ok := m["$base64"]; ok {
		s, _ := v.(string)
		bs, err := base64.StdEncoding.DecodeString(s)
		if err != nil {
			return b, true, err
		}
		return cborAppendBase64(b, bs), true, nil
	}

	if v, ok := m["$base16"]; ok {
		s, _ := v.(string)
		bs, err := hex.DecodeString(s)
		if err != nil {
			return b, true, err
		}
		return cborAppendBase16(b, bs), true, nil
	}

	if v, ok := m["$cbor"]; ok {
		s, _ := v.(string)
		bs, err := base64.StdEncoding.DecodeString(s)
		if err != nil {
			return b, true, err
		}
		return cborAppendEmbeddedCBOR(b, bs), true, nil
	}

	if v, ok := m["$uri"]; ok {
		s, _ := v.(string)
		if s == "" {
			return b, true, errors.New("cbor: $uri expects string")
		}
		return cborAppendURI(b, s), true, nil
	}

	if v, ok := m["$base64urlstr"]; ok {
		s, _ := v.(string)
		return cborAppendBase64URLString(b, s), true, nil
	}

	if v, ok := m["$base64str"]; ok {
		s, _ := v.(string)
		return cborAppendBase64String(b, s), true, nil
	}

	if v, ok := m["$regex"]; ok {
		s, _ := v.(string)
		if s == "" {
			return b, true, errors.New("cbor: $regex expects string")
		}
		if _, err := regexp.Compile(s); err != nil {
			return b, true, err
		}
		return cborAppendRegexpString(b, s), true, nil
	}

	if v, ok := m["$mime"]; ok {
		s, _ := v.(string)
		if s == "" {
			return b, true, errors.New("cbor: $mime expects string")
		}
		return cborAppendMIMEString(b, s), true, nil
	}

	if v, ok := m["$uuid"]; ok {
		s, _ := v.(string)
		if len(s) != 36 {
			return b, true, errors.New("cbor: $uuid expects canonical string")
		}
		hexStr := strings.ReplaceAll(s, "-", "")
		bs, err := hex.DecodeString(hexStr)
		if err != nil || len(bs) != 16 {
			return b, true, errors.New("cbor: invalid $uuid")
		}
		var u [16]byte
		copy(u[:], bs)
		return cborAppendUUID(b, u), true, nil
	}

	if v, ok := m["$selfdescribe"]; ok {
		bval, _ := v.(bool)
		if !bval {
			return b, true, errors.New("cbor: $selfdescribe expects true")
		}
		return cborAppendSelfDescribeCBOR(b), true, nil
	}
	return b, false, nil
}

func cbornumToUint64(v any) (uint64, error) {
	switch t := v.(type) {
	case json.Number:
		if strings.ContainsAny(string(t), ".eE") {
			f, err := t.Float64()
			if err != nil {
				return 0, err
			}
			if f < 0 {
				return 0, errors.New("cbor: negative tag")
			}
			return uint64(f), nil
		}
		i, err := t.Int64()
		if err != nil {
			return 0, err
		}
		if i < 0 {
			return 0, errors.New("cbor: negative tag")
		}
		return uint64(i), nil
	case float64:
		if t < 0 {
			return 0, errors.New("cbor: negative tag")
		}
		return uint64(t), nil
	case int64:
		if t < 0 {
			return 0, errors.New("cbor: negative tag")
		}
		return uint64(t), nil
	case int:
		if t < 0 {
			return 0, errors.New("cbor: negative tag")
		}
		return uint64(t), nil
	default:
		return 0, errors.New("cbor: expected numeric tag")
	}
}

func cboranyToInt64(v any) (int64, error) {
	switch t := v.(type) {
	case json.Number:
		i, err := t.Int64()
		if err != nil {
			return 0, err
		}
		return i, nil
	case float64:
		return int64(t), nil
	case int64:
		return t, nil
	case int:
		return int64(t), nil
	default:
		return 0, errors.New("cbor: expected integer")
	}
}

func cbormathFloor(f float64) float64 {
	if f >= 0 {
		return float64(int64(f))
	}
	if float64(int64(f)) == f {
		return f
	}
	return float64(int64(f) - 1)
}

func cbormathRound(f float64) float64 {
	if f >= 0 {
		return float64(int64(f + 0.5))
	}
	return float64(int64(f - 0.5))
}

func cborToJSONBytes(b []byte) ([]byte, []byte, error) {
	bb := cborGetByteBuffer()
	defer cborPutByteBuffer(bb)
	rest, err := cbortoJSON(bb, b, 0)
	if err != nil {
		return nil, b, err
	}
	out := make([]byte, bb.Len())
	copy(out, bb.Bytes())
	return out, rest, nil
}

func cbortoJSON(buf *cborByteBuffer, b []byte, depth int) ([]byte, error) {
	if depth > cborrecursionLimit {
		return b, cborErrMaxDepthExceeded
	}
	if len(b) < 1 {
		return b, cborErrShortBytes
	}
	maj := cborgetMajorType(b[0])
	add := cborgetAddInfo(b[0])

	switch maj {
	case cbormajorTypeUint:
		u, o, err := cborreadUintCore(b, cbormajorTypeUint)
		if err != nil {
			return b, err
		}
		buf.WriteString(strconv.FormatUint(u, 10))
		return o, nil
	case cbormajorTypeNegInt:
		u, o, err := cborreadUintCore(b, cbormajorTypeNegInt)
		if err != nil {
			return b, err
		}
		n := int64(-1) - int64(u)
		buf.WriteString(strconv.FormatInt(n, 10))
		return o, nil
	case cbormajorTypeBytes:
		bs, o, err := cborReadBytesBytes(b, nil)
		if err != nil {
			return b, err
		}

		buf.WriteString("\"")
		cborencodeBase64Std(buf, bs)
		buf.WriteString("\"")
		return o, nil
	case cbormajorTypeText:
		s, o, err := cborReadStringBytes(b)
		if err != nil {
			return b, err
		}
		js, _ := json.Marshal(s)
		buf.Write(js)
		return o, nil
	case cbormajorTypeArray:
		if add == cboraddInfoIndefinite {
			buf.WriteString("[")
			p := b[1:]
			first := true
			for {
				if len(p) < 1 {
					return b, cborErrShortBytes
				}
				if p[0] == cbormakeByte(cbormajorTypeSimple, cborsimpleBreak) {
					buf.WriteString("]")
					return p[1:], nil
				}
				if !first {
					buf.WriteString(",")
				} else {
					first = false
				}
				var err error
				p, err = cbortoJSON(buf, p, depth+1)
				if err != nil {
					return b, err
				}
			}
		}
		sz, p, err := cborreadUintCore(b, cbormajorTypeArray)
		if err != nil {
			return b, err
		}
		buf.WriteString("[")
		for i := uint64(0); i < sz; i++ {
			if i > 0 {
				buf.WriteString(",")
			}
			var err error
			p, err = cbortoJSON(buf, p, depth+1)
			if err != nil {
				return b, err
			}
		}
		buf.WriteString("]")
		return p, nil
	case cbormajorTypeMap:
		if add == cboraddInfoIndefinite {
			buf.WriteString("{")
			p := b[1:]
			first := true
			for {
				if len(p) < 1 {
					return b, cborErrShortBytes
				}
				if p[0] == cbormakeByte(cbormajorTypeSimple, cborsimpleBreak) {
					buf.WriteString("}")
					return p[1:], nil
				}

				if cborgetMajorType(p[0]) == cbormajorTypeText {
					k, o, err := cborReadStringBytes(p)
					if err != nil {
						return b, err
					}
					if !first {
						buf.WriteString(",")
					} else {
						first = false
					}
					kj, _ := json.Marshal(k)
					buf.Write(kj)
					buf.WriteString(":")
					var err2 error
					p, err2 = cbortoJSON(buf, o, depth+1)
					if err2 != nil {
						return b, err2
					}
				} else {

					ks, o, err := cborDiagBytes(p)
					if err != nil {
						return b, err
					}
					if !first {
						buf.WriteString(",")
					} else {
						first = false
					}
					kj, _ := json.Marshal(ks)
					buf.Write(kj)
					buf.WriteString(":")
					var err2 error
					p, err2 = cbortoJSON(buf, o, depth+1)
					if err2 != nil {
						return b, err2
					}
				}
			}
		}
		sz, p, err := cborreadUintCore(b, cbormajorTypeMap)
		if err != nil {
			return b, err
		}
		buf.WriteString("{")
		for i := uint64(0); i < sz; i++ {
			if i > 0 {
				buf.WriteString(",")
			}
			if cborgetMajorType(p[0]) == cbormajorTypeText {
				k, o, err := cborReadStringBytes(p)
				if err != nil {
					return b, err
				}
				kj, _ := json.Marshal(k)
				buf.Write(kj)
				buf.WriteString(":")
				var err2 error
				p, err2 = cbortoJSON(buf, o, depth+1)
				if err2 != nil {
					return b, err2
				}
			} else {
				ks, o, err := cborDiagBytes(p)
				if err != nil {
					return b, err
				}
				kj, _ := json.Marshal(ks)
				buf.Write(kj)
				buf.WriteString(":")
				var err2 error
				p, err2 = cbortoJSON(buf, o, depth+1)
				if err2 != nil {
					return b, err2
				}
			}
		}
		buf.WriteString("}")
		return p, nil
	case cbormajorTypeTag:
		tag, o, err := cborReadTagBytes(b)
		if err != nil {
			return b, err
		}
		switch tag {
		case cbortagDateTimeString:
			tm, rest, err := cborReadRFC3339TimeBytes(b)
			if err != nil {
				return b, err
			}
			js, _ := json.Marshal(tm.Format(time.RFC3339Nano))
			buf.Write(js)
			return rest, nil
		case cbortagEpochDateTime:
			tm, rest, err := cborReadTimeBytes(b)
			if err != nil {
				return b, err
			}
			js, _ := json.Marshal(tm.Format(time.RFC3339Nano))
			buf.Write(js)
			return rest, nil
		case cbortagPosBignum, cbortagNegBignum:
			z, rest, err := cborReadBigIntBytes(b)
			if err != nil {
				return b, err
			}
			js, _ := json.Marshal(z.String())
			buf.Write(js)
			return rest, nil
		case cbortagDecimalFrac:
			exp, mant, rest, err := cborReadDecimalFractionBytes(b)
			if err != nil {
				return b, err
			}
			buf.WriteString(`{"$decimal":[`)
			buf.WriteString(strconv.FormatInt(exp, 10))
			buf.WriteString(",")
			ms, _ := json.Marshal(mant.String())
			buf.Write(ms)
			buf.WriteString("]}")
			return rest, nil
		case cbortagBigfloat:
			exp, mant, rest, err := cborReadBigfloatBytes(b)
			if err != nil {
				return b, err
			}
			buf.WriteString(`{"$bigfloat":[`)
			buf.WriteString(strconv.FormatInt(exp, 10))
			buf.WriteString(",")
			ms, _ := json.Marshal(mant.String())
			buf.Write(ms)
			buf.WriteString("]}")
			return rest, nil
		case cbortagBase64URL:
			bs, rest, err := cborReadBase64URLBytes(b)
			if err != nil {
				return b, err
			}
			buf.WriteString(`{"$base64url":"`)
			cborencodeBase64RawURL(buf, bs)
			buf.WriteString(`"}`)
			return rest, nil
		case cbortagBase64:
			bs, rest, err := cborReadBase64Bytes(b)
			if err != nil {
				return b, err
			}
			buf.WriteString(`{"$base64":"`)
			cborencodeBase64Std(buf, bs)
			buf.WriteString(`"}`)
			return rest, nil
		case cbortagBase16:
			bs, rest, err := cborReadBase16Bytes(b)
			if err != nil {
				return b, err
			}
			buf.WriteString(`{"$base16":"`)
			d := buf.Extend(hex.EncodedLen(len(bs)))
			hex.Encode(d, bs)
			buf.WriteString(`"}`)
			return rest, nil
		case cbortagCBOR:
			payload, rest, err := cborReadEmbeddedCBORBytes(b)
			if err != nil {
				return b, err
			}
			buf.WriteString(`{"$cbor":"`)
			cborencodeBase64Std(buf, payload)
			buf.WriteString(`"}`)
			return rest, nil
		case cbortagURI:
			s, rest, err := cborReadURIStringBytes(b)
			if err != nil {
				return b, err
			}
			js, _ := json.Marshal(s)
			buf.Write(js)
			return rest, nil
		case cbortagBase64URLString:
			s, rest, err := cborReadBase64URLStringBytes(b)
			if err != nil {
				return b, err
			}
			buf.WriteString(`{"$base64urlstr":`)
			js, _ := json.Marshal(s)
			buf.Write(js)
			buf.WriteString("}")
			return rest, nil
		case cbortagBase64String:
			s, rest, err := cborReadBase64StringBytes(b)
			if err != nil {
				return b, err
			}
			buf.WriteString(`{"$base64str":`)
			js, _ := json.Marshal(s)
			buf.Write(js)
			buf.WriteString("}")
			return rest, nil
		case cbortagRegexp:
			s, rest, err := cborReadRegexpStringBytes(b)
			if err != nil {
				return b, err
			}
			buf.WriteString(`{"$regex":`)
			js, _ := json.Marshal(s)
			buf.Write(js)
			buf.WriteString("}")
			return rest, nil
		case cbortagMIME:
			s, rest, err := cborReadMIMEStringBytes(b)
			if err != nil {
				return b, err
			}
			buf.WriteString(`{"$mime":`)
			js, _ := json.Marshal(s)
			buf.Write(js)
			buf.WriteString("}")
			return rest, nil
		case 37:
			u, rest, err := cborReadUUIDBytes(b)
			if err != nil {
				return b, err
			}
			hexs := hex.EncodeToString(u[:])
			uuidStr := hexs[0:8] + "-" + hexs[8:12] + "-" + hexs[12:16] + "-" + hexs[16:20] + "-" + hexs[20:32]
			buf.WriteString(`{"$uuid":"`)
			buf.WriteString(uuidStr)
			buf.WriteString(`"}`)
			return rest, nil
		case cbortagSelfDescribeCBOR:
			_, found, _ := cborStripSelfDescribeCBOR(b)
			if found {
				buf.WriteString(`{"$selfdescribe":true}`)
				_, o2, _ := cborReadTagBytes(b)
				return o2, nil
			}
			return b, &cborErrUnsupportedType{}
		default:

			vbuf := cborGetByteBuffer()
			rest, err := cbortoJSON(vbuf, o, depth+1)
			if err != nil {
				cborPutByteBuffer(vbuf)
				return b, err
			}
			buf.WriteString(`{"$tag":`)
			buf.WriteString(strconv.FormatUint(tag, 10))
			buf.WriteString(`,"$":`)
			buf.Write(vbuf.Bytes())
			buf.WriteString("}")
			cborPutByteBuffer(vbuf)
			return rest, nil
		}
	case cbormajorTypeSimple:
		switch add {
		case cborsimpleFalse:
			buf.WriteString("false")
			return b[1:], nil
		case cborsimpleTrue:
			buf.WriteString("true")
			return b[1:], nil
		case cborsimpleNull, cborsimpleUndefined:
			buf.WriteString("null")
			return b[1:], nil
		case cborsimpleFloat16:
			f, o, err := cborReadFloat16Bytes(b)
			if err != nil {
				return b, err
			}
			buf.WriteString(strconv.FormatFloat(float64(f), 'g', -1, 32))
			return o, nil
		case cborsimpleFloat32:
			f, o, err := cborReadFloat32Bytes(b)
			if err != nil {
				return b, err
			}
			buf.WriteString(strconv.FormatFloat(float64(f), 'g', -1, 32))
			return o, nil
		case cborsimpleFloat64:
			f, o, err := cborReadFloat64Bytes(b)
			if err != nil {
				return b, err
			}
			buf.WriteString(strconv.FormatFloat(f, 'g', -1, 64))
			return o, nil
		case cboraddInfoUint8:

			if len(b) < 2 {
				return b, cborErrShortBytes
			}
			buf.WriteString("null")
			return b[2:], nil
		default:
			if add < 20 {

				buf.WriteString("null")
				return b[1:], nil
			}
			return b, &cborErrUnsupportedType{}
		}
	}
	return b, &cborErrUnsupportedType{}
}

func cborencodeBase64Std(buf *cborByteBuffer, src []byte) {
	out := buf.Extend(base64.StdEncoding.EncodedLen(len(src)))
	base64.StdEncoding.Encode(out, src)
}

// encodeBase64RawURL writes raw base64url of src into buf.

// ReadJSONNumberBytes reads a CBOR numeric value and returns it as a
// json.Number, along with the remaining input.

// Number represents a CBOR number that may be an int64, uint64,
// float32, or float64 internally. The zero value is equivalent to
// an int64 value of 0.

// AsInt sets the number to an int64.

// AsUint sets the number to a uint64.

// AsFloat32 sets the value of the number to a float32.

// AsFloat64 sets the value of the number to a float64.

// Int returns the value as an int64 and reports whether that was the
// underlying type (or the zero value).

// Uint returns the value as a uint64 and reports whether that was the
// underlying type.

// Float returns the value as a float64 and reports whether the
// underlying type was float32 or float64.

// Type returns the underlying numeric kind.

// UnmarshalCBOR decodes a single CBOR number from b into n.

// MarshalCBOR encodes the stored numeric value into b.

// CoerceInt attempts to coerce the value into an int64 without loss of
// precision and reports success.

// CoerceUInt attempts to coerce the value into a uint64 without loss of
// precision and reports success.

// isExactInt reports whether the stored float value is an exact integer.

// CoerceFloat returns the value as a float64.

// Msgsize returns the worst-case encoded size.

// String implements fmt.Stringer-style formatting.

// readUintCore reads an unsigned integer with the given expected major type

// ReadMapHeaderBytes reads a map header

// Ultra-fast paths: major type 5 (map): 0xa0-0xbb
// size 0-23

// size in uint8

// size in uint16

// size in uint32

// size in uint64

// ReadArrayHeaderBytes reads an array header

// Ultra-fast paths: major type 4 (array): 0x80-0x9b
// size 0-23

// size in uint8

// size in uint16

// size in uint32

// size in uint64

// ReadMapStartBytes reads a map start and indicates whether it is indefinite-length.
// If indefinite is true, sz is zero and rest points after the header byte (0xbf).

// ReadArrayStartBytes reads an array start and indicates whether it is indefinite-length.
// If indefinite is true, sz is zero and rest points after the header byte (0x9f).

// ReadBreakBytes checks whether the next byte is a break (0xff) and consumes it if so.

// ReadNilBytes reads a nil value

// ReadFloat64Bytes reads a float64

// Ultra-fast path: direct byte comparison (0xfb = float64)

// ReadFloat32Bytes reads a float32

// Ultra-fast path: direct byte comparison (0xfa = float32)

// ReadFloat16Bytes reads a float16 (IEEE 754 binary16) and returns float32

// ReadBoolBytes reads a bool

// Ultra-fast path: direct byte comparison
// true

// false

// ReadInt64Bytes reads an int64

// Ultra-fast paths: direct byte pattern matching, no bit ops
// Major type 0 (positive): 0x00-0x1b
// 0-23 direct encoding

// uint8 follows

// uint16 follows

// uint32 follows

// uint64 follows

// Major type 1 (negative): 0x20-0x3b
// -1 to -24 direct encoding

// negative, uint8 follows

// negative, uint16 follows

// negative, uint32 follows

// negative, uint64 follows

// Invalid major type for integer

// ReadInt32Bytes reads an int32

// ReadInt16Bytes reads an int16

// ReadInt8Bytes reads an int8

// ReadIntBytes reads an int

// ReadUint64Bytes reads a uint64

// ReadUint32Bytes reads a uint32

// ReadUint16Bytes reads a uint16

// ReadUint8Bytes reads a uint8

// ReadUintBytes reads a uint

// ReadBytesBytes reads a byte string

func cborencodeBase64RawURL(buf *cborByteBuffer, src []byte) {
	out := buf.Extend(base64.RawURLEncoding.EncodedLen(len(src)))
	base64.

		// Indefinite form: 0x5f

		RawURLEncoding.Encode(out, src)
}

func cborReadJSONNumberBytes(b []byte) (json.Number, []byte, error) {
	typ := cborNextType(b)
	switch typ {
	case cborIntType:
		v, o, err := cborReadInt64Bytes(b)
		if err != nil {
			return "", b, err
		}
		return json.Number(strconv.FormatInt(v, 10)), o, nil
	case cborUintType:
		v, o, err := cborReadUint64Bytes(b)
		if err != nil {
			return "", b, err
		}
		return json.Number(strconv.FormatUint(v, 10)), o, nil
	case cborFloat32Type:
		v, o, err := cborReadFloat32Bytes(b)
		if err != nil {
			return "", b, err
		}
		return json.Number(strconv.FormatFloat(float64(v), 'f', -1, 64)), o, nil
	case cborFloat64Type:
		v, o, err := cborReadFloat64Bytes(b)
		if err != nil {
			return "", b, err
		}
		return json.Number(strconv.FormatFloat(v, 'f', -1, 64)), o, nil
	default:
		return "", b, &cborErrUnsupportedType{}
	}
}

type cborNumber struct {
	bits uint64
	typ  cborType
}

func (n *cborNumber) AsInt(i int64) {
	if i == 0 {
		n.typ = cborInvalidType
		n.bits = 0
		return
	}

	n.typ = cborIntType
	n.bits = uint64(i)
}

func (n *cborNumber) AsUint(u uint64) {
	n.typ = cborUintType
	n.bits = u
}

func (n *cborNumber) AsFloat32(f float32) {
	n.typ = cborFloat32Type
	n.bits = uint64(math.Float32bits(f))
}

func (n *cborNumber) AsFloat64(f float64) {
	n.typ = cborFloat64Type
	n.bits = math.Float64bits(f)
}

func (n *cborNumber) Int() (int64, bool) {
	return int64(n.bits), n.typ == cborIntType || n.typ == cborInvalidType
}

func (n *cborNumber) Uint() (uint64, bool) {
	return n.bits, n.typ == cborUintType
}

func (n *cborNumber) Float() (float64, bool) {
	switch n.typ {
	case cborFloat32Type:
		return float64(math.Float32frombits(uint32(n.bits))), true
	case cborFloat64Type:
		return math.Float64frombits(n.bits), true
	default:
		return 0, false
	}
}

func (n *cborNumber) Type() cborType {
	if n.typ == cborInvalidType {
		return cborIntType
	}
	return n.typ
}

func (n *cborNumber) UnmarshalCBOR(b []byte) ([]byte, error) {
	typ := cborNextType(b)
	switch typ {
	case cborIntType:
		i, o, err := cborReadInt64Bytes(b)
		if err != nil {
			return b, err
		}
		n.AsInt(i)
		return o, nil
	case cborUintType:
		u, o, err := cborReadUint64Bytes(b)
		if err != nil {
			return b, err
		}
		n.AsUint(u)
		return o, nil
	case cborFloat64Type:
		f, o, err := cborReadFloat64Bytes(b)
		if err != nil {
			return b, err
		}
		n.AsFloat64(f)
		return o, nil
	case cborFloat32Type:
		f, o, err := cborReadFloat32Bytes(b)
		if err != nil {
			return b, err
		}
		n.AsFloat32(f)
		return o, nil
	default:
		return b, &cborErrUnsupportedType{}
	}
}

func (n *cborNumber) MarshalCBOR(b []byte) ([]byte, error) {
	switch n.typ {
	case cborIntType:
		return cborAppendInt64(b, int64(n.bits)), nil
	case cborUintType:
		return cborAppendUint64(b, n.bits), nil
	case cborFloat64Type:
		return cborAppendFloat64(b, math.Float64frombits(n.bits)), nil
	case cborFloat32Type:
		return cborAppendFloat32(b, math.Float32frombits(uint32(n.bits))), nil
	default:
		return cborAppendInt64(b, 0), nil
	}
}

func (n *cborNumber) CoerceInt() (int64, bool) {
	switch n.typ {
	case cborInvalidType, cborIntType:
		return int64(n.bits), true
	case cborUintType:
		return int64(n.bits), n.bits <= math.MaxInt64
	case cborFloat32Type:
		f := math.Float32frombits(uint32(n.bits))
		if n.isExactInt() && f <= math.MaxInt64 && f >= math.MinInt64 {
			return int64(f), true
		}
		if n.bits == 0 || n.bits == 1<<31 {
			return 0, true
		}
	case cborFloat64Type:
		f := math.Float64frombits(n.bits)
		if n.isExactInt() && f <= math.MaxInt64 && f >= math.MinInt64 {
			return int64(f), true
		}
		return 0, n.bits == 0 || n.bits == 1<<63
	}
	return 0, false
}

func (n *cborNumber) CoerceUInt() (uint64, bool) {
	switch n.typ {
	case cborInvalidType, cborIntType:
		if int64(n.bits) >= 0 {
			return n.bits, true
		}
	case cborUintType:
		return n.bits, true
	case cborFloat32Type:
		f := math.Float32frombits(uint32(n.bits))
		if f >= 0 && f <= math.MaxUint64 && n.isExactInt() {
			return uint64(f), true
		}
		if n.bits == 0 || n.bits == 1<<31 {
			return 0, true
		}
	case cborFloat64Type:
		f := math.Float64frombits(n.bits)
		if f >= 0 && f <= math.MaxUint64 && n.isExactInt() {
			return uint64(f), true
		}
		return 0, n.bits == 0 || n.bits == 1<<63
	}
	return 0, false
}

func (n *cborNumber) isExactInt() bool {
	var eBits, mBits int

	switch n.typ {
	case cborInvalidType, cborIntType, cborUintType:
		return true
	case cborFloat32Type:
		eBits = 8
		mBits = 23
	case cborFloat64Type:
		eBits = 11
		mBits = 52
	default:
		return false
	}

	exp := int(n.bits>>mBits) & ((1 << eBits) - 1)
	mant := n.bits & ((1 << mBits) - 1)
	if exp == 0 && mant == 0 {
		return true
	}

	exp -= (1 << (eBits - 1)) - 1
	if exp < 0 || exp == 1<<(eBits-1) {
		return false
	}
	if exp >= mBits {
		return true
	}
	return bits.TrailingZeros64(mant) >= mBits-exp
}

func (n *cborNumber) CoerceFloat() float64 {
	switch n.typ {
	case cborIntType:
		return float64(int64(n.bits))
	case cborUintType:
		return float64(n.bits)
	case cborFloat32Type:
		return float64(math.Float32frombits(uint32(n.bits)))
	case cborFloat64Type:
		return math.Float64frombits(n.bits)
	default:
		return 0
	}
}

func (n *cborNumber) Msgsize() int {
	switch n.typ {
	case cborFloat32Type:
		return cborFloat32Size
	case cborFloat64Type:
		return cborFloat64Size
	case cborIntType:
		return cborInt64Size
	case cborUintType:
		return cborUint64Size
	default:
		return 1
	}
}

func (n *cborNumber) String() string {
	switch n.typ {
	case cborInvalidType:
		return "0"
	case cborFloat32Type, cborFloat64Type:
		f, _ := n.Float()
		return strconv.FormatFloat(f, 'f', -1, 64)
	case cborIntType:
		i, _ := n.Int()
		return strconv.FormatInt(i, 10)
	case cborUintType:
		u, _ := n.Uint()
		return strconv.FormatUint(u, 10)
	default:
		return "0"
	}
}

var cborbe = binary.BigEndian

func cborreadUintCore(b []byte, expectedMajor uint8) (uint64, []byte, error) {
	if len(b) < 1 {
		return 0, b, cborErrShortBytes
	}

	major := cborgetMajorType(b[0])
	if major != expectedMajor {
		return 0, b, cborbadPrefix(major, expectedMajor)
	}

	addInfo := cborgetAddInfo(b[0])

	switch {
	case addInfo <= cboraddInfoDirect:
		return uint64(addInfo), b[1:], nil
	case addInfo == cboraddInfoUint8:
		if len(b) < 2 {
			return 0, b, cborErrShortBytes
		}
		return uint64(b[1]), b[2:], nil
	case addInfo == cboraddInfoUint16:
		if len(b) < 3 {
			return 0, b, cborErrShortBytes
		}
		return uint64(cborbe.Uint16(b[1:])), b[3:], nil
	case addInfo == cboraddInfoUint32:
		if len(b) < 5 {
			return 0, b, cborErrShortBytes
		}
		return uint64(cborbe.Uint32(b[1:])), b[5:], nil
	case addInfo == cboraddInfoUint64:
		if len(b) < 9 {
			return 0, b, cborErrShortBytes
		}
		return cborbe.Uint64(b[1:]), b[9:], nil
	default:
		return 0, b, &cborErrUnsupportedType{}
	}
}

func cborReadMapHeaderBytes(b []byte) (sz uint32, o []byte, err error) {
	if len(b) < 1 {
		return 0, b, cborErrShortBytes
	}

	lead := b[0]

	if lead >= 0xa0 && lead <= 0xb7 {
		return uint32(lead - 0xa0), b[1:], nil
	}
	if lead == 0xb8 {
		if len(b) < 2 {
			return 0, b, cborErrShortBytes
		}
		return uint32(b[1]), b[2:], nil
	}
	if lead == 0xb9 {
		if len(b) < 3 {
			return 0, b, cborErrShortBytes
		}
		return uint32(cborbe.Uint16(b[1:])), b[3:], nil
	}
	if lead == 0xba {
		if len(b) < 5 {
			return 0, b, cborErrShortBytes
		}
		return cborbe.Uint32(b[1:]), b[5:], nil
	}
	if lead == 0xbb {
		if len(b) < 9 {
			return 0, b, cborErrShortBytes
		}
		u := cborbe.Uint64(b[1:])
		if u > math.MaxUint32 {
			return 0, b, cborUintOverflow{Value: u, FailedBitsize: 32}
		}
		return uint32(u), b[9:], nil
	}

	major := cborgetMajorType(lead)
	return 0, b, cborbadPrefix(major, cbormajorTypeMap)
}

func cborReadArrayHeaderBytes(b []byte) (sz uint32, o []byte, err error) {
	if len(b) < 1 {
		return 0, b, cborErrShortBytes
	}

	lead := b[0]

	if lead >= 0x80 && lead <= 0x97 {
		return uint32(lead - 0x80), b[1:], nil
	}
	if lead == 0x98 {
		if len(b) < 2 {
			return 0, b, cborErrShortBytes
		}
		return uint32(b[1]), b[2:], nil
	}
	if lead == 0x99 {
		if len(b) < 3 {
			return 0, b, cborErrShortBytes
		}
		return uint32(cborbe.Uint16(b[1:])), b[3:], nil
	}
	if lead == 0x9a {
		if len(b) < 5 {
			return 0, b, cborErrShortBytes
		}
		return cborbe.Uint32(b[1:]), b[5:], nil
	}
	if lead == 0x9b {
		if len(b) < 9 {
			return 0, b, cborErrShortBytes
		}
		u := cborbe.Uint64(b[1:])
		if u > math.MaxUint32 {
			return 0, b, cborUintOverflow{Value: u, FailedBitsize: 32}
		}
		return uint32(u), b[9:], nil
	}

	major := cborgetMajorType(lead)
	return 0, b, cborbadPrefix(major, cbormajorTypeArray)
}

func cborReadMapStartBytes(b []byte) (sz uint32, indefinite bool, rest []byte, err error) {
	if len(b) < 1 {
		return 0, false, b, cborErrShortBytes
	}
	if b[0] == cbormakeByte(cbormajorTypeMap, cboraddInfoIndefinite) {
		return 0, true, b[1:], nil
	}
	s, o, e := cborReadMapHeaderBytes(b)
	return s, false, o, e
}

func cborReadArrayStartBytes(b []byte) (sz uint32, indefinite bool, rest []byte, err error) {
	if len(b) < 1 {
		return 0, false, b, cborErrShortBytes
	}
	if b[0] == cbormakeByte(cbormajorTypeArray, cboraddInfoIndefinite) {
		return 0, true, b[1:], nil
	}
	s, o, e := cborReadArrayHeaderBytes(b)
	return s, false, o, e
}

func cborReadBreakBytes(b []byte) (rest []byte, ok bool, err error) {
	if len(b) < 1 {
		return b, false, cborErrShortBytes
	}
	if b[0] == cbormakeByte(cbormajorTypeSimple, cborsimpleBreak) {
		return b[1:], true, nil
	}
	return b, false, nil
}

func cborReadNilBytes(b []byte) ([]byte, error) {
	if len(b) < 1 {
		return b, cborErrShortBytes
	}
	if b[0] != cbormakeByte(cbormajorTypeSimple, cborsimpleNull) {
		return b, cborErrNotNil
	}
	return b[1:], nil
}

func cborReadFloat64Bytes(b []byte) (f float64, o []byte, err error) {
	if len(b) < 9 {
		return 0, b, cborErrShortBytes
	}

	if b[0] != 0xfb {
		return 0, b, cborbadPrefix(cborgetMajorType(b[0]), cbormajorTypeSimple)
	}
	f = math.Float64frombits(cborbe.Uint64(b[1:]))
	return f, b[9:], nil
}

func cborReadFloat32Bytes(b []byte) (f float32, o []byte, err error) {
	if len(b) < 5 {
		return 0, b, cborErrShortBytes
	}

	if b[0] != 0xfa {
		return 0, b, cborbadPrefix(cborgetMajorType(b[0]), cbormajorTypeSimple)
	}
	f = math.Float32frombits(cborbe.Uint32(b[1:]))
	return f, b[5:], nil
}

func cborReadFloat16Bytes(b []byte) (f float32, o []byte, err error) {
	if len(b) < 3 {
		return 0, b, cborErrShortBytes
	}
	if b[0] != 0xF9 {
		return 0, b, cborbadPrefix(cborgetMajorType(b[0]), cbormajorTypeSimple)
	}
	h := binary.BigEndian.Uint16(b[1:])
	f = cborfloat16BitsToFloat32(h)
	return f, b[3:], nil
}

func cborReadBoolBytes(b []byte) (bool, []byte, error) {
	if len(b) < 1 {
		return false, b, cborErrShortBytes
	}

	if b[0] == 0xf5 {
		return true, b[1:], nil
	}
	if b[0] == 0xf4 {
		return false, b[1:], nil
	}
	return false, b, cborTypeError{Method: cborBoolType, Encoded: cborgetType(b[0])}
}

func cborReadInt64Bytes(b []byte) (i int64, o []byte, err error) {
	if len(b) < 1 {
		return 0, b, cborErrShortBytes
	}

	lead := b[0]

	if lead <= 0x17 {
		return int64(lead), b[1:], nil
	}
	if lead == 0x18 {
		if len(b) < 2 {
			return 0, b, cborErrShortBytes
		}
		return int64(b[1]), b[2:], nil
	}
	if lead == 0x19 {
		if len(b) < 3 {
			return 0, b, cborErrShortBytes
		}
		return int64(cborbe.Uint16(b[1:])), b[3:], nil
	}
	if lead == 0x1a {
		if len(b) < 5 {
			return 0, b, cborErrShortBytes
		}
		u := uint64(cborbe.Uint32(b[1:]))
		return int64(u), b[5:], nil
	}
	if lead == 0x1b {
		if len(b) < 9 {
			return 0, b, cborErrShortBytes
		}
		u := cborbe.Uint64(b[1:])
		if u > math.MaxInt64 {
			return 0, b, cborIntOverflow{Value: int64(u), FailedBitsize: 64}
		}
		return int64(u), b[9:], nil
	}

	if lead >= 0x20 && lead <= 0x37 {
		return -1 - int64(lead-0x20), b[1:], nil
	}
	if lead == 0x38 {
		if len(b) < 2 {
			return 0, b, cborErrShortBytes
		}
		return -1 - int64(b[1]), b[2:], nil
	}
	if lead == 0x39 {
		if len(b) < 3 {
			return 0, b, cborErrShortBytes
		}
		return -1 - int64(cborbe.Uint16(b[1:])), b[3:], nil
	}
	if lead == 0x3a {
		if len(b) < 5 {
			return 0, b, cborErrShortBytes
		}
		return -1 - int64(cborbe.Uint32(b[1:])), b[5:], nil
	}
	if lead == 0x3b {
		if len(b) < 9 {
			return 0, b, cborErrShortBytes
		}
		u := cborbe.Uint64(b[1:])
		if u > math.MaxInt64 {
			return 0, b, cborIntOverflow{Value: -1, FailedBitsize: 64}
		}
		return -1 - int64(u), b[9:], nil
	}

	major := (lead >> 5) & 0x07
	return 0, b, cborbadPrefix(major, cbormajorTypeUint)
}

func cborReadInt32Bytes(b []byte) (i int32, o []byte, err error) {
	i64, o, err := cborReadInt64Bytes(b)
	if err != nil {
		return 0, b, err
	}
	if i64 > math.MaxInt32 || i64 < math.MinInt32 {
		return 0, b, cborIntOverflow{Value: i64, FailedBitsize: 32}
	}
	return int32(i64), o, nil
}

func cborReadInt16Bytes(b []byte) (i int16, o []byte, err error) {
	i64, o, err := cborReadInt64Bytes(b)
	if err != nil {
		return 0, b, err
	}
	if i64 > math.MaxInt16 || i64 < math.MinInt16 {
		return 0, b, cborIntOverflow{Value: i64, FailedBitsize: 16}
	}
	return int16(i64), o, nil
}

func cborReadInt8Bytes(b []byte) (i int8, o []byte, err error) {
	i64, o, err := cborReadInt64Bytes(b)
	if err != nil {
		return 0, b, err
	}
	if i64 > math.MaxInt8 || i64 < math.MinInt8 {
		return 0, b, cborIntOverflow{Value: i64, FailedBitsize: 8}
	}
	return int8(i64), o, nil
}

func cborReadIntBytes(b []byte) (i int, o []byte, err error) {
	i64, o, err := cborReadInt64Bytes(b)
	if err != nil {
		return 0, b, err
	}
	return int(i64), o, nil
}

func cborReadUint64Bytes(b []byte) (u uint64, o []byte, err error) {
	return cborreadUintCore(b, cbormajorTypeUint)
}

func cborReadUint32Bytes(b []byte) (u uint32, o []byte, err error) {
	u64, o, err := cborreadUintCore(b, cbormajorTypeUint)
	if err != nil {
		return 0, b, err
	}
	if u64 > math.MaxUint32 {
		return 0, b, cborUintOverflow{Value: u64, FailedBitsize: 32}
	}
	return uint32(u64), o, nil
}

func cborReadUint16Bytes(b []byte) (u uint16, o []byte, err error) {
	u64, o, err := cborreadUintCore(b, cbormajorTypeUint)
	if err != nil {
		return 0, b, err
	}
	if u64 > math.MaxUint16 {
		return 0, b, cborUintOverflow{Value: u64, FailedBitsize: 16}
	}
	return uint16(u64), o, nil
}

func cborReadUint8Bytes(b []byte) (u uint8, o []byte, err error) {
	u64, o, err := cborreadUintCore(b, cbormajorTypeUint)
	if err != nil {
		return 0, b, err
	}
	if u64 > math.MaxUint8 {
		return 0, b, cborUintOverflow{Value: u64, FailedBitsize: 8}
	}
	return uint8(u64), o, nil
}

func cborReadUintBytes(b []byte) (u uint, o []byte, err error) {
	u64, o, err := cborreadUintCore(b, cbormajorTypeUint)
	if err != nil {
		return 0, b, err
	}
	return uint(u64), o, nil
}

func cborReadBytesBytes(b []byte, scratch []byte) (v []byte, o []byte, err error) {
	if len(b) < 1 {
		return nil, b, cborErrShortBytes
	}

	if b[0] == cbormakeByte(cbormajorTypeBytes, cboraddInfoIndefinite) {
		out := scratch[:0]
		p := b[1:]
		for {
			if len(p) < 1 {
				return nil, b, cborErrShortBytes
			}
			// Break?
			if p[0] == cbormakeByte(cbormajorTypeSimple, cborsimpleBreak) {
				return out, p[1:], nil
			}
			// Next must be a definite-length byte string
			sz, q, e := cborreadUintCore(p, cbormajorTypeBytes)
			if e != nil {
				return nil, b, e
			}
			if uint64(len(q)) < sz {
				return nil, b, cborErrShortBytes
			}
			out = append(out, q[:sz]...)
			p = q[sz:]
		}
	}
	sz, o, err := cborreadUintCore(b, cbormajorTypeBytes)
	if err != nil {
		return nil, b, err
	}
	if uint64(len(o)) < sz {
		return nil, b, cborErrShortBytes
	}
	if sz == 0 {
		return scratch[:0], o, nil
	}
	return o[:sz], o[sz:], nil
}

// ReadStringZC reads a text string zero-copy (returns slice into original buffer)
func cborReadStringZC(b []byte) (v []byte, o []byte, err error) {
	if len(b) < 1 {
		return nil, b, cborErrShortBytes
	}

	lead := b[0]

	// Ultra-fast path for length 0-23
	if lead >= 0x60 && lead <= 0x77 {
		sz := int(lead & 0x1f)
		if len(b) < 1+sz {
			return nil, b, cborErrShortBytes
		}
		return b[1 : 1+sz], b[1+sz:], nil
	}

	// Longer strings
	var sz int
	var start int

	switch lead {
	case 0x78: // uint8
		if len(b) < 2 {
			return nil, b, cborErrShortBytes
		}
		sz = int(b[1])
		start = 2
	case 0x79: // uint16
		if len(b) < 3 {
			return nil, b, cborErrShortBytes
		}
		sz = int(cborbe.Uint16(b[1:]))
		start = 3
	case 0x7a: // uint32
		if len(b) < 5 {
			return nil, b, cborErrShortBytes
		}
		sz = int(cborbe.Uint32(b[1:]))
		start = 5
	case 0x7b: // uint64
		if len(b) < 9 {
			return nil, b, cborErrShortBytes
		}
		u64 := cborbe.Uint64(b[1:])
		if u64 > math.MaxInt {
			return nil, b, cborUintOverflow{Value: u64, FailedBitsize: 64}
		}
		sz = int(u64)
		start = 9
	default:
		// Invalid major type
		major := cborgetMajorType(lead)
		return nil, b, cborbadPrefix(major, cbormajorTypeText)
	}

	// Guard against integer overflow and out-of-bounds slicing.
	// Use subtraction form to avoid start+sz overflow when sz is near MaxInt.
	if start < 0 || start > len(b) {
		return nil, b, cborErrShortBytes
	}
	if sz < 0 || sz > len(b)-start {
		return nil, b, cborErrShortBytes
	}
	end := start + sz
	return b[start:end], b[end:], nil
}

// ReadStringBytes reads a text string
func cborReadStringBytes(b []byte) (s string, o []byte, err error) {
	if len(b) < 1 {
		return "", b, cborErrShortBytes
	}
	// Indefinite-length text string (0x7f)
	if b[0] == cbormakeByte(cbormajorTypeText, cboraddInfoIndefinite) {
		p := b[1:]
		var out []byte
		for {
			if len(p) < 1 {
				return "", b, cborErrShortBytes
			}
			if p[0] == cbormakeByte(cbormajorTypeSimple, cborsimpleBreak) {
				if cborValidateUTF8OnDecode && !cborisUTF8Valid(out) {
					return "", b, cborErrInvalidUTF8
				}
				return string(out), p[1:], nil
			}
			chunk, q, e := cborReadStringZC(p)
			if e != nil {
				return "", b, e
			}
			out = append(out, chunk...)
			p = q
		}
	}
	v, o, err := cborReadStringZC(b)
	if err != nil {
		return "", b, err
	}
	if cborValidateUTF8OnDecode && !cborisUTF8Valid(v) {
		return "", b, cborErrInvalidUTF8
	}
	if cborUnsafeStringDecode {
		return cborUnsafeString(v), o, nil
	}
	return string(v), o, nil
}

// ReadMapKeyZC reads a map key expecting a text string and returns its bytes zero-copy.
// It is a thin wrapper around ReadStringZC for generated code compatibility.
func cborReadMapKeyZC(b []byte) (v []byte, o []byte, err error) {
	// For CBOR, map keys are typically text. Support text zero-copy here.
	if len(b) < 1 {
		return nil, b, cborErrShortBytes
	}
	if cborgetMajorType(b[0]) != cbormajorTypeText {
		// Fallback: treat as text anyway to surface a type error consistently
		return nil, b, cborTypeError{Method: cborStrType, Encoded: cborgetType(b[0])}
	}
	return cborReadStringZC(b)
}

// ReadSimpleValue reads a simple value and returns its numeric value.
// Returns values 0..23 (including false/true/null/undefined) directly,
// or 32..255 following a 0xf8 prefix. Float encodings are not handled here.
func cborReadSimpleValue(b []byte) (val uint8, o []byte, err error) {
	if len(b) < 1 {
		return 0, b, cborErrShortBytes
	}
	major := cborgetMajorType(b[0])
	if major != cbormajorTypeSimple {
		return 0, b, cborbadPrefix(major, cbormajorTypeSimple)
	}
	addInfo := cborgetAddInfo(b[0])
	switch addInfo {
	case cborsimpleFloat16, cborsimpleFloat32, cborsimpleFloat64:
		return 0, b, &cborErrUnsupportedType{}
	case cboraddInfoUint8: // 0xf8 XX
		if len(b) < 2 {
			return 0, b, cborErrShortBytes
		}
		return b[1], b[2:], nil
	default:
		if addInfo <= cboraddInfoDirect {
			return addInfo, b[1:], nil
		}
		return 0, b, &cborErrUnsupportedType{}
	}
}

// ReadTimeBytes reads a time.Time (CBOR tag 1 with Unix timestamp)
func cborReadTimeBytes(b []byte) (t time.Time, o []byte, err error) {
	if len(b) < 2 {
		return time.Time{}, b, cborErrShortBytes
	}
	if cborgetMajorType(b[0]) != cbormajorTypeTag {
		return time.Time{}, b, cborbadPrefix(cborgetMajorType(b[0]), cbormajorTypeTag)
	}
	tag, o, err := cborreadUintCore(b, cbormajorTypeTag)
	if err != nil {
		return time.Time{}, b, err
	}
	if tag != cbortagEpochDateTime {
		return time.Time{}, b, errors.New("cbor: expected epoch datetime tag")
	}
	if len(o) < 1 {
		return time.Time{}, b, cborErrShortBytes
	}
	switch cborgetMajorType(o[0]) {
	case cbormajorTypeUint, cbormajorTypeNegInt:
		sec, o2, e := cborReadInt64Bytes(o)
		if e != nil {
			return time.Time{}, b, e
		}
		return time.Unix(sec, 0), o2, nil
	case cbormajorTypeSimple:
		add := cborgetAddInfo(o[0])
		switch add {
		case cborsimpleFloat64:
			f, o2, e := cborReadFloat64Bytes(o)
			if e != nil {
				return time.Time{}, b, e
			}
			sec := math.Floor(f)
			ns := int64(math.Round((f - sec) * 1e9))
			secs := int64(sec)
			if ns >= 1e9 {
				secs++
				ns -= 1e9
			}
			return time.Unix(secs, ns), o2, nil
		case cborsimpleFloat32:
			f, o2, e := cborReadFloat32Bytes(o)
			if e != nil {
				return time.Time{}, b, e
			}
			sec := math.Floor(float64(f))
			ns := int64(math.Round((float64(f) - sec) * 1e9))
			secs := int64(sec)
			if ns >= 1e9 {
				secs++
				ns -= 1e9
			}
			return time.Unix(secs, ns), o2, nil
		case cborsimpleFloat16:
			f, o2, e := cborReadFloat16Bytes(o)
			if e != nil {
				return time.Time{}, b, e
			}
			sec := math.Floor(float64(f))
			ns := int64(math.Round((float64(f) - sec) * 1e9))
			secs := int64(sec)
			if ns >= 1e9 {
				secs++
				ns -= 1e9
			}
			return time.Unix(secs, ns), o2, nil
		default:
			return time.Time{}, b, &cborErrUnsupportedType{}
		}
	default:
		return time.Time{}, b, &cborErrUnsupportedType{}
	}
}

// ReadTagBytes reads a semantic tag value (major type 6)
func cborReadTagBytes(b []byte) (tag uint64, o []byte, err error) {
	tag, o, err = cborreadUintCore(b, cbormajorTypeTag)
	if err != nil {
		return 0, b, err
	}
	return tag, o, nil
}

// ReadRFC3339TimeBytes reads a tag(0) RFC3339 time string into time.Time
func cborReadRFC3339TimeBytes(b []byte) (t time.Time, o []byte, err error) {
	tag, o, err := cborReadTagBytes(b)
	if err != nil {
		return time.Time{}, b, err
	}
	if tag != cbortagDateTimeString {
		return time.Time{}, b, cborbadPrefix(cbormajorTypeTag, cbormajorTypeTag)
	}
	s, o2, err := cborReadStringBytes(o)
	if err != nil {
		return time.Time{}, b, err
	}
	tt, perr := time.Parse(time.RFC3339Nano, s)
	if perr != nil {
		return time.Time{}, b, perr
	}
	return tt, o2, nil
}

// ReadBase64URLStringBytes reads tag(33) base64url text string
func cborReadBase64URLStringBytes(b []byte) (s string, o []byte, err error) {
	tag, o, err := cborReadTagBytes(b)
	if err != nil {
		return "", b, err
	}
	if tag != cbortagBase64URLString {
		return "", b, cborbadPrefix(cbormajorTypeTag, cbormajorTypeTag)
	}
	return cborReadStringBytes(o)
}

// ReadBase64StringBytes reads tag(34) base64 text string
func cborReadBase64StringBytes(b []byte) (s string, o []byte, err error) {
	tag, o, err := cborReadTagBytes(b)
	if err != nil {
		return "", b, err
	}
	if tag != cbortagBase64String {
		return "", b, cborbadPrefix(cbormajorTypeTag, cbormajorTypeTag)
	}
	return cborReadStringBytes(o)
}

// ReadURIStringBytes reads a tag(32) URI text string
func cborReadURIStringBytes(b []byte) (uri string, o []byte, err error) {
	tag, o, err := cborReadTagBytes(b)
	if err != nil {
		return "", b, err
	}
	if tag != cbortagURI {
		return "", b, cborbadPrefix(cbormajorTypeTag, cbormajorTypeTag)
	}
	return cborReadStringBytes(o)
}

// ReadEmbeddedCBORBytes reads tag(24) with embedded CBOR payload
func cborReadEmbeddedCBORBytes(b []byte) (payload []byte, o []byte, err error) {
	tag, o, err := cborReadTagBytes(b)
	if err != nil {
		return nil, b, err
	}
	if tag != cbortagCBOR {
		return nil, b, cborbadPrefix(cbormajorTypeTag, cbormajorTypeTag)
	}
	return cborReadBytesBytes(o, nil)
}

// ReadBase64URLBytes reads tag(21) byte string
func cborReadBase64URLBytes(b []byte) (bs []byte, o []byte, err error) {
	tag, o, err := cborReadTagBytes(b)
	if err != nil {
		return nil, b, err
	}
	if tag != cbortagBase64URL {
		return nil, b, cborbadPrefix(cbormajorTypeTag, cbormajorTypeTag)
	}
	return cborReadBytesBytes(o, nil)
}

// ReadBase64Bytes reads tag(22) byte string
func cborReadBase64Bytes(b []byte) (bs []byte, o []byte, err error) {
	tag, o, err := cborReadTagBytes(b)
	if err != nil {
		return nil, b, err
	}
	if tag != cbortagBase64 {
		return nil, b, cborbadPrefix(cbormajorTypeTag, cbormajorTypeTag)
	}
	return cborReadBytesBytes(o, nil)
}

// ReadBase16Bytes reads tag(23) byte string
func cborReadBase16Bytes(b []byte) (bs []byte, o []byte, err error) {
	tag, o, err := cborReadTagBytes(b)
	if err != nil {
		return nil, b, err
	}
	if tag != cbortagBase16 {
		return nil, b, cborbadPrefix(cbormajorTypeTag, cbormajorTypeTag)
	}
	return cborReadBytesBytes(o, nil)
}

// ReadUUIDBytes reads tag(37) UUID as 16-byte array
func cborReadUUIDBytes(b []byte) (uuid [16]byte, o []byte, err error) {
	tag, o, err := cborReadTagBytes(b)
	if err != nil {
		return uuid, b, err
	}
	if tag != 37 {
		return uuid, b, cborbadPrefix(cbormajorTypeTag, cbormajorTypeTag)
	}
	bs, o2, err := cborReadBytesBytes(o, nil)
	if err != nil {
		return uuid, b, err
	}
	if len(bs) != 16 {
		return uuid, b, errors.New("cbor: uuid must be 16 bytes")
	}
	copy(uuid[:], bs)
	return uuid, o2, nil
}

// ReadRegexpStringBytes reads tag(35) regular expression pattern as text string
func cborReadRegexpStringBytes(b []byte) (pattern string, o []byte, err error) {
	tag, o, err := cborReadTagBytes(b)
	if err != nil {
		return "", b, err
	}
	if tag != cbortagRegexp {
		return "", b, cborbadPrefix(cbormajorTypeTag, cbormajorTypeTag)
	}
	return cborReadStringBytes(o)
}

// ReadMIMEStringBytes reads tag(36) MIME message as text string
func cborReadMIMEStringBytes(b []byte) (mime string, o []byte, err error) {
	tag, o, err := cborReadTagBytes(b)
	if err != nil {
		return "", b, err
	}
	if tag != cbortagMIME {
		return "", b, cborbadPrefix(cbormajorTypeTag, cbormajorTypeTag)
	}
	return cborReadStringBytes(o)
}

// StripSelfDescribeCBOR checks for and consumes a self-describe CBOR tag (0xd9d9f7)
func cborStripSelfDescribeCBOR(b []byte) (rest []byte, found bool, err error) {
	if len(b) < 1 {
		return b, false, cborErrShortBytes
	}
	if cborgetMajorType(b[0]) != cbormajorTypeTag {
		return b, false, nil
	}
	tag, o, e := cborReadTagBytes(b)
	if e != nil {
		return b, false, e
	}
	if tag != cbortagSelfDescribeCBOR {
		return b, false, nil
	}
	return o, true, nil
}

// ReadRegexpBytes reads tag(35) and compiles the contained pattern into *regexp.Regexp
func cborReadRegexpBytes(b []byte) (re *regexp.Regexp, o []byte, err error) {
	s, o, err := cborReadRegexpStringBytes(b)
	if err != nil {
		return nil, b, err
	}
	r, e := regexp.Compile(s)
	if e != nil {
		return nil, b, e
	}
	return r, o, nil
}

// ReadBigIntBytes reads a bignum (tag 2 or 3) into a big.Int
func cborReadBigIntBytes(b []byte) (z *bigmath.Int, o []byte, err error) {
	tag, o, err := cborReadTagBytes(b)
	if err != nil {
		return nil, b, err
	}
	bs, o2, err := cborReadBytesBytes(o, nil)
	if err != nil {
		return nil, b, err
	}
	mag := new(bigmath.Int).SetBytes(bs)
	switch tag {
	case cbortagPosBignum:
		return mag, o2, nil
	case cbortagNegBignum:
		mag.Add(mag, bigmath.NewInt(1))
		mag.Neg(mag)
		return mag, o2, nil
	default:
		return nil, b, cborbadPrefix(cbormajorTypeTag, cbormajorTypeTag)
	}
}

// readCBORIntegerAsBigInt reads a CBOR integer (major type 0/1) or bignum (tags 2/3) into big.Int
func cborreadCBORIntegerAsBigInt(b []byte) (*bigmath.Int, []byte, error) {
	if len(b) < 1 {
		return nil, b, cborErrShortBytes
	}
	major := cborgetMajorType(b[0])
	switch major {
	case cbormajorTypeUint:
		u, o, err := cborreadUintCore(b, cbormajorTypeUint)
		if err != nil {
			return nil, b, err
		}
		zz := new(bigmath.Int).SetUint64(u)
		return zz, o, nil
	case cbormajorTypeNegInt:
		i, o, err := cborReadInt64Bytes(b)
		if err != nil {
			return nil, b, err
		}
		zz := bigmath.NewInt(i)
		return zz, o, nil
	case cbormajorTypeTag:
		tag, o, err := cborReadTagBytes(b)
		if err != nil {
			return nil, b, err
		}
		if tag != cbortagPosBignum && tag != cbortagNegBignum {
			return nil, b, &cborErrUnsupportedType{}
		}
		bs, o2, err := cborReadBytesBytes(o, nil)
		if err != nil {
			return nil, b, err
		}
		mag := new(bigmath.Int).SetBytes(bs)
		if tag == cbortagNegBignum {
			mag.Add(mag, bigmath.NewInt(1))
			mag.Neg(mag)
		}
		return mag, o2, nil
	default:
		return nil, b, &cborErrUnsupportedType{}
	}
}

// ReadDecimalFractionBytes reads tag(4) decimal fraction [exponent, mantissa]
func cborReadDecimalFractionBytes(b []byte) (exp int64, mant *bigmath.Int, o []byte, err error) {
	tag, o, err := cborReadTagBytes(b)
	if err != nil {
		return 0, nil, b, err
	}
	if tag != cbortagDecimalFrac {
		return 0, nil, b, &cborErrUnsupportedType{}
	}
	// Handle definite and indefinite arrays
	if len(o) < 1 {
		return 0, nil, b, cborErrShortBytes
	}
	if o[0] == cbormakeByte(cbormajorTypeArray, cboraddInfoIndefinite) {
		// skip header
		p := o[1:]
		// exponent
		exp, p, err = cborReadInt64Bytes(p)
		if err != nil {
			return 0, nil, b, err
		}
		// mantissa
		mant, p, err = cborreadCBORIntegerAsBigInt(p)
		if err != nil {
			return 0, nil, b, err
		}
		// expect break
		if len(p) < 1 || p[0] != cbormakeByte(cbormajorTypeSimple, cborsimpleBreak) {
			return 0, nil, b, &cborErrUnsupportedType{}
		}
		return exp, mant, p[1:], nil
	}
	// definite
	sz, p, err := cborReadArrayHeaderBytes(o)
	if err != nil {
		return 0, nil, b, err
	}
	if sz != 2 {
		return 0, nil, b, cborArrayError{Wanted: 2, Got: sz}
	}
	exp, p, err = cborReadInt64Bytes(p)
	if err != nil {
		return 0, nil, b, err
	}
	mant, p, err = cborreadCBORIntegerAsBigInt(p)
	if err != nil {
		return 0, nil, b, err
	}
	return exp, mant, p, nil
}

// ReadBigfloatBytes reads tag(5) bigfloat [exponent, mantissa]
func cborReadBigfloatBytes(b []byte) (exp int64, mant *bigmath.Int, o []byte, err error) {
	tag, o, err := cborReadTagBytes(b)
	if err != nil {
		return 0, nil, b, err
	}
	if tag != cbortagBigfloat {
		return 0, nil, b, &cborErrUnsupportedType{}
	}
	if len(o) < 1 {
		return 0, nil, b, cborErrShortBytes
	}
	if o[0] == cbormakeByte(cbormajorTypeArray, cboraddInfoIndefinite) {
		p := o[1:]
		exp, p, err = cborReadInt64Bytes(p)
		if err != nil {
			return 0, nil, b, err
		}
		mant, p, err = cborreadCBORIntegerAsBigInt(p)
		if err != nil {
			return 0, nil, b, err
		}
		if len(p) < 1 || p[0] != cbormakeByte(cbormajorTypeSimple, cborsimpleBreak) {
			return 0, nil, b, &cborErrUnsupportedType{}
		}
		return exp, mant, p[1:], nil
	}
	sz, p, err := cborReadArrayHeaderBytes(o)
	if err != nil {
		return 0, nil, b, err
	}
	if sz != 2 {
		return 0, nil, b, cborArrayError{Wanted: 2, Got: sz}
	}
	exp, p, err = cborReadInt64Bytes(p)
	if err != nil {
		return 0, nil, b, err
	}
	mant, p, err = cborreadCBORIntegerAsBigInt(p)
	if err != nil {
		return 0, nil, b, err
	}
	return exp, mant, p, nil
}

// ReadMapNoDupBytes validates that the next CBOR item is a map and that it has no duplicate keys.
// Keys are compared by raw CBOR byte representation. Returns the bytes after the map or an error.
func cborReadMapNoDupBytes(b []byte) (o []byte, err error) {
	if len(b) < 1 {
		return b, cborErrShortBytes
	}
	if cborgetMajorType(b[0]) != cbormajorTypeMap {
		return b, cborbadPrefix(cbormajorTypeMap, cborgetMajorType(b[0]))
	}
	// Indefinite-length map
	if cborgetAddInfo(b[0]) == cboraddInfoIndefinite {
		seen := make(map[string]struct{})
		p := b[1:]
		for {
			if len(p) < 1 {
				return b, cborErrShortBytes
			}
			if p[0] == cbormakeByte(cbormajorTypeSimple, cborsimpleBreak) {
				return p[1:], nil
			}
			// Capture raw key bytes
			r, err := cborSkip(p)
			if err != nil {
				return b, err
			}
			keyLen := len(p) - len(r)
			rawKey := p[:keyLen]
			keyStr := string(rawKey)
			if _, ok := seen[keyStr]; ok {
				return b, cborErrDuplicateMapKey
			}
			seen[keyStr] = struct{}{}
			// Skip value
			r2, err := cborSkip(r)
			if err != nil {
				return b, err
			}
			p = r2
		}
	}
	// Definite-length map
	sz, p, err := cborReadMapHeaderBytes(b)
	if err != nil {
		return b, err
	}
	seen := make(map[string]struct{}, sz)
	for i := uint32(0); i < sz; i++ {
		r, err := cborSkip(p)
		if err != nil {
			return b, err
		}
		keyLen := len(p) - len(r)
		rawKey := p[:keyLen]
		keyStr := string(rawKey)
		if _, ok := seen[keyStr]; ok {
			return b, cborErrDuplicateMapKey
		}
		seen[keyStr] = struct{}{}
		// skip value
		p2, err := cborSkip(r)
		if err != nil {
			return b, err
		}
		p = p2
	}
	return p, nil
}

// ForEachSequenceBytes calls onItem for each CBOR item in a CBOR sequence buffer b.
// The item passed to onItem is a slice referencing b containing exactly one item.
func cborForEachSequenceBytes(b []byte, onItem func(item []byte) error) error {
	p := b
	for len(p) > 0 {
		r, err := cborSkip(p)
		if err != nil {
			return err
		}
		seg := p[:len(p)-len(r)]
		if err := onItem(seg); err != nil {
			return err
		}
		p = r
	}
	return nil
}

// SplitSequenceBytes splits a CBOR sequence into a slice of item slices referencing the original buffer.
func cborSplitSequenceBytes(b []byte) (out [][]byte, err error) {
	err = cborForEachSequenceBytes(b, func(it []byte) error { out = append(out, it); return nil })
	return out, err
}

// AppendSequence appends a sequence of pre-encoded CBOR items to b.
// Each item must be a complete CBOR data item.
func cborAppendSequence(b []byte, items ...[]byte) []byte {
	for _, it := range items {
		b = append(b, it...)
	}
	return b
}

// AppendSequenceFunc appends n items produced by fn(i), where each returned []byte is a full CBOR item.
func cborAppendSequenceFunc(b []byte, n int, fn func(i int) ([]byte, error)) ([]byte, error) {
	for i := 0; i < n; i++ {
		it, err := fn(i)
		if err != nil {
			return b, err
		}
		b = append(b, it...)
	}
	return b, nil
}

// ReadOrderedMapBytes reads the next CBOR map (definite or indefinite) and
// returns a slice of RawPair in the order they appeared on the wire.
// Each Key and Value contains exactly one CBOR item (copied).
func cborReadOrderedMapBytes(b []byte) (pairs []cborRawPair, o []byte, err error) {
	if len(b) < 1 {
		return nil, b, cborErrShortBytes
	}
	if cborgetMajorType(b[0]) != cbormajorTypeMap {
		return nil, b, cborbadPrefix(cbormajorTypeMap, cborgetMajorType(b[0]))
	}
	// Indefinite-length map
	if cborgetAddInfo(b[0]) == cboraddInfoIndefinite {
		p := b[1:]
		var scratch []byte
		for {
			if len(p) < 1 {
				return nil, b, cborErrShortBytes
			}
			if p[0] == cbormakeByte(cbormajorTypeSimple, cborsimpleBreak) {
				return pairs, p[1:], nil
			}
			// Capture raw key
			r1, err := cborSkip(p)
			if err != nil {
				return nil, b, err
			}
			klen := len(p) - len(r1)
			// Append key bytes into a shared scratch buffer and take a subslice
			startK := len(scratch)
			scratch = append(scratch, p[:klen]...)
			kraw := scratch[startK:]
			// Capture raw value
			r2, err := cborSkip(r1)
			if err != nil {
				return nil, b, err
			}
			vlen := len(r1) - len(r2)
			startV := len(scratch)
			scratch = append(scratch, r1[:vlen]...)
			vraw := scratch[startV:]
			pairs = append(pairs, cborRawPair{Key: kraw, Value: vraw})
			p = r2
		}
	}
	// Definite-length map
	sz, p, err := cborReadMapHeaderBytes(b)
	if err != nil {
		return nil, b, err
	}
	pairs = make([]cborRawPair, 0, sz)
	var scratch []byte
	for i := uint32(0); i < sz; i++ {
		r1, err := cborSkip(p)
		if err != nil {
			return nil, b, err
		}
		klen := len(p) - len(r1)
		startK := len(scratch)
		scratch = append(scratch, p[:klen]...)
		kraw := scratch[startK:]
		r2, err := cborSkip(r1)
		if err != nil {
			return nil, b, err
		}
		vlen := len(r1) - len(r2)
		startV := len(scratch)
		scratch = append(scratch, r1[:vlen]...)
		vraw := scratch[startV:]
		pairs = append(pairs, cborRawPair{Key: kraw, Value: vraw})
		p = r2
	}
	return pairs, p, nil
}

// float16BitsToFloat32 converts IEEE 754 binary16 bits to float32
func cborfloat16BitsToFloat32(h uint16) float32 {
	sign := uint32(h>>15) & 0x1
	exp := (h >> 10) & 0x1F
	mant := uint32(h & 0x03FF)
	var bits uint32
	switch exp {
	case 0:
		if mant == 0 {
			bits = sign << 31
		} else {
			// subnormal: value = mant / 2^10 * 2^-14 = mant * 2^-24
			// Build float by arithmetic
			f := math.Ldexp(float64(mant), -24)
			if sign != 0 {
				f = -f
			}
			return float32(f)
		}
	case 0x1F:
		// Inf/NaN
		bits = (sign << 31) | (0xFF << 23)
		if mant != 0 {
			bits |= (mant << 13)
		}
	default:
		// normalized
		e32 := int(exp) - 15 + 127
		bits = (sign << 31) | (uint32(e32) << 23) | (mant << 13)
	}
	return math.Float32frombits(bits)
}

// ReadDurationBytes reads a time.Duration
func cborReadDurationBytes(b []byte) (d time.Duration, o []byte, err error) {
	i64, o, err := cborReadInt64Bytes(b)
	if err != nil {
		return 0, b, err
	}
	return time.Duration(i64), o, nil
}

// ReadMapStrStrBytes reads a map[string]string
func cborReadMapStrStrBytes(b []byte, m map[string]string) (o []byte, err error) {
	sz, o, err := cborReadMapHeaderBytes(b)
	if err != nil {
		return b, err
	}

	for i := uint32(0); i < sz; i++ {
		var key, val string
		key, o, err = cborReadStringBytes(o)
		if err != nil {
			return b, err
		}
		val, o, err = cborReadStringBytes(o)
		if err != nil {
			return b, err
		}
		m[key] = val
	}
	return o, nil
}

// Skip skips over the next CBOR object
func cborSkip(b []byte) ([]byte, error) {
	return cborskip(b, 0)
}

func cborskip(b []byte, depth int) ([]byte, error) {
	if depth > cborrecursionLimit {
		return b, cborErrMaxDepthExceeded
	}
	if len(b) < 1 {
		return b, cborErrShortBytes
	}

	major := cborgetMajorType(b[0])
	addInfo := cborgetAddInfo(b[0])

	switch major {
	case cbormajorTypeUint, cbormajorTypeNegInt, cbormajorTypeTag:
		_, o, err := cborreadUintCore(b, major)
		if err != nil {
			return b, err
		}
		if major == cbormajorTypeTag {
			return cborskip(o, depth+1)
		}
		return o, nil

	case cbormajorTypeBytes, cbormajorTypeText:
		if addInfo == cboraddInfoIndefinite {
			// Indefinite-length string: series of definite chunks terminated by break
			o := b[1:]
			for {
				if len(o) < 1 {
					return b, cborErrShortBytes
				}
				if o[0] == cbormakeByte(cbormajorTypeSimple, cborsimpleBreak) {
					return o[1:], nil
				}
				// Next must be a definite-length chunk of same major type
				sz, q, err := cborreadUintCore(o, major)
				if err != nil {
					return b, err
				}
				if uint64(len(q)) < sz {
					return b, cborErrShortBytes
				}
				o = q[sz:]
			}
		}
		sz, o, err := cborreadUintCore(b, major)
		if err != nil {
			return b, err
		}
		if uint64(len(o)) < sz {
			return b, cborErrShortBytes
		}
		return o[sz:], nil

	case cbormajorTypeArray:
		if addInfo == cboraddInfoIndefinite {
			o := b[1:]
			for {
				if len(o) < 1 {
					return b, cborErrShortBytes
				}
				if o[0] == cbormakeByte(cbormajorTypeSimple, cborsimpleBreak) {
					return o[1:], nil
				}
				var err error
				o, err = cborskip(o, depth+1)
				if err != nil {
					return b, err
				}
			}
		}
		sz, o, err := cborreadUintCore(b, major)
		if err != nil {
			return b, err
		}
		for i := uint64(0); i < sz; i++ {
			o, err = cborskip(o, depth+1)
			if err != nil {
				return b, err
			}
		}
		return o, nil

	case cbormajorTypeMap:
		if addInfo == cboraddInfoIndefinite {
			o := b[1:]
			for {
				if len(o) < 1 {
					return b, cborErrShortBytes
				}
				if o[0] == cbormakeByte(cbormajorTypeSimple, cborsimpleBreak) {
					return o[1:], nil
				}
				var err error
				o, err = cborskip(o, depth+1) // key
				if err != nil {
					return b, err
				}
				o, err = cborskip(o, depth+1) // value
				if err != nil {
					return b, err
				}
			}
		}
		sz, o, err := cborreadUintCore(b, major)
		if err != nil {
			return b, err
		}
		for i := uint64(0); i < sz; i++ {
			o, err = cborskip(o, depth+1) // key
			if err != nil {
				return b, err
			}
			o, err = cborskip(o, depth+1) // value
			if err != nil {
				return b, err
			}
		}
		return o, nil

	case cbormajorTypeSimple:
		switch addInfo {
		case cborsimpleFalse, cborsimpleTrue, cborsimpleNull, cborsimpleUndefined:
			return b[1:], nil
		case cborsimpleFloat16:
			if len(b) < 3 {
				return b, cborErrShortBytes
			}
			return b[3:], nil
		case cborsimpleFloat32:
			if len(b) < 5 {
				return b, cborErrShortBytes
			}
			return b[5:], nil
		case cborsimpleFloat64:
			if len(b) < 9 {
				return b, cborErrShortBytes
			}
			return b[9:], nil
		default:
			if addInfo < 20 {
				return b[1:], nil
			}
			return b, &cborErrUnsupportedType{}
		}
	}

	return b, &cborErrUnsupportedType{}
}

// IsNil checks if the next value is nil
func cborIsNil(b []byte) bool {
	return len(b) > 0 && b[0] == cbormakeByte(cbormajorTypeSimple, cborsimpleNull)
}

// Raw is raw CBOR data
type cborRaw []byte

// MarshalCBOR implements Marshaler
func (r cborRaw) MarshalCBOR(b []byte) ([]byte, error) {
	if len(r) == 0 {
		return cborAppendNil(b), nil
	}
	return append(b, r...), nil
}

// UnmarshalCBOR implements Unmarshaler

// Reader provides a minimal slice-based CBOR reader. It is intended
// for use by generated DecodeMsg implementations and operates on
// an in-memory buffer.

// NewReaderBytes constructs a Reader over the provided buffer.

// SetStrictDecode controls whether the reader should enforce canonical
// length encodings for containers (arrays, maps, strings, bytes).

// SetDeterministicDecode controls whether certain non-deterministic
// features such as indefinite-length containers are forbidden.

// SetMaxContainerLen configures an upper bound on container lengths
// (arrays, maps, byte strings, text strings). A value of zero disables
// the limit. When exceeded, ErrContainerTooLarge is returned.

// Remaining returns the unread portion of the underlying buffer.

// ReadArrayHeader reads an array header and advances the buffer.
// When strict decoding is enabled, non-canonical length encodings
// (i.e., using a larger integer encoding than necessary) will be
// rejected with ErrNonCanonicalLength.

// ReadArrayStart reads an array start and indicates whether it is
// indefinite-length. When deterministic decoding is enabled,
// indefinite-length arrays are rejected with ErrIndefiniteForbidden.

// ReadMapHeader reads a map header and advances the buffer.
// In strict mode, non-canonical length encodings are rejected.

// ReadString reads a text string and advances the buffer.
// In strict mode, non-canonical length encodings are rejected.
// In deterministic mode, indefinite-length strings are forbidden.

// ReadInt reads an int and advances the buffer.
// In strict mode, it enforces canonical integer encodings for both
// positive and negative values.

// ReadBytes reads a byte string and advances the buffer.

// Skip skips over the next CBOR item and advances the buffer.

// ReadBool reads a bool and advances the buffer.

// ReadInt64 reads an int64 and advances the buffer.
// In strict mode, it enforces canonical integer encodings for both
// positive and negative values.

// ReadUint reads a uint and advances the buffer.
// In strict mode, it enforces canonical unsigned integer encodings.

// ReadUint64 reads a uint64 and advances the buffer.
// In strict mode, it enforces canonical unsigned integer encodings.

// ReadFloat32 reads a float32 and advances the buffer.

// ReadFloat64 reads a float64 and advances the buffer.

// isNonCanonicalLength reports whether the leading header in b for the
// given major type uses a non-minimal integer encoding for its length
// according to RFC 8949 canonicalization rules.

// Canonicality applies to definite lengths; indefinite is
// handled separately by deterministic mode.

// Direct additional info encodes 0..23 canonically.

// Worst-case encoded sizes for common types. For variable-length types
// such as strings and byte slices, the total encoded size is the
// corresponding prefix size plus the length of the value.

// UnsafeString returns a string that shares the same underlying
// memory as b. It must only be used in Trusted decode paths where
// the backing buffer is immutable for the lifetime of the string.

// UnsafeBytes returns the string as a byte slice. It is
// equivalent to []byte(s) and retained for compatibility.

// isUTF8Valid validates UTF-8 for a byte slice. It can be overridden by
// architecture-specific, SIMD-accelerated implementations via build tags.

// ValidateWellFormedBytes validates that the next CBOR data item in b is well-formed per RFC 8949
// and returns the remaining bytes after that item.
// Checks performed:
// - Structural correctness of arrays, maps, tags, simple values
// - String UTF-8 validity (for major type 3)
// - Prohibits reserved additional info values 28,29,30

// ValidateDocument validates that all items in b are well-formed until input is exhausted.

// Reserved additional info values 28, 29, 30 are not well-formed

// indefinite bytes: series of definite byte strings terminated by break

// chunk must be bytes

// accumulate chunks and validate utf-8 progressively

// chunk must be text

// definite string

// key

// value

// key

// value

// one-byte simple value (0xf8 xx)

// unassigned simple values are still well-formed

// ensure 'sz' extra bytes in 'b' btw len(b) and cap(b)

// exponential growth

// appendUintCore encodes an unsigned integer with the given major type

// AppendMapHeader appends a map header with the given size

// AppendArrayHeader appends an array header with the given size

// AppendArrayHeaderIndefinite appends an indefinite-length array header (0x9f)

// AppendNil appends a nil value

// AppendUndefined appends an undefined simple value (23)

// AppendTextHeaderIndefinite appends an indefinite-length text string header (0x7f)

// AppendBytesHeaderIndefinite appends an indefinite-length byte string header (0x5f)

// AppendTextChunk appends a definite-length text string chunk (use within indefinite text)

// AppendBytesChunk appends a definite-length byte string chunk (use within indefinite bytes)

// AppendFloat64 appends a float64

// AppendFloat32 appends a float32

// AppendFloatCanonical appends the shortest-width float (f16/f32/f64) that preserves the value.

// Normalize -0 to +0 for canonical

// NaN: canonicalize to float16 NaN

// Try f16

// Try f32

// AppendFloat16 appends a float16 (IEEE 754 binary16) encoded value

// AppendFloat appends a float as float32 if it represents the same value, else float64

// AppendDuration appends a time.Duration as int64

// AppendInt64 appends an int64 using canonical CBOR integer encoding.
//
// For small values in the common ranges we specialize the encoding
// inline rather than routing through appendUintCore. This mirrors the
// fast-path treatment used in the original tinylib/msgp runtime while
// preserving CBOR's major-type and additional-info layout.

// Fast path for small positive values 0..23 (single-byte encoding).

// Fast path for small negative values -1..-24. CBOR encodes
// negative integers as -1-n with unsigned argument n.

// n such that value = -1-n

// Remaining positive values go through the generic uint encoder.

// AppendInt appends an int

// AppendInt8 appends an int8

// AppendInt16 appends an int16

// AppendInt32 appends an int32

// AppendUint64 appends a uint64

// AppendUint appends a uint

// AppendUint8 appends a uint8

// AppendUint16 appends a uint16

// AppendUint32 appends a uint32

// AppendBytes appends a byte string

// Compute header size and reserve in one shot to avoid double ensure + copy

// Write header

// Copy payload

// AppendString appends a text string

// Compute header size and reserve once

// Write header

// Copy payload

// AppendStringFromBytes appends a string from bytes

// AppendBool appends a bool

// AppendSimpleValue appends a generic simple value.
// Values 0..23 are encoded in the additional information;
// values 32..255 are encoded as 0xf8 XX.
// Note: 24..27 are reserved for float encodings and are not handled here.

// 0xf8

// AppendTime appends a time.Time as CBOR tag 1 (epoch timestamp)

// AppendTag appends a generic semantic tag

// AppendTagged appends a tag followed by a pre-encoded value

// AppendRFC3339Time appends a tag(0) RFC3339 datetime string

// AppendBase64URLString appends tag(33) with a base64url text string payload

// AppendBase64String appends tag(34) with a base64 text string payload

// AppendURI appends a tag(32) URI text string

// AppendEmbeddedCBOR appends tag(24) with a byte string containing embedded CBOR payload

// AppendUUID appends tag(37) with a 16-byte UUID (RFC 4122) as byte string

// AppendRegexpString appends tag(35) with a regular expression pattern as text

// AppendMIMEString appends tag(36) with a MIME message as text

// AppendSelfDescribeCBOR appends the self-describe CBOR tag (0xd9d9f7)

// AppendRegexp appends tag(35) from a compiled *regexp.Regexp

// AppendBigInt appends a big integer using bignum tags (2 positive, 3 negative)

// Negative: encode n = -1 - value
// -z
// -z - 1

// appendCBORIntegerFromBigInt encodes a big.Int as the shortest CBOR integer or bignum.

// AppendDecimalFraction appends tag(4) decimal fraction [exponent, mantissa]

// AppendBigfloat appends tag(5) bigfloat [exponent, mantissa]

// AppendBase64URL appends tag(21) with a byte string payload

// AppendBase64 appends tag(22) with a byte string payload

// AppendBase16 appends tag(23) with a byte string payload

// float32ToFloat16Bits converts float32 to IEEE 754 binary16 representation (round to nearest even)

// NaN or Inf

// Inf

// ensure NaN payload

// zero or subnormal in f32 => maps to zero in f16 or very small subnormals (flush to zero)
// Treat as subnormal; result rounds to 0 for f16 granularity

// Normalized number
// Unbias exponent: e32 = exp-127; target e16 = e32 + 15

// overflow => Inf

// subnormal or underflow
// subnormal half: significand = (mant | 1<<23) >> (1 - e16 + 13)
// shift = 14 - e32 = 14 - (exp-127) = 141 - exp

// too small => zero

// add rounding bias before shifting to 10 bits

// round to even

// normal half
// round mantissa from 23 to 10 bits

// mantissa overflow rounded up exponent
// carry into exponent

// AppendMapStrStr appends a map[string]string

// AppendMapStrInterface appends a map[string]any

// AppendStringSlice appends a []string as a CBOR array of text strings.

// AppendMapUint64Marshaler appends map[uint64]T to a CBOR map, where T has
// a corresponding Marshaler implementation (either as value or pointer).
// This is intended for generated code to avoid dynamic map handling in
// AppendInterface for map[uint64]*Struct shapes like ConsumerState.Pending.

// AppendMapUint64Uint64 appends a map[uint64]uint64 as a CBOR map with
// uint64 keys and values. This is used for ConsumerState.Redelivered and
// avoids reflection or interface-based encoding.

// AppendPtrMarshaler appends a pointer to a value that implements
// Marshaler. If the pointer is nil, a CBOR null is written. This is
// primarily for generated code (cborgen) to avoid the generic
// AppendInterface path for pointer-to-struct fields.

// AppendSliceMarshaler appends a slice of values that have a corresponding
// Marshaler implementation to a CBOR array. It is intended for use by
// generated code (cborgen) to avoid per-element AppendInterface overhead.
//
// T may be a type that itself implements Marshaler or whose pointer type
// implements Marshaler (the common case for generated methods).

// AppendInterface appends an arbitrary value

// Treat RawMessage as an opaque CBOR byte string.

// Fallback: handle slices and maps of Marshaler types via reflection.

// Encode the key according to its kind.

// Prefer Marshaler if available. For common generated
// patterns that use pointer receivers on value fields,
// synthesize a pointer and try that before falling back
// to AppendInterface.

// Try pointer to value type.

// AppendMapStrStrDeterministic appends a map[string]string with keys sorted by encoded key bytes.

// AppendMapStrInterfaceDeterministic appends a map[string]any with keys sorted by encoded key bytes.

// AppendMapHeaderIndefinite appends an indefinite-length map header (0xbf)

// AppendBreak appends a break stop code (0xff)

// AppendRawMapDeterministic appends a map with entries provided as raw CBOR key/value pairs.
// Pairs are sorted by CBOR-encoded key bytes to ensure RFC 8949 deterministic order.

// Deterministic order: by encoded key length, then bytewise lexicographic.

// Bucket indices by key length.

// Adaptive: comparator is faster for smaller groups/short keys.

// AppendMapDeterministic appends a map[K]V deterministically.
// encKey appends the CBOR encoding of key k to dst and returns the extended dst.
// encVal appends the CBOR encoding of value v to dst and returns the extended dst.
// Keys are encoded once for sorting and then reused to avoid re-encoding.

// Use a single growing scratch buffer to hold all encoded keys.
// This reduces per-key allocations. Each keyEnc stores a subslice
// of the scratch at the moment of encoding; later growth may reallocate
// scratch, but the subslices retain references to the older backing arrays.

// Bucket by encoded key length, then LSD radix within groups.

// Adaptive: comparator wins for small groups/short keys

// Common key encoders (for AppendMapDeterministic)

// Common value encoders (for AppendMapDeterministic)

// EncValInterface appends an arbitrary value.

// Typed deterministic appenders for common key/value types

// Writer provides a minimal CBOR writer backed by ByteBuffer.
// It is intended for use by generated EncodeMsg implementations.

// NewWriter constructs a Writer that appends to the provided ByteBuffer.

// Bytes returns the underlying encoded bytes.

// WriteMapHeader writes a map header with the given size.

// WriteString writes a text string value.

// WriteBool writes a bool value.

// WriteInt writes an int value.

// WriteInt64 writes an int64 value.

// WriteUint writes a uint value.

// WriteUint64 writes a uint64 value.

// WriteFloat32 writes a float32 value.

// WriteFloat64 writes a float64 value.

// WriteBytes writes a byte string value.

func (r *cborRaw) UnmarshalCBOR(b []byte) ([]byte, error) {
	l := len(b)
	out, err := cborSkip(b)
	if err != nil {
		return b, err
	}
	rlen := l - len(out)
	if cborIsNil(b[:rlen]) {
		rlen = 0
	}
	if cap(*r) < rlen {
		*r = make(cborRaw, rlen)
	} else {
		*r = (*r)[0:rlen]
	}
	copy(*r, b[:rlen])
	return out, nil
}

type cborReader struct {
	buf           []byte
	strict        bool
	deterministic bool
	maxContainer  uint32
}

func cborNewReaderBytes(b []byte) *cborReader { return &cborReader{buf: b} }

func (r *cborReader) SetStrictDecode(strict bool) { r.strict = strict }

func (r *cborReader) SetDeterministicDecode(det bool) { r.deterministic = det }

func (r *cborReader) SetMaxContainerLen(max uint32) { r.maxContainer = max }

func (r *cborReader) Remaining() []byte { return r.buf }

func (r *cborReader) ReadArrayHeader() (uint32, error) {
	if len(r.buf) < 1 {
		return 0, cborErrShortBytes
	}
	if r.strict {
		nonCanon, err := cborisNonCanonicalArrayLength(r.buf)
		if err != nil {
			return 0, err
		}
		if nonCanon {
			return 0, cborErrNonCanonicalLength
		}
	}
	sz, rest, err := cborReadArrayHeaderBytes(r.buf)
	if err != nil {
		return 0, err
	}
	if r.maxContainer > 0 && sz > r.maxContainer {
		return 0, cborErrContainerTooLarge
	}
	r.buf = rest
	return sz, nil
}

func (r *cborReader) ReadArrayStart() (sz uint32, indefinite bool, err error) {
	sz, indef, rest, err := cborReadArrayStartBytes(r.buf)
	if err != nil {
		return 0, false, err
	}
	if indef && r.deterministic {
		return 0, false, cborErrIndefiniteForbidden
	}
	r.buf = rest
	return sz, indef, nil
}

func (r *cborReader) ReadMapHeader() (uint32, error) {
	if len(r.buf) < 1 {
		return 0, cborErrShortBytes
	}
	if r.strict {
		nonCanon, err := cborisNonCanonicalMapLength(r.buf)
		if err != nil {
			return 0, err
		}
		if nonCanon {
			return 0, cborErrNonCanonicalLength
		}
	}
	sz, rest, err := cborReadMapHeaderBytes(r.buf)
	if err != nil {
		return 0, err
	}
	if r.maxContainer > 0 && sz > r.maxContainer {
		return 0, cborErrContainerTooLarge
	}
	r.buf = rest
	return sz, nil
}

func (r *cborReader) ReadString() (string, error) {
	if len(r.buf) < 1 {
		return "", cborErrShortBytes
	}
	if r.strict {
		nonCanon, err := cborisNonCanonicalTextLength(r.buf)
		if err != nil {
			return "", err
		}
		if nonCanon {
			return "", cborErrNonCanonicalLength
		}
	}
	if r.deterministic && cborgetMajorType(r.buf[0]) == cbormajorTypeText && cborgetAddInfo(r.buf[0]) == cboraddInfoIndefinite {
		return "", cborErrIndefiniteForbidden
	}
	s, rest, err := cborReadStringBytes(r.buf)
	if err != nil {
		return "", err
	}
	r.buf = rest
	return s, nil
}

func (r *cborReader) ReadInt() (int, error) {
	if len(r.buf) < 1 {
		return 0, cborErrShortBytes
	}
	if r.strict {
		maj := cborgetMajorType(r.buf[0])
		if maj == cbormajorTypeUint || maj == cbormajorTypeNegInt {
			nonCanon, err := cborisNonCanonicalLength(r.buf, maj)
			if err != nil {
				return 0, err
			}
			if nonCanon {
				return 0, cborErrNonCanonicalLength
			}
		}
	}
	v, rest, err := cborReadIntBytes(r.buf)
	if err != nil {
		return 0, err
	}
	r.buf = rest
	return v, nil
}

func (r *cborReader) ReadBytes() ([]byte, error) {
	if len(r.buf) < 1 {
		return nil, cborErrShortBytes
	}
	if r.strict {
		nonCanon, err := cborisNonCanonicalBytesLength(r.buf)
		if err != nil {
			return nil, err
		}
		if nonCanon {
			return nil, cborErrNonCanonicalLength
		}
	}
	if r.deterministic && cborgetMajorType(r.buf[0]) == cbormajorTypeBytes && cborgetAddInfo(r.buf[0]) == cboraddInfoIndefinite {
		return nil, cborErrIndefiniteForbidden
	}
	v, rest, err := cborReadBytesBytes(r.buf, nil)
	if err != nil {
		return nil, err
	}
	r.buf = rest
	return v, nil
}

func (r *cborReader) Skip() error {
	rest, err := cborSkip(r.buf)
	if err != nil {
		return err
	}
	r.buf = rest
	return nil
}

func (r *cborReader) ReadBool() (bool, error) {
	v, rest, err := cborReadBoolBytes(r.buf)
	if err != nil {
		return false, err
	}
	r.buf = rest
	return v, nil
}

func (r *cborReader) ReadInt64() (int64, error) {
	if len(r.buf) < 1 {
		return 0, cborErrShortBytes
	}
	if r.strict {
		maj := cborgetMajorType(r.buf[0])
		if maj == cbormajorTypeUint || maj == cbormajorTypeNegInt {
			nonCanon, err := cborisNonCanonicalLength(r.buf, maj)
			if err != nil {
				return 0, err
			}
			if nonCanon {
				return 0, cborErrNonCanonicalLength
			}
		}
	}
	v, rest, err := cborReadInt64Bytes(r.buf)
	if err != nil {
		return 0, err
	}
	r.buf = rest
	return v, nil
}

func (r *cborReader) ReadUint() (uint, error) {
	if len(r.buf) < 1 {
		return 0, cborErrShortBytes
	}
	if r.strict && cborgetMajorType(r.buf[0]) == cbormajorTypeUint {
		nonCanon, err := cborisNonCanonicalLength(r.buf, cbormajorTypeUint)
		if err != nil {
			return 0, err
		}
		if nonCanon {
			return 0, cborErrNonCanonicalLength
		}
	}
	v, rest, err := cborReadUintBytes(r.buf)
	if err != nil {
		return 0, err
	}
	r.buf = rest
	return v, nil
}

func (r *cborReader) ReadUint64() (uint64, error) {
	if len(r.buf) < 1 {
		return 0, cborErrShortBytes
	}
	if r.strict && cborgetMajorType(r.buf[0]) == cbormajorTypeUint {
		nonCanon, err := cborisNonCanonicalLength(r.buf, cbormajorTypeUint)
		if err != nil {
			return 0, err
		}
		if nonCanon {
			return 0, cborErrNonCanonicalLength
		}
	}
	v, rest, err := cborReadUint64Bytes(r.buf)
	if err != nil {
		return 0, err
	}
	r.buf = rest
	return v, nil
}

func (r *cborReader) ReadFloat32() (float32, error) {
	orig := r.buf
	v, rest, err := cborReadFloat32Bytes(r.buf)
	if err != nil {
		return 0, err
	}
	if r.strict {
		canon := cborAppendFloatCanonical(nil, float64(v))
		encLen := len(orig) - len(rest)
		if encLen < 0 || encLen > len(orig) {
			return 0, cborErrShortBytes
		}
		if len(canon) != encLen || !bytes.Equal(orig[:encLen], canon) {
			return 0, cborErrNonCanonicalFloat
		}
	}
	r.buf = rest
	return v, nil
}

func (r *cborReader) ReadFloat64() (float64, error) {
	orig := r.buf
	v, rest, err := cborReadFloat64Bytes(r.buf)
	if err != nil {
		return 0, err
	}
	if r.strict {
		canon := cborAppendFloatCanonical(nil, v)
		encLen := len(orig) - len(rest)
		if encLen < 0 || encLen > len(orig) {
			return 0, cborErrShortBytes
		}
		if len(canon) != encLen || !bytes.Equal(orig[:encLen], canon) {
			return 0, cborErrNonCanonicalFloat
		}
	}
	r.buf = rest
	return v, nil
}

func cborisNonCanonicalLength(b []byte, expectedMajor uint8) (bool, error) {
	if len(b) < 1 {
		return false, cborErrShortBytes
	}
	if cborgetMajorType(b[0]) != expectedMajor {
		return false, cborbadPrefix(cborgetMajorType(b[0]), expectedMajor)
	}
	add := cborgetAddInfo(b[0])
	switch add {
	case cboraddInfoIndefinite:

		return false, nil
	case 0, 1, 2, 3, 4, 5, 6, 7,
		8, 9, 10, 11, 12, 13, 14, 15,
		16, 17, 18, 19, 20, 21, 22, 23:

		return false, nil
	case cboraddInfoUint8:
		if len(b) < 2 {
			return false, cborErrShortBytes
		}
		v := uint64(b[1])
		if v <= 23 {
			return true, nil
		}
		return false, nil
	case cboraddInfoUint16:
		if len(b) < 3 {
			return false, cborErrShortBytes
		}
		v := uint64(binary.BigEndian.Uint16(b[1:]))
		if v <= math.MaxUint8 {
			return true, nil
		}
		return false, nil
	case cboraddInfoUint32:
		if len(b) < 5 {
			return false, cborErrShortBytes
		}
		v := uint64(binary.BigEndian.Uint32(b[1:]))
		if v <= math.MaxUint16 {
			return true, nil
		}
		return false, nil
	case cboraddInfoUint64:
		if len(b) < 9 {
			return false, cborErrShortBytes
		}
		v := binary.BigEndian.Uint64(b[1:])
		if v <= math.MaxUint32 {
			return true, nil
		}
		return false, nil
	default:
		return false, &cborErrUnsupportedType{}
	}
}

func cborisNonCanonicalArrayLength(b []byte) (bool, error) {
	return cborisNonCanonicalLength(b, cbormajorTypeArray)
}
func cborisNonCanonicalMapLength(b []byte) (bool, error) {
	return cborisNonCanonicalLength(b, cbormajorTypeMap)
}
func cborisNonCanonicalBytesLength(b []byte) (bool, error) {
	return cborisNonCanonicalLength(b, cbormajorTypeBytes)
}
func cborisNonCanonicalTextLength(b []byte) (bool, error) {
	return cborisNonCanonicalLength(b, cbormajorTypeText)
}

const (
	cborInt64Size           = 9
	cborIntSize             = cborInt64Size
	cborUintSize            = cborInt64Size
	cborInt8Size            = 2
	cborInt16Size           = 3
	cborInt32Size           = 5
	cborUint8Size           = 2
	cborUint16Size          = 3
	cborUint32Size          = 5
	cborUint64Size          = cborInt64Size
	cborFloat64Size         = 9
	cborFloat32Size         = 5
	cborDurationSize        = cborInt64Size
	cborTimeSize            = 15
	cborBoolSize            = 1
	cborNilSize             = 1
	cborMapHeaderSize       = 5
	cborArrayHeaderSize     = 5
	cborBytesPrefixSize     = 5
	cborStringPrefixSize    = 5
	cborExtensionPrefixSize = 6
)

func cborUnsafeString(b []byte) string {
	return *(*string)(unsafe.Pointer(&b))
}

func cborUnsafeBytes(s string) []byte { return []byte(s) }

var cborisUTF8Valid = func(b []byte) bool { return utf8.Valid(b) }

func cborValidateWellFormedBytes(b []byte) (rest []byte, err error) {
	return cborvalidateWellFormed(b, 0)
}

func cborValidateDocument(b []byte) error {
	var err error
	for len(b) > 0 {
		b, err = cborvalidateWellFormed(b, 0)
		if err != nil {
			return err
		}
	}
	return nil
}

func cborvalidateWellFormed(b []byte, depth int) ([]byte, error) {
	if depth > cborrecursionLimit {
		return b, cborErrMaxDepthExceeded
	}
	if len(b) < 1 {
		return b, cborErrShortBytes
	}
	lead := b[0]
	major := cborgetMajorType(lead)
	add := cborgetAddInfo(lead)

	if add == 28 || add == 29 || add == 30 {
		return b, cborInvalidPrefixError{Want: major, Got: major}
	}

	switch major {
	case cbormajorTypeUint, cbormajorTypeNegInt, cbormajorTypeTag:
		_, o, err := cborreadUintCore(b, major)
		if err != nil {
			return b, err
		}
		if major == cbormajorTypeTag {
			return cborvalidateWellFormed(o, depth+1)
		}
		return o, nil

	case cbormajorTypeBytes:
		if add == cboraddInfoIndefinite {

			p := b[1:]
			for {
				if len(p) < 1 {
					return b, cborErrShortBytes
				}
				if p[0] == cbormakeByte(cbormajorTypeSimple, cborsimpleBreak) {
					return p[1:], nil
				}

				sz, o, err := cborreadUintCore(p, cbormajorTypeBytes)
				if err != nil {
					return b, err
				}
				if uint64(len(o)) < sz {
					return b, cborErrShortBytes
				}
				p = o[sz:]
			}
		}
		sz, o, err := cborreadUintCore(b, cbormajorTypeBytes)
		if err != nil {
			return b, err
		}
		if uint64(len(o)) < sz {
			return b, cborErrShortBytes
		}
		return o[sz:], nil

	case cbormajorTypeText:
		if add == cboraddInfoIndefinite {
			p := b[1:]

			for {
				if len(p) < 1 {
					return b, cborErrShortBytes
				}
				if p[0] == cbormakeByte(cbormajorTypeSimple, cborsimpleBreak) {
					return p[1:], nil
				}

				chunk, o, err := cborReadStringZC(p)
				if err != nil {
					return b, err
				}
				if !cborisUTF8Valid(chunk) {
					return b, cborErrInvalidUTF8
				}
				p = o
			}
		}

		s, o, err := cborReadStringZC(b)
		if err != nil {
			return b, err
		}
		if !cborisUTF8Valid(s) {
			return b, cborErrInvalidUTF8
		}
		return o, nil

	case cbormajorTypeArray:
		if add == cboraddInfoIndefinite {
			p := b[1:]
			for {
				if len(p) < 1 {
					return b, cborErrShortBytes
				}
				if p[0] == cbormakeByte(cbormajorTypeSimple, cborsimpleBreak) {
					return p[1:], nil
				}
				var err error
				p, err = cborvalidateWellFormed(p, depth+1)
				if err != nil {
					return b, err
				}
			}
		}
		sz, p, err := cborreadUintCore(b, cbormajorTypeArray)
		if err != nil {
			return b, err
		}
		for i := uint64(0); i < sz; i++ {
			p, err = cborvalidateWellFormed(p, depth+1)
			if err != nil {
				return b, err
			}
		}
		return p, nil

	case cbormajorTypeMap:
		if add == cboraddInfoIndefinite {
			p := b[1:]
			for {
				if len(p) < 1 {
					return b, cborErrShortBytes
				}
				if p[0] == cbormakeByte(cbormajorTypeSimple, cborsimpleBreak) {
					return p[1:], nil
				}
				var err error
				p, err = cborvalidateWellFormed(p, depth+1)
				if err != nil {
					return b, err
				}
				p, err = cborvalidateWellFormed(p, depth+1)
				if err != nil {
					return b, err
				}
			}
		}
		sz, p, err := cborreadUintCore(b, cbormajorTypeMap)
		if err != nil {
			return b, err
		}
		for i := uint64(0); i < sz; i++ {
			p, err = cborvalidateWellFormed(p, depth+1)
			if err != nil {
				return b, err
			}
			p, err = cborvalidateWellFormed(p, depth+1)
			if err != nil {
				return b, err
			}
		}
		return p, nil

	case cbormajorTypeSimple:
		switch add {
		case cborsimpleFalse, cborsimpleTrue, cborsimpleNull, cborsimpleUndefined:
			return b[1:], nil
		case cborsimpleFloat16:
			if len(b) < 3 {
				return b, cborErrShortBytes
			}
			return b[3:], nil
		case cborsimpleFloat32:
			if len(b) < 5 {
				return b, cborErrShortBytes
			}
			return b[5:], nil
		case cborsimpleFloat64:
			if len(b) < 9 {
				return b, cborErrShortBytes
			}
			return b[9:], nil
		case cboraddInfoUint8:
			if len(b) < 2 {
				return b, cborErrShortBytes
			}
			return b[2:], nil
		default:
			if add < 20 {
				return b[1:], nil
			}
			return b, &cborErrUnsupportedType{}
		}
	}
	return b, &cborErrUnsupportedType{}
}

func cborensure(b []byte, sz int) ([]byte, int) {
	l := len(b)
	c := cap(b)
	if c-l < sz {
		o := make([]byte, (2*c)+sz)
		n := copy(o, b)
		return o[:n+sz], n
	}
	return b[:l+sz], l
}

func cborappendUintCore(b []byte, majorType uint8, u uint64) []byte {
	switch {
	case u <= cboraddInfoDirect:
		return append(b, cbormakeByte(majorType, uint8(u)))
	case u <= math.MaxUint8:
		o, n := cborensure(b, 2)
		o[n] = cbormakeByte(majorType, cboraddInfoUint8)
		o[n+1] = uint8(u)
		return o
	case u <= math.MaxUint16:
		o, n := cborensure(b, 3)
		o[n] = cbormakeByte(majorType, cboraddInfoUint16)
		binary.BigEndian.PutUint16(o[n+1:], uint16(u))
		return o
	case u <= math.MaxUint32:
		o, n := cborensure(b, 5)
		o[n] = cbormakeByte(majorType, cboraddInfoUint32)
		binary.BigEndian.PutUint32(o[n+1:], uint32(u))
		return o
	default:
		o, n := cborensure(b, 9)
		o[n] = cbormakeByte(majorType, cboraddInfoUint64)
		binary.BigEndian.PutUint64(o[n+1:], u)
		return o
	}
}

func cborAppendMapHeader(b []byte, sz uint32) []byte {
	return cborappendUintCore(b, cbormajorTypeMap, uint64(sz))
}

func cborAppendArrayHeader(b []byte, sz uint32) []byte {
	return cborappendUintCore(b, cbormajorTypeArray, uint64(sz))
}

func cborAppendArrayHeaderIndefinite(b []byte) []byte {
	return append(b, cbormakeByte(cbormajorTypeArray, cboraddInfoIndefinite))
}

func cborAppendNil(b []byte) []byte {
	return append(b, cbormakeByte(cbormajorTypeSimple, cborsimpleNull))
}

func cborAppendUndefined(b []byte) []byte {
	return append(b, cbormakeByte(cbormajorTypeSimple, cborsimpleUndefined))
}

func cborAppendTextHeaderIndefinite(b []byte) []byte {
	return append(b, cbormakeByte(cbormajorTypeText, cboraddInfoIndefinite))
}

func cborAppendBytesHeaderIndefinite(b []byte) []byte {
	return append(b, cbormakeByte(cbormajorTypeBytes, cboraddInfoIndefinite))
}

func cborAppendTextChunk(b []byte, s string) []byte { return cborAppendString(b, s) }

func cborAppendBytesChunk(b []byte, bs []byte) []byte { return cborAppendBytes(b, bs) }

func cborAppendFloat64(b []byte, f float64) []byte {
	o, n := cborensure(b, 9)
	o[n] = cbormakeByte(cbormajorTypeSimple, cborsimpleFloat64)
	binary.BigEndian.PutUint64(o[n+1:], math.Float64bits(f))
	return o
}

func cborAppendFloat32(b []byte, f float32) []byte {
	o, n := cborensure(b, 5)
	o[n] = cbormakeByte(cbormajorTypeSimple, cborsimpleFloat32)
	binary.BigEndian.PutUint32(o[n+1:], math.Float32bits(f))
	return o
}

func cborAppendFloatCanonical(b []byte, f float64) []byte {

	if f == 0 && math.Signbit(f) {
		f = 0
	}

	if math.IsNaN(f) {
		return cborAppendFloat16(b, float32(f))
	}

	f16 := cborfloat32ToFloat16Bits(float32(f))
	if float64(cborfloat16BitsToFloat32(f16)) == f {
		return cborAppendFloat16(b, float32(f))
	}

	f32 := float32(f)
	if float64(f32) == f {
		return cborAppendFloat32(b, f32)
	}
	return cborAppendFloat64(b, f)
}

func cborAppendFloat16(b []byte, f float32) []byte {
	o, n := cborensure(b, 3)
	o[n] = cbormakeByte(cbormajorTypeSimple, cborsimpleFloat16)
	binary.BigEndian.PutUint16(o[n+1:], cborfloat32ToFloat16Bits(f))
	return o
}

func cborAppendFloat(b []byte, f float64) []byte {
	f32 := float32(f)
	if float64(f32) == f {
		return cborAppendFloat32(b, f32)
	}
	return cborAppendFloat64(b, f)
}

func cborAppendDuration(b []byte, d time.Duration) []byte {
	return cborAppendInt64(b, int64(d))
}

func cborAppendInt64(b []byte, i int64) []byte {

	if i >= 0 && i <= cboraddInfoDirect {
		return append(b, cbormakeByte(cbormajorTypeUint, uint8(i)))
	}

	if i < 0 {
		neg := -1 - i
		if neg >= 0 && neg <= cboraddInfoDirect {
			return append(b, cbormakeByte(cbormajorTypeNegInt, uint8(neg)))
		}
		return cborappendUintCore(b, cbormajorTypeNegInt, uint64(neg))
	}

	return cborappendUintCore(b, cbormajorTypeUint, uint64(i))
}

func cborAppendInt(b []byte, i int) []byte {
	return cborAppendInt64(b, int64(i))
}

func cborAppendInt8(b []byte, i int8) []byte {
	return cborAppendInt64(b, int64(i))
}

func cborAppendInt16(b []byte, i int16) []byte {
	return cborAppendInt64(b, int64(i))
}

func cborAppendInt32(b []byte, i int32) []byte {
	return cborAppendInt64(b, int64(i))
}

func cborAppendUint64(b []byte, u uint64) []byte {
	return cborappendUintCore(b, cbormajorTypeUint, u)
}

func cborAppendUint(b []byte, u uint) []byte {
	return cborAppendUint64(b, uint64(u))
}

func cborAppendUint8(b []byte, u uint8) []byte {
	return cborappendUintCore(b, cbormajorTypeUint, uint64(u))
}

func cborAppendUint16(b []byte, u uint16) []byte {
	return cborappendUintCore(b, cbormajorTypeUint, uint64(u))
}

func cborAppendUint32(b []byte, u uint32) []byte {
	return cborappendUintCore(b, cbormajorTypeUint, uint64(u))
}

func cborAppendBytes(b []byte, data []byte) []byte {
	sz := uint64(len(data))

	var h int
	switch {
	case sz <= cboraddInfoDirect:
		h = 1
	case sz <= math.MaxUint8:
		h = 2
	case sz <= math.MaxUint16:
		h = 3
	case sz <= math.MaxUint32:
		h = 5
	default:
		h = 9
	}
	o, n := cborensure(b, h+int(sz))

	switch h {
	case 1:
		o[n] = cbormakeByte(cbormajorTypeBytes, uint8(sz))
		n++
	case 2:
		o[n] = cbormakeByte(cbormajorTypeBytes, cboraddInfoUint8)
		o[n+1] = uint8(sz)
		n += 2
	case 3:
		o[n] = cbormakeByte(cbormajorTypeBytes, cboraddInfoUint16)
		binary.BigEndian.PutUint16(o[n+1:], uint16(sz))
		n += 3
	case 5:
		o[n] = cbormakeByte(cbormajorTypeBytes, cboraddInfoUint32)
		binary.BigEndian.PutUint32(o[n+1:], uint32(sz))
		n += 5
	case 9:
		o[n] = cbormakeByte(cbormajorTypeBytes, cboraddInfoUint64)
		binary.BigEndian.PutUint64(o[n+1:], sz)
		n += 9
	}

	copy(o[n:], data)
	return o[:n+int(sz)]
}

func cborAppendString(b []byte, s string) []byte {
	sz := uint64(len(s))

	var h int
	switch {
	case sz <= cboraddInfoDirect:
		h = 1
	case sz <= math.MaxUint8:
		h = 2
	case sz <= math.MaxUint16:
		h = 3
	case sz <= math.MaxUint32:
		h = 5
	default:
		h = 9
	}
	o, n := cborensure(b, h+int(sz))

	switch h {
	case 1:
		o[n] = cbormakeByte(cbormajorTypeText, uint8(sz))
		n++
	case 2:
		o[n] = cbormakeByte(cbormajorTypeText, cboraddInfoUint8)
		o[n+1] = uint8(sz)
		n += 2
	case 3:
		o[n] = cbormakeByte(cbormajorTypeText, cboraddInfoUint16)
		binary.BigEndian.PutUint16(o[n+1:], uint16(sz))
		n += 3
	case 5:
		o[n] = cbormakeByte(cbormajorTypeText, cboraddInfoUint32)
		binary.BigEndian.PutUint32(o[n+1:], uint32(sz))
		n += 5
	case 9:
		o[n] = cbormakeByte(cbormajorTypeText, cboraddInfoUint64)
		binary.BigEndian.PutUint64(o[n+1:], sz)
		n += 9
	}

	copy(o[n:], s)
	return o[:n+int(sz)]
}

func cborAppendStringFromBytes(b []byte, data []byte) []byte {
	sz := uint64(len(data))
	b = cborappendUintCore(b, cbormajorTypeText, sz)
	return append(b, data...)
}

func cborAppendBool(b []byte, val bool) []byte {
	if val {
		return append(b, cbormakeByte(cbormajorTypeSimple, cborsimpleTrue))
	}
	return append(b, cbormakeByte(cbormajorTypeSimple, cborsimpleFalse))
}

func cborAppendSimpleValue(b []byte, val uint8) []byte {
	switch {
	case val <= cboraddInfoDirect:
		return append(b, cbormakeByte(cbormajorTypeSimple, val))
	default:
		o, n := cborensure(b, 2)
		o[n] = cbormakeByte(cbormajorTypeSimple, cboraddInfoUint8)
		o[n+1] = val
		return o
	}
}

func cborAppendTime(b []byte, t time.Time) []byte {
	b = cborAppendTag(b, cbortagEpochDateTime)
	sec := t.Unix()
	nsec := t.Nanosecond()
	if nsec == 0 {
		return cborAppendInt64(b, sec)
	}
	f := float64(sec) + float64(nsec)/1e9
	return cborAppendFloat64(b, f)
}

func cborAppendTag(b []byte, tag uint64) []byte {
	return cborappendUintCore(b, cbormajorTypeTag, tag)
}

func cborAppendTagged(b []byte, tag uint64, value []byte) []byte {
	b = cborAppendTag(b, tag)
	return append(b, value...)
}

func cborAppendRFC3339Time(b []byte, t time.Time) []byte {
	b = cborAppendTag(b, cbortagDateTimeString)
	return cborAppendString(b, t.Format(time.RFC3339Nano))
}

func cborAppendBase64URLString(b []byte, s string) []byte {
	b = cborAppendTag(b, cbortagBase64URLString)
	return cborAppendString(b, s)
}

func cborAppendBase64String(b []byte, s string) []byte {
	b = cborAppendTag(b, cbortagBase64String)
	return cborAppendString(b, s)
}

func cborAppendURI(b []byte, uri string) []byte {
	b = cborAppendTag(b, cbortagURI)
	return cborAppendString(b, uri)
}

func cborAppendEmbeddedCBOR(b []byte, payload []byte) []byte {
	b = cborAppendTag(b, cbortagCBOR)
	return cborAppendBytes(b, payload)
}

func cborAppendUUID(b []byte, uuid [16]byte) []byte {
	b = cborAppendTag(b, 37)
	return cborAppendBytes(b, uuid[:])
}

func cborAppendRegexpString(b []byte, re string) []byte {
	b = cborAppendTag(b, cbortagRegexp)
	return cborAppendString(b, re)
}

func cborAppendMIMEString(b []byte, mime string) []byte {
	b = cborAppendTag(b, cbortagMIME)
	return cborAppendString(b, mime)
}

func cborAppendSelfDescribeCBOR(b []byte) []byte {
	return cborappendUintCore(b, cbormajorTypeTag, cbortagSelfDescribeCBOR)
}

func cborAppendRegexp(b []byte, re *regexp.Regexp) []byte {
	if re == nil {
		return cborAppendNil(b)
	}
	return cborAppendRegexpString(b, re.String())
}

func cborAppendBigInt(b []byte, z *bigmath.Int) []byte {
	if z == nil {
		return cborAppendNil(b)
	}
	if z.Sign() >= 0 {
		b = cborAppendTag(b, cbortagPosBignum)
		return cborAppendBytes(b, z.Bytes())
	}

	tmp := new(bigmath.Int).Neg(z)
	tmp.Sub(tmp, bigmath.NewInt(1))
	b = cborAppendTag(b, cbortagNegBignum)
	return cborAppendBytes(b, tmp.Bytes())
}

func cborappendCBORIntegerFromBigInt(b []byte, z *bigmath.Int) []byte {
	if z == nil {
		return cborAppendNil(b)
	}
	if z.Sign() >= 0 && z.BitLen() <= 64 {
		return cborAppendUint64(b, z.Uint64())
	}
	if z.Sign() < 0 && z.BitLen() <= 63 {
		return cborAppendInt64(b, z.Int64())
	}
	return cborAppendBigInt(b, z)
}

func cborAppendDecimalFraction(b []byte, exponent int64, mantissa *bigmath.Int) []byte {
	b = cborAppendTag(b, cbortagDecimalFrac)
	b = cborAppendArrayHeader(b, 2)
	b = cborAppendInt64(b, exponent)
	b = cborappendCBORIntegerFromBigInt(b, mantissa)
	return b
}

func cborAppendBigfloat(b []byte, exponent int64, mantissa *bigmath.Int) []byte {
	b = cborAppendTag(b, cbortagBigfloat)
	b = cborAppendArrayHeader(b, 2)
	b = cborAppendInt64(b, exponent)
	b = cborappendCBORIntegerFromBigInt(b, mantissa)
	return b
}

func cborAppendBase64URL(b []byte, data []byte) []byte {
	b = cborAppendTag(b, cbortagBase64URL)
	return cborAppendBytes(b, data)
}

func cborAppendBase64(b []byte, data []byte) []byte {
	b = cborAppendTag(b, cbortagBase64)
	return cborAppendBytes(b, data)
}

func cborAppendBase16(b []byte, data []byte) []byte {
	b = cborAppendTag(b, cbortagBase16)
	return cborAppendBytes(b, data)
}

func cborfloat32ToFloat16Bits(f float32) uint16 {
	bits := math.Float32bits(f)
	sign := uint16((bits >> 31) & 0x1)
	exp := int((bits >> 23) & 0xFF)
	mant := bits & 0x7FFFFF

	var h uint16
	switch exp {
	case 0xFF:
		if mant == 0 {
			h = (0x1F << 10)
		} else {
			h = (0x1F << 10) | uint16(mant>>13)
			if h&0x03FF == 0 {
				h |= 1
			}
		}
	case 0:

		h = 0
	default:

		e32 := exp - 127
		e16 := e32 + 15
		if e16 >= 0x1F {
			h = (0x1F << 10)
		} else if e16 <= 0 {

			shift := 14 - e32
			if shift > 24 {
				h = 0
			} else {
				mantissa := (mant | 1<<23)

				round := uint32(1) << (shift - 1)
				val := uint32(mantissa)
				val += round - 1 + ((val >> (shift)) & 1)
				frac := uint16(val >> shift)
				h = frac & 0x03FF
			}
		} else {

			mantR := mant
			round := uint32(1) << 12
			val := mantR + round - 1 + ((mantR >> 13) & 1)
			frac := uint16(val >> 13)
			h = (uint16(e16) << 10) | (frac & 0x03FF)
			if frac>>10 != 0 {

				e16++
				if e16 >= 0x1F {
					h = (0x1F << 10)
				} else {
					h = (uint16(e16) << 10)
				}
			}
		}
	}
	return (sign << 15) | h
}

func cborAppendMapStrStr(b []byte, m map[string]string) []byte {
	sz := uint32(len(m))
	b = cborAppendMapHeader(b, sz)
	for key, val := range m {
		b = cborAppendString(b, key)
		b = cborAppendString(b, val)
	}
	return b
}

func cborAppendMapStrInterface(b []byte, m map[string]any) ([]byte, error) {
	sz := uint32(len(m))
	b = cborAppendMapHeader(b, sz)
	for key, val := range m {
		b = cborAppendString(b, key)
		var err error
		b, err = cborAppendInterface(b, val)
		if err != nil {
			return b, err
		}
	}
	return b, nil
}

func cborAppendStringSlice(b []byte, v []string) []byte {
	b = cborAppendArrayHeader(b, uint32(len(v)))
	for _, s := range v {
		b = cborAppendString(b, s)
	}
	return b
}

func cborAppendMapUint64Marshaler[T any](b []byte, m map[uint64]T) ([]byte, error) {
	b = cborAppendMapHeader(b, uint32(len(m)))
	var err error
	for k, v := range m {
		b = cborAppendUint64(b, k)
		var mval cborMarshaler
		if mm, ok := any(v).(cborMarshaler); ok {
			mval = mm
		} else if mm, ok := any(&v).(cborMarshaler); ok {
			mval = mm
		} else {
			return b, &cborErrUnsupportedType{}
		}
		b, err = mval.MarshalCBOR(b)
		if err != nil {
			return b, err
		}
	}
	return b, nil
}

func cborAppendMapUint64Uint64(b []byte, m map[uint64]uint64) []byte {
	b = cborAppendMapHeader(b, uint32(len(m)))
	for k, v := range m {
		b = cborAppendUint64(b, k)
		b = cborAppendUint64(b, v)
	}
	return b
}

func cborAppendPtrMarshaler[T any](b []byte, v *T) ([]byte, error) {
	if v == nil {
		return cborAppendNil(b), nil
	}
	if m, ok := any(v).(cborMarshaler); ok {
		return m.MarshalCBOR(b)
	}
	return b, &cborErrUnsupportedType{}
}

func cborAppendSliceMarshaler[T any](b []byte, v []T) ([]byte, error) {
	b = cborAppendArrayHeader(b, uint32(len(v)))
	var err error
	for i := range v {
		var m cborMarshaler
		if mm, ok := any(v[i]).(cborMarshaler); ok {
			m = mm
		} else if mm, ok := any(&v[i]).(cborMarshaler); ok {
			m = mm
		} else {
			return b, &cborErrUnsupportedType{}
		}
		b, err = m.MarshalCBOR(b)
		if err != nil {
			return b, err
		}
	}
	return b, nil
}

func cborAppendInterface(b []byte, i any) ([]byte, error) {
	if i == nil {
		return cborAppendNil(b), nil
	}

	switch v := i.(type) {
	case cborMarshaler:
		return v.MarshalCBOR(b)
	case string:
		return cborAppendString(b, v), nil
	case bool:
		return cborAppendBool(b, v), nil
	case int:
		return cborAppendInt(b, v), nil
	case int8:
		return cborAppendInt8(b, v), nil
	case int16:
		return cborAppendInt16(b, v), nil
	case int32:
		return cborAppendInt32(b, v), nil
	case int64:
		return cborAppendInt64(b, v), nil
	case uint:
		return cborAppendUint(b, v), nil
	case uint8:
		return cborAppendUint8(b, v), nil
	case uint16:
		return cborAppendUint16(b, v), nil
	case uint32:
		return cborAppendUint32(b, v), nil
	case uint64:
		return cborAppendUint64(b, v), nil
	case float32:
		return cborAppendFloat32(b, v), nil
	case float64:
		return cborAppendFloat64(b, v), nil
	case []byte:
		return cborAppendBytes(b, v), nil
	case time.Time:
		return cborAppendTime(b, v), nil
	case time.Duration:
		return cborAppendDuration(b, v), nil
	case []int:
		b = cborAppendArrayHeader(b, uint32(len(v)))
		for _, elem := range v {
			b = cborAppendInt(b, elem)
		}
		return b, nil
	case []int8:
		b = cborAppendArrayHeader(b, uint32(len(v)))
		for _, elem := range v {
			b = cborAppendInt8(b, elem)
		}
		return b, nil
	case []int16:
		b = cborAppendArrayHeader(b, uint32(len(v)))
		for _, elem := range v {
			b = cborAppendInt16(b, elem)
		}
		return b, nil
	case []int32:
		b = cborAppendArrayHeader(b, uint32(len(v)))
		for _, elem := range v {
			b = cborAppendInt32(b, elem)
		}
		return b, nil
	case []int64:
		b = cborAppendArrayHeader(b, uint32(len(v)))
		for _, elem := range v {
			b = cborAppendInt64(b, elem)
		}
		return b, nil
	case []uint:
		b = cborAppendArrayHeader(b, uint32(len(v)))
		for _, elem := range v {
			b = cborAppendUint(b, elem)
		}
		return b, nil
	case []uint16:
		b = cborAppendArrayHeader(b, uint32(len(v)))
		for _, elem := range v {
			b = cborAppendUint16(b, elem)
		}
		return b, nil
	case []uint32:
		b = cborAppendArrayHeader(b, uint32(len(v)))
		for _, elem := range v {
			b = cborAppendUint32(b, elem)
		}
		return b, nil
	case []uint64:
		b = cborAppendArrayHeader(b, uint32(len(v)))
		for _, elem := range v {
			b = cborAppendUint64(b, elem)
		}
		return b, nil
	case []float32:
		b = cborAppendArrayHeader(b, uint32(len(v)))
		for _, elem := range v {
			b = cborAppendFloat32(b, elem)
		}
		return b, nil
	case []float64:
		b = cborAppendArrayHeader(b, uint32(len(v)))
		for _, elem := range v {
			b = cborAppendFloat64(b, elem)
		}
		return b, nil
	case []string:
		b = cborAppendArrayHeader(b, uint32(len(v)))
		for _, elem := range v {
			b = cborAppendString(b, elem)
		}
		return b, nil
	case map[string]int:
		b = cborAppendMapHeader(b, uint32(len(v)))
		for k, val := range v {
			b = cborAppendString(b, k)
			b = cborAppendInt(b, val)
		}
		return b, nil
	case map[string]int64:
		b = cborAppendMapHeader(b, uint32(len(v)))
		for k, val := range v {
			b = cborAppendString(b, k)
			b = cborAppendInt64(b, val)
		}
		return b, nil
	case map[string]uint:
		b = cborAppendMapHeader(b, uint32(len(v)))
		for k, val := range v {
			b = cborAppendString(b, k)
			b = cborAppendUint(b, val)
		}
		return b, nil
	case map[string]uint64:
		b = cborAppendMapHeader(b, uint32(len(v)))
		for k, val := range v {
			b = cborAppendString(b, k)
			b = cborAppendUint64(b, val)
		}
		return b, nil
	case map[string]float64:
		b = cborAppendMapHeader(b, uint32(len(v)))
		for k, val := range v {
			b = cborAppendString(b, k)
			b = cborAppendFloat64(b, val)
		}
		return b, nil
	case map[string]string:
		b = cborAppendMapHeader(b, uint32(len(v)))
		for k, val := range v {
			b = cborAppendString(b, k)
			b = cborAppendString(b, val)
		}
		return b, nil
	case json.RawMessage:

		return cborAppendBytes(b, []byte(v)), nil
	case json.Number:
		if iv, err := v.Int64(); err == nil {
			return cborAppendInt64(b, iv), nil
		}
		if fv, err := v.Float64(); err == nil {
			return cborAppendFloat64(b, fv), nil
		}
		return b, &cborErrUnsupportedType{}
	case map[string]any:
		return cborAppendMapStrInterface(b, v)
	case []any:
		b = cborAppendArrayHeader(b, uint32(len(v)))
		var err error
		for _, elem := range v {
			b, err = cborAppendInterface(b, elem)
			if err != nil {
				return b, err
			}
		}
		return b, nil
	default:

		rv := reflect.ValueOf(i)
		t := rv.Type()
		if rv.Kind() == reflect.Slice {
			b = cborAppendArrayHeader(b, uint32(rv.Len()))
			for idx := 0; idx < rv.Len(); idx++ {
				val := rv.Index(idx)
				elem := val.Interface()
				m, ok := elem.(cborMarshaler)
				if !ok && val.CanAddr() {
					m, ok = val.Addr().Interface().(cborMarshaler)
				}
				if !ok {
					return b, &cborErrUnsupportedType{}
				}
				var err error
				b, err = m.MarshalCBOR(b)
				if err != nil {
					return b, err
				}
			}
			return b, nil
		}
		if rv.Kind() == reflect.Map {
			keyKind := t.Key().Kind()
			keys := rv.MapKeys()
			b = cborAppendMapHeader(b, uint32(len(keys)))
			for _, k := range keys {

				switch keyKind {
				case reflect.String:
					b = cborAppendString(b, k.String())
				case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
					b = cborAppendUint64(b, k.Uint())
				case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
					b = cborAppendInt64(b, k.Int())
				default:
					return b, &cborErrUnsupportedType{}
				}

				mv := rv.MapIndex(k)
				val := mv.Interface()

				if m, ok := val.(cborMarshaler); ok {
					var err error
					b, err = m.MarshalCBOR(b)
					if err != nil {
						return b, err
					}
				} else {

					ptr := reflect.New(mv.Type())
					ptr.Elem().Set(mv)
					if m, ok := ptr.Interface().(cborMarshaler); ok {
						var err error
						b, err = m.MarshalCBOR(b)
						if err != nil {
							return b, err
						}
						continue
					}

					var err error
					b, err = cborAppendInterface(b, val)
					if err != nil {
						return b, err
					}
				}
			}
			return b, nil
		}
		return b, &cborErrUnsupportedType{}
	}
}

func cborAppendMapStrStrDeterministic(b []byte, m map[string]string) []byte {
	sz := uint32(len(m))
	b = cborAppendMapHeader(b, sz)
	type kv struct {
		key string
		enc []byte
	}
	arr := make([]kv, 0, len(m))
	for k := range m {
		arr = append(arr, kv{key: k, enc: cborAppendString(nil, k)})
	}
	sort.Slice(arr, func(i, j int) bool { return bytes.Compare(arr[i].enc, arr[j].enc) < 0 })
	for _, it := range arr {
		b = cborAppendString(b, it.key)
		b = cborAppendString(b, m[it.key])
	}
	return b
}

func cborAppendMapStrInterfaceDeterministic(b []byte, m map[string]any) ([]byte, error) {
	sz := uint32(len(m))
	b = cborAppendMapHeader(b, sz)
	type kv struct {
		key string
		enc []byte
	}
	arr := make([]kv, 0, len(m))
	for k := range m {
		arr = append(arr, kv{key: k, enc: cborAppendString(nil, k)})
	}
	sort.Slice(arr, func(i, j int) bool { return bytes.Compare(arr[i].enc, arr[j].enc) < 0 })
	for _, it := range arr {
		b = cborAppendString(b, it.key)
		var err error
		b, err = cborAppendInterface(b, m[it.key])
		if err != nil {
			return b, err
		}
	}
	return b, nil
}

func cborAppendMapHeaderIndefinite(b []byte) []byte {
	return append(b, cbormakeByte(cbormajorTypeMap, cboraddInfoIndefinite))
}

func cborAppendBreak(b []byte) []byte {
	return append(b, cbormakeByte(cbormajorTypeSimple, cborsimpleBreak))
}

func cborAppendRawMapDeterministic(b []byte, pairs []cborRawPair) []byte {

	n := len(pairs)
	if n == 0 {
		return cborAppendMapHeader(b, 0)
	}

	byLen := make(map[int][]int)
	for i := 0; i < n; i++ {
		l := len(pairs[i].Key)
		byLen[l] = append(byLen[l], i)
	}
	lens := make([]int, 0, len(byLen))
	for l := range byLen {
		lens = append(lens, l)
	}
	sort.Ints(lens)
	order := make([]int, 0, n)
	counts := make([]int, 256)
	var tmp []int
	for _, l := range lens {
		grp := byLen[l]
		if len(grp) <= 1 {
			order = append(order, grp...)
			continue
		}

		if l < 64 && len(grp) < 1024 {
			sort.Slice(grp, func(i, j int) bool { return bytes.Compare(pairs[grp[i]].Key, pairs[grp[j]].Key) < 0 })
			order = append(order, grp...)
			continue
		}
		if cap(tmp) < len(grp) {
			tmp = make([]int, len(grp))
		} else {
			tmp = tmp[:len(grp)]
		}
		cur := grp
		aux := tmp
		for pos := l - 1; pos >= 0; pos-- {
			for i := range counts {
				counts[i] = 0
			}
			for _, idx := range cur {
				counts[int(pairs[idx].Key[pos])]++
			}
			sum := 0
			for i := 0; i < 256; i++ {
				c := counts[i]
				counts[i] = sum
				sum += c
			}
			for _, idx := range cur {
				bv := pairs[idx].Key[pos]
				p := counts[int(bv)]
				aux[p] = idx
				counts[int(bv)] = p + 1
			}
			cur, aux = aux, cur
		}
		order = append(order, cur...)
	}
	b = cborAppendMapHeader(b, uint32(n))
	for _, i := range order {
		b = append(b, pairs[i].Key...)
		b = append(b, pairs[i].Value...)
	}
	return b
}

func cborAppendMapDeterministic[K comparable, V any](b []byte, m map[K]V,
	encKey func(dst []byte, k K) []byte,
	encVal func(dst []byte, v V) ([]byte, error),
) ([]byte, error) {
	type item struct {
		keyEnc []byte
		key    K
		val    V
	}
	items := make([]item, 0, len(m))

	var scratch []byte
	for k, v := range m {
		prev := len(scratch)
		scratch = encKey(scratch, k)
		ke := scratch[prev:]
		items = append(items, item{keyEnc: ke, key: k, val: v})
	}

	byLen := make(map[int][]int)
	for i := range items {
		byLen[len(items[i].keyEnc)] = append(byLen[len(items[i].keyEnc)], i)
	}
	lens := make([]int, 0, len(byLen))
	for l := range byLen {
		lens = append(lens, l)
	}
	sort.Ints(lens)
	order := make([]int, 0, len(items))
	counts := make([]int, 256)
	var tmpIdx []int
	for _, l := range lens {
		grp := byLen[l]
		if len(grp) <= 1 {
			order = append(order, grp...)
			continue
		}

		if l < 64 && len(grp) < 1024 {
			sort.Slice(grp, func(i, j int) bool { return bytes.Compare(items[grp[i]].keyEnc, items[grp[j]].keyEnc) < 0 })
			order = append(order, grp...)
			continue
		}
		if cap(tmpIdx) < len(grp) {
			tmpIdx = make([]int, len(grp))
		} else {
			tmpIdx = tmpIdx[:len(grp)]
		}
		cur := grp
		aux := tmpIdx
		for pos := l - 1; pos >= 0; pos-- {
			for i := range counts {
				counts[i] = 0
			}
			for _, idx := range cur {
				counts[int(items[idx].keyEnc[pos])]++
			}
			sum := 0
			for i := 0; i < 256; i++ {
				c := counts[i]
				counts[i] = sum
				sum += c
			}
			for _, idx := range cur {
				bv := items[idx].keyEnc[pos]
				p := counts[int(bv)]
				aux[p] = idx
				counts[int(bv)] = p + 1
			}
			cur, aux = aux, cur
		}
		order = append(order, cur...)
	}
	b = cborAppendMapHeader(b, uint32(len(items)))
	var err error
	for _, oi := range order {
		b = append(b, items[oi].keyEnc...)
		b, err = encVal(b, items[oi].val)
		if err != nil {
			return b, err
		}
	}
	return b, nil
}

func cborEncKeyString(dst []byte, s string) []byte   { return cborAppendString(dst, s) }
func cborEncKeyBytes(dst []byte, bs []byte) []byte   { return cborAppendBytes(dst, bs) }
func cborEncKeyInt(dst []byte, i int) []byte         { return cborAppendInt(dst, i) }
func cborEncKeyInt64(dst []byte, i int64) []byte     { return cborAppendInt64(dst, i) }
func cborEncKeyUint64(dst []byte, u uint64) []byte   { return cborAppendUint64(dst, u) }
func cborEncKeyBool(dst []byte, v bool) []byte       { return cborAppendBool(dst, v) }
func cborEncKeyFloat64(dst []byte, f float64) []byte { return cborAppendFloat64(dst, f) }
func cborEncKeyTime(dst []byte, t time.Time) []byte  { return cborAppendTime(dst, t) }

func cborEncValString(dst []byte, s string) ([]byte, error)   { return cborAppendString(dst, s), nil }
func cborEncValBytes(dst []byte, bs []byte) ([]byte, error)   { return cborAppendBytes(dst, bs), nil }
func cborEncValInt(dst []byte, i int) ([]byte, error)         { return cborAppendInt(dst, i), nil }
func cborEncValInt64(dst []byte, i int64) ([]byte, error)     { return cborAppendInt64(dst, i), nil }
func cborEncValUint64(dst []byte, u uint64) ([]byte, error)   { return cborAppendUint64(dst, u), nil }
func cborEncValBool(dst []byte, v bool) ([]byte, error)       { return cborAppendBool(dst, v), nil }
func cborEncValFloat64(dst []byte, f float64) ([]byte, error) { return cborAppendFloat64(dst, f), nil }
func cborEncValFloat32(dst []byte, f float32) ([]byte, error) { return cborAppendFloat32(dst, f), nil }
func cborEncValTime(dst []byte, t time.Time) ([]byte, error)  { return cborAppendTime(dst, t), nil }

func cborEncValInterface(dst []byte, v any) ([]byte, error) { return cborAppendInterface(dst, v) }

func cborAppendMapDeterministicStrStr(b []byte, m map[string]string) []byte {
	out, _ := cborAppendMapDeterministic(b, m, cborEncKeyString, cborEncValString)
	return out
}

func cborAppendMapDeterministicStrInt64(b []byte, m map[string]int64) []byte {
	out, _ := cborAppendMapDeterministic(b, m, cborEncKeyString, cborEncValInt64)
	return out
}

func cborAppendMapDeterministicStrInt(b []byte, m map[string]int) []byte {
	out, _ := cborAppendMapDeterministic(b, m, cborEncKeyString, cborEncValInt)
	return out
}

func cborAppendMapDeterministicStrUint64(b []byte, m map[string]uint64) []byte {
	out, _ := cborAppendMapDeterministic(b, m, cborEncKeyString, cborEncValUint64)
	return out
}

func cborAppendMapDeterministicStrBool(b []byte, m map[string]bool) []byte {
	out, _ := cborAppendMapDeterministic(b, m, cborEncKeyString, cborEncValBool)
	return out
}

func cborAppendMapDeterministicStrFloat64(b []byte, m map[string]float64) []byte {
	out, _ := cborAppendMapDeterministic(b, m, cborEncKeyString, cborEncValFloat64)
	return out
}

func cborAppendMapDeterministicStrBytes(b []byte, m map[string][]byte) []byte {
	out, _ := cborAppendMapDeterministic(b, m, cborEncKeyString, cborEncValBytes)
	return out
}

func cborAppendMapDeterministicStrInterface(b []byte, m map[string]any) ([]byte, error) {
	return cborAppendMapDeterministic(b, m, cborEncKeyString, cborEncValInterface)
}

type cborWriter struct {
	bb *cborByteBuffer
}

func cborNewWriter(bb *cborByteBuffer) *cborWriter { return &cborWriter{bb: bb} }

func (w *cborWriter) Bytes() []byte { return w.bb.Bytes() }

func (w *cborWriter) WriteMapHeader(sz uint32) error {
	w.bb.AppendMapHeader(sz)
	return nil
}

func (w *cborWriter) WriteString(s string) error {
	w.bb.AppendString(s)
	return nil
}

func (w *cborWriter) WriteBool(v bool) error {
	w.bb.AppendBool(v)
	return nil
}

func (w *cborWriter) WriteInt(v int) error {
	w.bb.AppendInt64(int64(v))
	return nil
}

func (w *cborWriter) WriteInt64(v int64) error {
	w.bb.AppendInt64(v)
	return nil
}

func (w *cborWriter) WriteUint(v uint) error {
	w.bb.AppendUint64(uint64(v))
	return nil
}

func (w *cborWriter) WriteUint64(v uint64) error {
	w.bb.AppendUint64(v)
	return nil
}

func (w *cborWriter) WriteFloat32(v float32) error {
	w.bb.AppendFloat32(v)
	return nil
}

func (w *cborWriter) WriteFloat64(v float64) error {
	w.bb.AppendFloat64(v)
	return nil
}

func (w *cborWriter) WriteBytes(v []byte) error {
	w.bb.AppendBytes(v)
	return nil
}
