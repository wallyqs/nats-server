// Code generated by cborgen DO NOT EDIT.

package server

import "time"

func (x raftGroup) Msgsize() (s int) {
	s = cborMapHeaderSize + cborStringPrefixSize + len("name") + cborStringPrefixSize + len(x.Name) + cborStringPrefixSize + len("peers") + cborArrayHeaderSize + len(x.Peers)*cborStringPrefixSize + cborStringPrefixSize + len("cluster") + cborStringPrefixSize + len(x.Cluster) + cborStringPrefixSize + len("preferred") + cborStringPrefixSize + len(x.Preferred) + cborStringPrefixSize + len("scale_up") + cborBoolSize
	return
}

func (x *raftGroup) MarshalCBOR(b []byte) ([]byte, error) {
	if x == nil {
		return cborAppendNil(b), nil
	}

	b = cborRequire(b, x.Msgsize())

	count := uint32(0)
	count++
	count++
	count++
	if !(x.Cluster == "") {
		count++
	}
	if !(x.Preferred == "") {
		count++
	}
	if !(!x.ScaleUp) {
		count++
	}
	b = cborAppendMapHeader(b, count)
	var err error
	b = cborAppendString(b, "name")
	b, err = cborAppendString(b, x.Name), nil
	if err != nil {
		return b, err
	}

	b = cborAppendString(b, "peers")
	b = cborAppendArrayHeader(b, uint32(len(x.Peers)))
	for _, v := range x.Peers {
		b = cborAppendString(b, v)
	}
	b = cborAppendString(b, "store")
	b, err = x.Storage.MarshalCBOR(b)
	if err != nil {
		return b, err
	}
	if !(x.Cluster == "") {
		b = cborAppendString(b, "cluster")
		b, err = cborAppendString(b, x.Cluster), nil
		if err != nil {
			return b, err
		}
	}
	if !(x.Preferred == "") {
		b = cborAppendString(b, "preferred")
		b, err = cborAppendString(b, x.Preferred), nil
		if err != nil {
			return b, err
		}
	}
	if !(!x.ScaleUp) {
		b = cborAppendString(b, "scale_up")
		b, err = cborAppendBool(b, x.ScaleUp), nil
		if err != nil {
			return b, err
		}
	}

	return b, nil
}

// DecodeSafe decodes using validated, allocating string handling.
func (x *raftGroup) DecodeSafe(b []byte) ([]byte, error) {
	if x == nil {
		return b, cborErrNotNil
	}
	sz, rest, err := cborReadMapHeaderBytes(b)
	if err != nil {
		return b, err
	}
	for i := uint32(0); i < sz; i++ {
		key, v, err := cborReadStringBytes(rest)
		if err != nil {
			return b, err
		}
		switch key {
		case "name":

			var tmp string
			tmp, v, err = cborReadStringBytes(v)
			if err != nil {
				return b, err
			}
			x.Name = tmp
		case "peers":

			var sz uint32
			sz, v, err = cborReadArrayHeaderBytes(v)
			if err != nil {
				return b, err
			}
			if cap(x.Peers) >= int(sz) {
				x.Peers = x.Peers[:sz]
			} else {
				x.Peers = make([]string, sz)
			}
			if sz > 0 {
				_ = x.Peers[sz-1]
			}
			for iPeers := uint32(0); iPeers < sz; iPeers++ {
				var tmp string
				tmp, v, err = cborReadStringBytes(v)
				if err != nil {
					return b, err
				}
				x.Peers[iPeers] = tmp
			}
		case "store":

			v, err = x.Storage.UnmarshalCBOR(v)
			if err != nil {
				return b, err
			}
		case "cluster":

			var tmp string
			tmp, v, err = cborReadStringBytes(v)
			if err != nil {
				return b, err
			}
			x.Cluster = tmp
		case "preferred":

			var tmp string
			tmp, v, err = cborReadStringBytes(v)
			if err != nil {
				return b, err
			}
			x.Preferred = tmp
		case "scale_up":

			var tmp bool
			tmp, v, err = cborReadBoolBytes(v)
			if err != nil {
				return b, err
			}
			x.ScaleUp = tmp
		default:
			v, err = cborSkip(v)
			if err != nil {
				return b, err
			}
		}
		rest = v
	}
	return rest, nil
}

// DecodeTrusted decodes using zero-copy strings and no per-string UTF-8 validation.
func (x *raftGroup) DecodeTrusted(b []byte) ([]byte, error) {
	if x == nil {
		return b, cborErrNotNil
	}
	sz, rest, err := cborReadMapHeaderBytes(b)
	if err != nil {
		return b, err
	}
	for i := uint32(0); i < sz; i++ {
		keyBytes, v, err := cborReadStringZC(rest)
		if err != nil {
			return b, err
		}
		key := cborUnsafeString(keyBytes)
		switch key {
		case "name":

			var tmpBytes []byte
			tmpBytes, v, err = cborReadStringZC(v)
			if err != nil {
				return b, err
			}
			x.Name = cborUnsafeString(tmpBytes)
		case "peers":

			var sz uint32
			sz, v, err = cborReadArrayHeaderBytes(v)
			if err != nil {
				return b, err
			}
			if cap(x.Peers) >= int(sz) {
				x.Peers = x.Peers[:sz]
			} else {
				x.Peers = make([]string, sz)
			}
			if sz > 0 {
				_ = x.Peers[sz-1]
			}
			for iPeers := uint32(0); iPeers < sz; iPeers++ {
				var tmp string
				tmp, v, err = cborReadStringBytes(v)
				if err != nil {
					return b, err
				}
				x.Peers[iPeers] = tmp
			}
		case "store":

			v, err = x.Storage.UnmarshalCBOR(v)
			if err != nil {
				return b, err
			}
		case "cluster":

			var tmpBytes []byte
			tmpBytes, v, err = cborReadStringZC(v)
			if err != nil {
				return b, err
			}
			x.Cluster = cborUnsafeString(tmpBytes)
		case "preferred":

			var tmpBytes []byte
			tmpBytes, v, err = cborReadStringZC(v)
			if err != nil {
				return b, err
			}
			x.Preferred = cborUnsafeString(tmpBytes)
		case "scale_up":

			var tmp bool
			tmp, v, err = cborReadBoolBytes(v)
			if err != nil {
				return b, err
			}
			x.ScaleUp = tmp
		default:
			v, err = cborSkip(v)
			if err != nil {
				return b, err
			}
		}
		rest = v
	}
	return rest, nil
}

// UnmarshalCBOR implements cbor.Unmarshaler using the Safe path.
func (x *raftGroup) UnmarshalCBOR(b []byte) ([]byte, error) {
	return x.DecodeSafe(b)
}

func (x writeableConsumerAssignment) Msgsize() (s int) {
	s = cborMapHeaderSize + cborStringPrefixSize + len("created") + cborTimeSize + cborStringPrefixSize + len("name") + cborStringPrefixSize + len(x.Name) + cborStringPrefixSize + len("stream") + cborStringPrefixSize + len(x.Stream)
	return
}

func (x *writeableConsumerAssignment) MarshalCBOR(b []byte) ([]byte, error) {
	if x == nil {
		return cborAppendNil(b), nil
	}

	b = cborRequire(b, x.Msgsize())

	count := uint32(0)
	if !(x.Client == nil) {
		count++
	}
	count++
	count++
	count++
	count++
	count++
	if !(x.State == nil) {
		count++
	}
	b = cborAppendMapHeader(b, count)
	var err error
	if !(x.Client == nil) {
		b = cborAppendString(b, "client")
		b, err = cborAppendPtrMarshaler(b, x.Client)
		if err != nil {
			return b, err
		}
	}
	b = cborAppendString(b, "created")
	b, err = cborAppendTime(b, x.Created), nil
	if err != nil {
		return b, err
	}
	b = cborAppendString(b, "name")
	b, err = cborAppendString(b, x.Name), nil
	if err != nil {
		return b, err
	}
	b = cborAppendString(b, "stream")
	b, err = cborAppendString(b, x.Stream), nil
	if err != nil {
		return b, err
	}
	b = cborAppendString(b, "consumer")
	b, err = cborAppendBytes(b, []byte(x.ConfigJSON)), nil
	if err != nil {
		return b, err
	}
	b = cborAppendString(b, "group")
	b, err = cborAppendInterface(b, x.Group)
	if err != nil {
		return b, err
	}
	if !(x.State == nil) {
		b = cborAppendString(b, "state")
		b, err = cborAppendPtrMarshaler(b, x.State)
		if err != nil {
			return b, err
		}
	}

	return b, nil
}

// DecodeSafe decodes using validated, allocating string handling.
func (x *writeableConsumerAssignment) DecodeSafe(b []byte) ([]byte, error) {
	if x == nil {
		return b, cborErrNotNil
	}
	sz, rest, err := cborReadMapHeaderBytes(b)
	if err != nil {
		return b, err
	}
	for i := uint32(0); i < sz; i++ {
		key, v, err := cborReadStringBytes(rest)
		if err != nil {
			return b, err
		}
		switch key {
		case "client":

			if x.Client == nil {
				x.Client = new(ClientInfo)
			}
			v, err = x.Client.UnmarshalCBOR(v)
			if err != nil {
				return b, err
			}
		case "created":

			var tmp time.Time
			tmp, v, err = cborReadTimeBytes(v)
			if err != nil {
				return b, err
			}
			x.Created = tmp
		case "name":

			var tmp string
			tmp, v, err = cborReadStringBytes(v)
			if err != nil {
				return b, err
			}
			x.Name = tmp
		case "stream":

			var tmp string
			tmp, v, err = cborReadStringBytes(v)
			if err != nil {
				return b, err
			}
			x.Stream = tmp
		case "consumer":

			v, err = cborSkip(v)
			if err != nil {
				return b, err
			}
		case "group":

			if x.Group == nil {
				x.Group = new(raftGroup)
			}
			v, err = x.Group.UnmarshalCBOR(v)
			if err != nil {
				return b, err
			}
		case "state":

			if x.State == nil {
				x.State = new(ConsumerState)
			}
			v, err = x.State.UnmarshalCBOR(v)
			if err != nil {
				return b, err
			}
		default:
			v, err = cborSkip(v)
			if err != nil {
				return b, err
			}
		}
		rest = v
	}
	return rest, nil
}

// DecodeTrusted decodes using zero-copy strings and no per-string UTF-8 validation.
func (x *writeableConsumerAssignment) DecodeTrusted(b []byte) ([]byte, error) {
	if x == nil {
		return b, cborErrNotNil
	}
	sz, rest, err := cborReadMapHeaderBytes(b)
	if err != nil {
		return b, err
	}
	for i := uint32(0); i < sz; i++ {
		keyBytes, v, err := cborReadStringZC(rest)
		if err != nil {
			return b, err
		}
		key := cborUnsafeString(keyBytes)
		switch key {
		case "client":

			if x.Client == nil {
				x.Client = new(ClientInfo)
			}
			v, err = x.Client.UnmarshalCBOR(v)
			if err != nil {
				return b, err
			}
		case "created":

			var tmp time.Time
			tmp, v, err = cborReadTimeBytes(v)
			if err != nil {
				return b, err
			}
			x.Created = tmp
		case "name":

			var tmpBytes []byte
			tmpBytes, v, err = cborReadStringZC(v)
			if err != nil {
				return b, err
			}
			x.Name = cborUnsafeString(tmpBytes)
		case "stream":

			var tmpBytes []byte
			tmpBytes, v, err = cborReadStringZC(v)
			if err != nil {
				return b, err
			}
			x.Stream = cborUnsafeString(tmpBytes)
		case "consumer":

			v, err = cborSkip(v)
			if err != nil {
				return b, err
			}
		case "group":

			if x.Group == nil {
				x.Group = new(raftGroup)
			}
			v, err = x.Group.DecodeTrusted(v)
			if err != nil {
				return b, err
			}
		case "state":

			if x.State == nil {
				x.State = new(ConsumerState)
			}
			v, err = x.State.UnmarshalCBOR(v)
			if err != nil {
				return b, err
			}
		default:
			v, err = cborSkip(v)
			if err != nil {
				return b, err
			}
		}
		rest = v
	}
	return rest, nil
}

// UnmarshalCBOR implements cbor.Unmarshaler using the Safe path.
func (x *writeableConsumerAssignment) UnmarshalCBOR(b []byte) ([]byte, error) {
	return x.DecodeSafe(b)
}

func (x writeableStreamAssignment) Msgsize() (s int) {
	s = cborMapHeaderSize + cborStringPrefixSize + len("created") + cborTimeSize + cborStringPrefixSize + len("sync") + cborStringPrefixSize + len(x.Sync)
	return
}

func (x *writeableStreamAssignment) MarshalCBOR(b []byte) ([]byte, error) {
	if x == nil {
		return cborAppendNil(b), nil
	}

	b = cborRequire(b, x.Msgsize())

	count := uint32(0)
	if !(x.Client == nil) {
		count++
	}
	count++
	count++
	count++
	count++
	count++
	b = cborAppendMapHeader(b, count)
	var err error
	if !(x.Client == nil) {
		b = cborAppendString(b, "client")
		b, err = cborAppendPtrMarshaler(b, x.Client)
		if err != nil {
			return b, err
		}
	}
	b = cborAppendString(b, "created")
	b, err = cborAppendTime(b, x.Created), nil
	if err != nil {
		return b, err
	}
	b = cborAppendString(b, "stream")
	b, err = cborAppendBytes(b, []byte(x.ConfigJSON)), nil
	if err != nil {
		return b, err
	}
	b = cborAppendString(b, "group")
	b, err = cborAppendInterface(b, x.Group)
	if err != nil {
		return b, err
	}
	b = cborAppendString(b, "sync")
	b, err = cborAppendString(b, x.Sync), nil
	if err != nil {
		return b, err
	}
	b = cborAppendString(b, "Consumers")
	b, err = cborAppendInterface(b, x.Consumers)
	if err != nil {
		return b, err
	}

	return b, nil
}

// DecodeSafe decodes using validated, allocating string handling.
func (x *writeableStreamAssignment) DecodeSafe(b []byte) ([]byte, error) {
	if x == nil {
		return b, cborErrNotNil
	}
	sz, rest, err := cborReadMapHeaderBytes(b)
	if err != nil {
		return b, err
	}
	for i := uint32(0); i < sz; i++ {
		key, v, err := cborReadStringBytes(rest)
		if err != nil {
			return b, err
		}
		switch key {
		case "client":

			if x.Client == nil {
				x.Client = new(ClientInfo)
			}
			v, err = x.Client.UnmarshalCBOR(v)
			if err != nil {
				return b, err
			}
		case "created":

			var tmp time.Time
			tmp, v, err = cborReadTimeBytes(v)
			if err != nil {
				return b, err
			}
			x.Created = tmp
		case "stream":

			v, err = cborSkip(v)
			if err != nil {
				return b, err
			}
		case "group":

			if x.Group == nil {
				x.Group = new(raftGroup)
			}
			v, err = x.Group.UnmarshalCBOR(v)
			if err != nil {
				return b, err
			}
		case "sync":

			var tmp string
			tmp, v, err = cborReadStringBytes(v)
			if err != nil {
				return b, err
			}
			x.Sync = tmp
		case "Consumers":

			var sz uint32
			sz, v, err = cborReadArrayHeaderBytes(v)
			if err != nil {
				return b, err
			}
			if cap(x.Consumers) >= int(sz) {
				x.Consumers = x.Consumers[:sz]
			} else {
				x.Consumers = make([]*writeableConsumerAssignment, sz)
			}
			if sz > 0 {
				_ = x.Consumers[sz-1]
			}
			for iConsumers := uint32(0); iConsumers < sz; iConsumers++ {
				if x.Consumers[iConsumers] == nil {
					x.Consumers[iConsumers] = new(writeableConsumerAssignment)
				}
				v, err = x.Consumers[iConsumers].UnmarshalCBOR(v)
				if err != nil {
					return b, err
				}
			}
		default:
			v, err = cborSkip(v)
			if err != nil {
				return b, err
			}
		}
		rest = v
	}
	return rest, nil
}

// DecodeTrusted decodes using zero-copy strings and no per-string UTF-8 validation.
func (x *writeableStreamAssignment) DecodeTrusted(b []byte) ([]byte, error) {
	if x == nil {
		return b, cborErrNotNil
	}
	sz, rest, err := cborReadMapHeaderBytes(b)
	if err != nil {
		return b, err
	}
	for i := uint32(0); i < sz; i++ {
		keyBytes, v, err := cborReadStringZC(rest)
		if err != nil {
			return b, err
		}
		key := cborUnsafeString(keyBytes)
		switch key {
		case "client":

			if x.Client == nil {
				x.Client = new(ClientInfo)
			}
			v, err = x.Client.UnmarshalCBOR(v)
			if err != nil {
				return b, err
			}
		case "created":

			var tmp time.Time
			tmp, v, err = cborReadTimeBytes(v)
			if err != nil {
				return b, err
			}
			x.Created = tmp
		case "stream":

			v, err = cborSkip(v)
			if err != nil {
				return b, err
			}
		case "group":

			if x.Group == nil {
				x.Group = new(raftGroup)
			}
			v, err = x.Group.DecodeTrusted(v)
			if err != nil {
				return b, err
			}
		case "sync":

			var tmpBytes []byte
			tmpBytes, v, err = cborReadStringZC(v)
			if err != nil {
				return b, err
			}
			x.Sync = cborUnsafeString(tmpBytes)
		case "Consumers":

			var sz uint32
			sz, v, err = cborReadArrayHeaderBytes(v)
			if err != nil {
				return b, err
			}
			if cap(x.Consumers) >= int(sz) {
				x.Consumers = x.Consumers[:sz]
			} else {
				x.Consumers = make([]*writeableConsumerAssignment, sz)
			}
			if sz > 0 {
				_ = x.Consumers[sz-1]
			}
			for iConsumers := uint32(0); iConsumers < sz; iConsumers++ {
				if x.Consumers[iConsumers] == nil {
					x.Consumers[iConsumers] = new(writeableConsumerAssignment)
				}
				v, err = x.Consumers[iConsumers].DecodeTrusted(v)
				if err != nil {
					return b, err
				}
			}
		default:
			v, err = cborSkip(v)
			if err != nil {
				return b, err
			}
		}
		rest = v
	}
	return rest, nil
}

// UnmarshalCBOR implements cbor.Unmarshaler using the Safe path.
func (x *writeableStreamAssignment) UnmarshalCBOR(b []byte) ([]byte, error) {
	return x.DecodeSafe(b)
}
