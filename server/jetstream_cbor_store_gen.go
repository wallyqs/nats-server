// Code generated by cborgen DO NOT EDIT.

package server

func (x SequencePair) Msgsize() (s int) {
	s = cborMapHeaderSize + cborStringPrefixSize + len("consumer_seq") + cborUint64Size + cborStringPrefixSize + len("stream_seq") + cborUint64Size
	return
}

func (x *SequencePair) MarshalCBOR(b []byte) ([]byte, error) {
	if x == nil {
		return cborAppendNil(b), nil
	}

	b = cborRequire(b, x.Msgsize())

	b = cborAppendMapHeader(b, uint32(2))
	var err error
	b = cborAppendString(b, "consumer_seq")
	b, err = cborAppendUint64(b, x.Consumer), nil
	if err != nil {
		return b, err
	}
	b = cborAppendString(b, "stream_seq")
	b, err = cborAppendUint64(b, x.Stream), nil
	if err != nil {
		return b, err
	}

	return b, nil
}

// DecodeSafe decodes using validated, allocating string handling.
func (x *SequencePair) DecodeSafe(b []byte) ([]byte, error) {
	if x == nil {
		return b, cborErrNotNil
	}
	sz, rest, err := cborReadMapHeaderBytes(b)
	if err != nil {
		return b, err
	}
	for i := uint32(0); i < sz; i++ {
		key, v, err := cborReadStringBytes(rest)
		if err != nil {
			return b, err
		}
		switch key {
		case "consumer_seq":

			var tmp uint64
			tmp, v, err = cborReadUint64Bytes(v)
			if err != nil {
				return b, err
			}
			x.Consumer = tmp
		case "stream_seq":

			var tmp uint64
			tmp, v, err = cborReadUint64Bytes(v)
			if err != nil {
				return b, err
			}
			x.Stream = tmp
		default:
			v, err = cborSkip(v)
			if err != nil {
				return b, err
			}
		}
		rest = v
	}
	return rest, nil
}

// DecodeTrusted decodes using zero-copy strings and no per-string UTF-8 validation.
func (x *SequencePair) DecodeTrusted(b []byte) ([]byte, error) {
	if x == nil {
		return b, cborErrNotNil
	}
	sz, rest, err := cborReadMapHeaderBytes(b)
	if err != nil {
		return b, err
	}
	for i := uint32(0); i < sz; i++ {
		keyBytes, v, err := cborReadStringZC(rest)
		if err != nil {
			return b, err
		}
		key := cborUnsafeString(keyBytes)
		switch key {
		case "consumer_seq":

			var tmp uint64
			tmp, v, err = cborReadUint64Bytes(v)
			if err != nil {
				return b, err
			}
			x.Consumer = tmp
		case "stream_seq":

			var tmp uint64
			tmp, v, err = cborReadUint64Bytes(v)
			if err != nil {
				return b, err
			}
			x.Stream = tmp
		default:
			v, err = cborSkip(v)
			if err != nil {
				return b, err
			}
		}
		rest = v
	}
	return rest, nil
}

// UnmarshalCBOR implements cbor.Unmarshaler using the Safe path.
func (x *SequencePair) UnmarshalCBOR(b []byte) ([]byte, error) {
	return x.DecodeSafe(b)
}

func (x *ConsumerState) MarshalCBOR(b []byte) ([]byte, error) {
	if x == nil {
		return cborAppendNil(b), nil
	}

	count := uint32(0)
	count++
	count++
	if !(len(x.Pending) == 0) {
		count++
	}
	if !(len(x.Redelivered) == 0) {
		count++
	}
	b = cborAppendMapHeader(b, count)
	var err error
	b = cborAppendString(b, "delivered")
	b, err = x.Delivered.MarshalCBOR(b)
	if err != nil {
		return b, err
	}
	b = cborAppendString(b, "ack_floor")
	b, err = x.AckFloor.MarshalCBOR(b)
	if err != nil {
		return b, err
	}
	if !(len(x.Pending) == 0) {

		b = cborAppendString(b, "pending")
		b = cborAppendMapHeader(b, uint32(len(x.Pending)))
		for k, v := range x.Pending {
			b = cborAppendUint64(b, k)
			if v == nil {
				b = cborAppendNil(b)
			} else {
				b, err = v.MarshalCBOR(b)
				if err != nil {
					return b, err
				}
			}
		}
	}
	if !(len(x.Redelivered) == 0) {

		b = cborAppendString(b, "redelivered")
		b = cborAppendMapHeader(b, uint32(len(x.Redelivered)))
		for k, v := range x.Redelivered {
			b = cborAppendUint64(b, k)
			b = cborAppendUint64(b, v)
		}
	}

	return b, nil
}

// DecodeSafe decodes using validated, allocating string handling.
func (x *ConsumerState) DecodeSafe(b []byte) ([]byte, error) {
	if x == nil {
		return b, cborErrNotNil
	}
	sz, rest, err := cborReadMapHeaderBytes(b)
	if err != nil {
		return b, err
	}
	for i := uint32(0); i < sz; i++ {
		key, v, err := cborReadStringBytes(rest)
		if err != nil {
			return b, err
		}
		switch key {
		case "delivered":

			v, err = x.Delivered.UnmarshalCBOR(v)
			if err != nil {
				return b, err
			}
		case "ack_floor":

			v, err = x.AckFloor.UnmarshalCBOR(v)
			if err != nil {
				return b, err
			}
		case "pending":

			var sz uint32
			sz, v, err = cborReadMapHeaderBytes(v)
			if err != nil {
				return b, err
			}
			if x.Pending == nil && sz > 0 {
				x.Pending = make(map[uint64]*Pending, sz)
			} else if x.Pending != nil {
				clear(x.Pending)
			}
			for iPending := uint32(0); iPending < sz; iPending++ {
				var key uint64
				key, v, err = cborReadUint64Bytes(v)
				if err != nil {
					return b, err
				}
				if len(v) == 0 {
					return b, cborErrShortBytes
				}
				if v[0] == 0xf6 { // null
					var tmpBytes []byte
					tmpBytes, err = cborReadNilBytes(v)
					if err != nil {
						return b, err
					}
					v = tmpBytes
					x.Pending[key] = nil
					continue
				}
				tmp := new(Pending)
				v, err = tmp.UnmarshalCBOR(v)
				if err != nil {
					return b, err
				}
				x.Pending[key] = tmp
			}
		case "redelivered":

			var sz uint32
			sz, v, err = cborReadMapHeaderBytes(v)
			if err != nil {
				return b, err
			}
			if x.Redelivered == nil && sz > 0 {
				x.Redelivered = make(map[uint64]uint64, sz)
			} else if x.Redelivered != nil {
				clear(x.Redelivered)
			}
			for iRedelivered := uint32(0); iRedelivered < sz; iRedelivered++ {
				var key uint64
				key, v, err = cborReadUint64Bytes(v)
				if err != nil {
					return b, err
				}
				var val uint64
				val, v, err = cborReadUint64Bytes(v)
				if err != nil {
					return b, err
				}
				x.Redelivered[key] = val
			}
		default:
			v, err = cborSkip(v)
			if err != nil {
				return b, err
			}
		}
		rest = v
	}
	return rest, nil
}

// DecodeTrusted decodes using zero-copy strings and no per-string UTF-8 validation.
func (x *ConsumerState) DecodeTrusted(b []byte) ([]byte, error) {
	if x == nil {
		return b, cborErrNotNil
	}
	sz, rest, err := cborReadMapHeaderBytes(b)
	if err != nil {
		return b, err
	}
	for i := uint32(0); i < sz; i++ {
		keyBytes, v, err := cborReadStringZC(rest)
		if err != nil {
			return b, err
		}
		key := cborUnsafeString(keyBytes)
		switch key {
		case "delivered":

			v, err = (&x.Delivered).DecodeTrusted(v)
			if err != nil {
				return b, err
			}
		case "ack_floor":

			v, err = (&x.AckFloor).DecodeTrusted(v)
			if err != nil {
				return b, err
			}
		case "pending":

			var sz uint32
			sz, v, err = cborReadMapHeaderBytes(v)
			if err != nil {
				return b, err
			}
			if x.Pending == nil && sz > 0 {
				x.Pending = make(map[uint64]*Pending, sz)
			}
			for iPending := uint32(0); iPending < sz; iPending++ {
				var key uint64
				key, v, err = cborReadUint64Bytes(v)
				if err != nil {
					return b, err
				}
				if len(v) == 0 {
					return b, cborErrShortBytes
				}
				if v[0] == 0xf6 { // null
					var tmp []byte
					tmp, err = cborReadNilBytes(v)
					if err != nil {
						return b, err
					}
					v = tmp
					x.Pending[key] = nil
					continue
				}
				val := new(Pending)
				v, err = val.DecodeTrusted(v)
				if err != nil {
					return b, err
				}
				x.Pending[key] = val
			}
		case "redelivered":

			var sz uint32
			sz, v, err = cborReadMapHeaderBytes(v)
			if err != nil {
				return b, err
			}
			if x.Redelivered == nil && sz > 0 {
				x.Redelivered = make(map[uint64]uint64, sz)
			}
			for iRedelivered := uint32(0); iRedelivered < sz; iRedelivered++ {
				var key uint64
				key, v, err = cborReadUint64Bytes(v)
				if err != nil {
					return b, err
				}
				var val uint64
				val, v, err = cborReadUint64Bytes(v)
				if err != nil {
					return b, err
				}
				x.Redelivered[key] = val
			}
		default:
			v, err = cborSkip(v)
			if err != nil {
				return b, err
			}
		}
		rest = v
	}
	return rest, nil
}

// UnmarshalCBOR implements cbor.Unmarshaler using the Safe path.
func (x *ConsumerState) UnmarshalCBOR(b []byte) ([]byte, error) {
	return x.DecodeSafe(b)
}

func (x Pending) Msgsize() (s int) {
	s = cborMapHeaderSize + cborStringPrefixSize + len("Sequence") + cborUint64Size + cborStringPrefixSize + len("Timestamp") + cborInt64Size
	return
}

func (x *Pending) MarshalCBOR(b []byte) ([]byte, error) {
	if x == nil {
		return cborAppendNil(b), nil
	}

	b = cborRequire(b, x.Msgsize())

	b = cborAppendMapHeader(b, uint32(2))
	var err error
	b = cborAppendString(b, "Sequence")
	b, err = cborAppendUint64(b, x.Sequence), nil
	if err != nil {
		return b, err
	}
	b = cborAppendString(b, "Timestamp")
	b, err = cborAppendInt64(b, x.Timestamp), nil
	if err != nil {
		return b, err
	}

	return b, nil
}

// DecodeSafe decodes using validated, allocating string handling.
func (x *Pending) DecodeSafe(b []byte) ([]byte, error) {
	if x == nil {
		return b, cborErrNotNil
	}
	sz, rest, err := cborReadMapHeaderBytes(b)
	if err != nil {
		return b, err
	}
	for i := uint32(0); i < sz; i++ {
		key, v, err := cborReadStringBytes(rest)
		if err != nil {
			return b, err
		}
		switch key {
		case "Sequence":

			var tmp uint64
			tmp, v, err = cborReadUint64Bytes(v)
			if err != nil {
				return b, err
			}
			x.Sequence = tmp
		case "Timestamp":

			var tmp int64
			tmp, v, err = cborReadInt64Bytes(v)
			if err != nil {
				return b, err
			}
			x.Timestamp = tmp
		default:
			v, err = cborSkip(v)
			if err != nil {
				return b, err
			}
		}
		rest = v
	}
	return rest, nil
}

// DecodeTrusted decodes using zero-copy strings and no per-string UTF-8 validation.
func (x *Pending) DecodeTrusted(b []byte) ([]byte, error) {
	if x == nil {
		return b, cborErrNotNil
	}
	sz, rest, err := cborReadMapHeaderBytes(b)
	if err != nil {
		return b, err
	}
	for i := uint32(0); i < sz; i++ {
		keyBytes, v, err := cborReadStringZC(rest)
		if err != nil {
			return b, err
		}
		key := cborUnsafeString(keyBytes)
		switch key {
		case "Sequence":

			var tmp uint64
			tmp, v, err = cborReadUint64Bytes(v)
			if err != nil {
				return b, err
			}
			x.Sequence = tmp
		case "Timestamp":

			var tmp int64
			tmp, v, err = cborReadInt64Bytes(v)
			if err != nil {
				return b, err
			}
			x.Timestamp = tmp
		default:
			v, err = cborSkip(v)
			if err != nil {
				return b, err
			}
		}
		rest = v
	}
	return rest, nil
}

// UnmarshalCBOR implements cbor.Unmarshaler using the Safe path.
func (x *Pending) UnmarshalCBOR(b []byte) ([]byte, error) {
	return x.DecodeSafe(b)
}
