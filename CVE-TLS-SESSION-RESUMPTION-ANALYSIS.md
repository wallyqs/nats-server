# TLS Session Resumption CVE Analysis for NATS Server

## CVE Summary

The Go crypto/tls CVE relates to unexpected session resumption when using `Config.GetConfigForClient`. Session ticket keys are implicitly shared between parent and child configs unless explicitly overridden, which can bypass modified authentication requirements when resuming sessions.

## Impact Assessment: **AFFECTED**

NATS Server **IS AFFECTED** by this CVE in two specific areas:

### 1. Monitoring Endpoint (HTTPS) - PRIMARY CONCERN

**Location**: `server/server.go:3082-3087` and `server/server.go:3114-3117`

**Vulnerable Pattern**:
```go
// Line 3082-3087: GetConfigForClient callback
func (s *Server) getMonitoringTLSConfig(_ *tls.ClientHelloInfo) (*tls.Config, error) {
	opts := s.getOpts()
	tc := opts.TLSConfig.Clone()
	tc.ClientAuth = tls.NoClientCert  // ⚠️ Modifies auth requirement
	return tc, nil
}

// Line 3114-3119: Monitoring server setup
config := opts.TLSConfig.Clone()
if !s.ocspPeerVerify {
	config.GetConfigForClient = s.getMonitoringTLSConfig  // ⚠️ Sets callback
	config.ClientAuth = tls.NoClientCert
}
httpListener, err = tls.Listen("tcp", hp, config)
```

**Vulnerability Details**:
- The main server TLS config (`opts.TLSConfig`) can be configured with `ClientAuth = RequireAndVerifyClientCert` (see `server/opts.go:5683`)
- The monitoring endpoint uses `GetConfigForClient` to return a modified config with `ClientAuth = NoClientCert`
- **Session ticket keys are shared** between the parent config and the config returned by `GetConfigForClient`
- This creates a security boundary violation where:
  - A session established with one set of authentication requirements can potentially be resumed with different requirements
  - The root certificate verification on session resumption may not match the current config's expectations

**Attack Scenario**:
1. Main NATS server configured with `tls { verify: true }` (RequireAndVerifyClientCert)
2. Monitoring endpoint (HTTPS) uses the same base TLS config but sets ClientAuth to NoClientCert
3. Session tickets from connections to one endpoint could potentially be resumed on the other
4. Prior to the Go fix, the root CA verification on resumption might not align with the current config's ClientCAs

**Evidence from Tests**:
In `server/monitor_test.go:2311-2317`, tests configure:
```go
opts.TLSConfig.ClientAuth = tls.RequireAndVerifyClientCert
```
This demonstrates that the main server does use strict client certificate authentication, making the vulnerability exploitable.

### 2. WebSocket Endpoint - SECONDARY CONCERN

**Location**: `server/websocket.go:1171-1172` and `server/websocket.go:1264-1267`

**Vulnerable Pattern**:
```go
// Line 1264-1267: GetConfigForClient callback
func (s *Server) wsGetTLSConfig(_ *tls.ClientHelloInfo) (*tls.Config, error) {
	opts := s.getOpts()
	return opts.Websocket.TLSConfig, nil  // ⚠️ Returns potentially different config
}

// Line 1171-1172: WebSocket setup
config = o.TLSConfig.Clone()
config.GetConfigForClient = s.wsGetTLSConfig  // ⚠️ Sets callback
```

**Vulnerability Details**:
- WebSocket TLS config (`opts.Websocket.TLSConfig`) can be configured separately from the main server
- If these configs have different `ClientAuth` or `ClientCAs` settings, session tickets are still shared
- Less severe than monitoring endpoint because WebSocket and main server typically use separate TLS configs

## Session Ticket Key Sharing

**Current State**:
- NATS Server does NOT explicitly configure session ticket keys
- No usage of `SetSessionTicketKeys()` found in codebase
- No usage of `SessionTicketsDisabled` found in codebase

This means session ticket keys are **implicitly shared** between parent and child configs when using `GetConfigForClient`, which is the exact scenario the CVE addresses.

## Mitigation Options

### Option 1: Explicitly Set Session Ticket Keys (Recommended)
For each config returned by `GetConfigForClient`, explicitly set unique session ticket keys to prevent sharing:

```go
func (s *Server) getMonitoringTLSConfig(_ *tls.ClientHelloInfo) (*tls.Config, error) {
	opts := s.getOpts()
	tc := opts.TLSConfig.Clone()
	tc.ClientAuth = tls.NoClientCert
	// Generate unique session ticket keys for monitoring endpoint
	tc.SetSessionTicketKeys([][32]byte{})  // Empty keys = generate new ones
	return tc, nil
}
```

### Option 2: Disable Session Tickets
If session resumption is not needed:

```go
config.SessionTicketsDisabled = true
```

### Option 3: Use VerifyConnection Instead
The CVE notes that `VerifyConnection` is called on every connection (including resumed ones):

```go
config.VerifyConnection = func(cs tls.ConnectionState) error {
	// Perform verification on every connection, including resumed sessions
	return nil
}
```

### Option 4: Update Go Version
Ensure the server is built with:
- Go 1.26 RC2 or later
- Go 1.25.6 or later
- Go 1.24.12 or later

The Go fix checks that the root of the previously-verified chain is still in ClientCAs/RootCAs when resuming, which mitigates this issue.

## Recommendations

1. **Immediate**: Document this issue and verify Go version in use
2. **Short-term**: Explicitly set session ticket keys in `GetConfigForClient` callbacks to prevent sharing
3. **Long-term**: Review TLS configuration strategy - consider if monitoring endpoint needs to use same base TLS config as main server

## Affected Code Locations

### Files to Review/Modify:
- `server/server.go:3082-3087` (getMonitoringTLSConfig)
- `server/server.go:3114-3119` (monitoring server setup)
- `server/websocket.go:1264-1267` (wsGetTLSConfig)
- `server/websocket.go:1171-1172` (WebSocket setup)

### Related Configuration:
- `server/opts.go:5683` (sets RequireAndVerifyClientCert)
- `server/opts.go:3146` (cluster TLS config)

## Severity Assessment

**Severity**: Medium to High

**Factors**:
- ✅ Uses vulnerable pattern (`GetConfigForClient` with modified auth)
- ✅ Main server can require client certificates
- ✅ Session tickets implicitly shared (not explicitly configured)
- ✅ No explicit session ticket key management
- ⚠️ Impact depends on specific deployment configuration
- ⚠️ Monitoring endpoint typically on separate port (reduces attack surface)
- ✅ Fixed in recent Go versions (mitigation available)

**Risk**: Deployments using TLS client certificate authentication on the main server with an HTTPS monitoring endpoint are potentially vulnerable to session resumption attacks that could bypass authentication boundaries.
